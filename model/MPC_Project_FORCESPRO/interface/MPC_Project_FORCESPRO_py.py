#MPC_Project_FORCESPRO : A fast customized optimization solver.
#
#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
#
#
#This software is intended for simulation and testing purposes only. 
#Use of this software for any commercial purpose is prohibited.
#
#This program is distributed in the hope that it will be useful.
#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
#PARTICULAR PURPOSE. 
#
#EMBOTECH shall not have any liability for any damage arising from the use
#of the software.
#
#This Agreement shall exclusively be governed by and interpreted in 
#accordance with the laws of Switzerland, excluding its principles
#of conflict of laws. The Courts of Zurich-City shall have exclusive 
#jurisdiction in case of any dispute.
#
#def __init__():
'''
a Python wrapper for a fast solver generated by FORCESPRO v5.1.0

   OUTPUT = MPC_Project_FORCESPRO_py.MPC_Project_FORCESPRO_solve(PARAMS) solves a multistage problem
   subject to the parameters supplied in the following dictionary:
       PARAMS['xinit'] - column vector of length 3
       PARAMS['linear_model1'] - matrix of size [3 x 5]
       PARAMS['linear_model2'] - matrix of size [3 x 5]
       PARAMS['linear_model3'] - matrix of size [3 x 5]
       PARAMS['linear_model4'] - matrix of size [3 x 5]
       PARAMS['linear_model5'] - matrix of size [3 x 5]
       PARAMS['linear_model6'] - matrix of size [3 x 5]
       PARAMS['linear_model7'] - matrix of size [3 x 5]
       PARAMS['linear_model8'] - matrix of size [3 x 5]
       PARAMS['linear_model9'] - matrix of size [3 x 5]
       PARAMS['linear_model10'] - matrix of size [3 x 5]
       PARAMS['linear_model11'] - matrix of size [3 x 5]
       PARAMS['linear_model12'] - matrix of size [3 x 5]
       PARAMS['linear_model13'] - matrix of size [3 x 5]
       PARAMS['linear_model14'] - matrix of size [3 x 5]
       PARAMS['linear_model15'] - matrix of size [3 x 5]
       PARAMS['linear_model16'] - matrix of size [3 x 5]
       PARAMS['linear_model17'] - matrix of size [3 x 5]
       PARAMS['linear_model18'] - matrix of size [3 x 5]
       PARAMS['linear_model19'] - matrix of size [3 x 5]
       PARAMS['linear_model20'] - matrix of size [3 x 5]
       PARAMS['linear_model21'] - matrix of size [3 x 5]
       PARAMS['linear_model22'] - matrix of size [3 x 5]
       PARAMS['linear_model23'] - matrix of size [3 x 5]
       PARAMS['linear_model24'] - matrix of size [3 x 5]
       PARAMS['linear_model25'] - matrix of size [3 x 5]
       PARAMS['linear_model26'] - matrix of size [3 x 5]
       PARAMS['linear_model27'] - matrix of size [3 x 5]
       PARAMS['linear_model28'] - matrix of size [3 x 5]
       PARAMS['linear_model29'] - matrix of size [3 x 5]
       PARAMS['linear_model30'] - matrix of size [3 x 5]
       PARAMS['linear_model31'] - matrix of size [3 x 5]
       PARAMS['linear_model32'] - matrix of size [3 x 5]
       PARAMS['linear_model33'] - matrix of size [3 x 5]
       PARAMS['linear_model34'] - matrix of size [3 x 5]
       PARAMS['linear_model35'] - matrix of size [3 x 5]
       PARAMS['linear_model36'] - matrix of size [3 x 5]
       PARAMS['linear_model37'] - matrix of size [3 x 5]
       PARAMS['linear_model38'] - matrix of size [3 x 5]
       PARAMS['linear_model39'] - matrix of size [3 x 5]
       PARAMS['linear_model40'] - matrix of size [3 x 5]
       PARAMS['linear_model41'] - matrix of size [3 x 5]
       PARAMS['linear_model42'] - matrix of size [3 x 5]
       PARAMS['linear_model43'] - matrix of size [3 x 5]
       PARAMS['linear_model44'] - matrix of size [3 x 5]
       PARAMS['linear_model45'] - matrix of size [3 x 5]
       PARAMS['linear_model46'] - matrix of size [3 x 5]
       PARAMS['linear_model47'] - matrix of size [3 x 5]
       PARAMS['linear_model48'] - matrix of size [3 x 5]
       PARAMS['linear_model49'] - matrix of size [3 x 5]

   OUTPUT returns the values of the last iteration of the solver where
       OUTPUT['output'] - column vector of size 50

   [OUTPUT, EXITFLAG] = MPC_Project_FORCESPRO_py.MPC_Project_FORCESPRO_solve(PARAMS) returns additionally
   the integer EXITFLAG indicating the state of the solution with 
       1 - Optimal solution has been found (subject to desired accuracy)
       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
       0 - Timeout - maximum number of iterations reached
      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
     -10 - The convex solver could not proceed due to an internal error
    -100 - License error

   [OUTPUT, EXITFLAG, INFO] = MPC_Project_FORCESPRO_py.MPC_Project_FORCESPRO_solve(PARAMS) returns 
   additional information about the last iterate:
       INFO.it        - number of iterations that lead to this result
       INFO.it2opt    - number of convex solves
       INFO.res_eq    - max. equality constraint residual
       INFO.res_ineq  - max. inequality constraint residual
       INFO.pobj      - primal objective
       INFO.dobj      - dual objective
       INFO.dgap      - duality gap := pobj - dobj
       INFO.rdgap     - relative duality gap := |dgap / pobj|
       INFO.gradient_lag_norm - infinity norm of gradient of Lagrangian
       INFO.mu        - duality measure
       INFO.sigma     - centering parameter
       INFO.lsit_aff  - iterations of affine line search
       INFO.lsit_cc   - iterations of line search (combined direction)
       INFO.step_aff  - step size (affine direction)
       INFO.step_cc   - step size (centering direction)
       INFO.solvetime - Time needed for solve (wall clock time)

 See also COPYING

'''

import ctypes
import os
import numpy as np
import numpy.ctypeslib as npct
import sys

#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'MPC_Project_FORCESPRO/lib/MPC_Project_FORCESPRO.dll')) 
try:
    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'MPC_Project_FORCESPRO/lib/MPC_Project_FORCESPRO.dll'))
    csolver = getattr(_lib,'MPC_Project_FORCESPRO_solve')
except:
    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'MPC_Project_FORCESPRO/lib/libMPC_Project_FORCESPRO.dll'))
    csolver = getattr(_lib,'MPC_Project_FORCESPRO_solve')

class MPC_Project_FORCESPRO_params_ctypes(ctypes.Structure):
#    @classmethod
#    def from_param(self):
#        return self
    _fields_ = [('xinit', ctypes.c_double * 3),
('linear_model1', ctypes.c_double * 15),
('linear_model2', ctypes.c_double * 15),
('linear_model3', ctypes.c_double * 15),
('linear_model4', ctypes.c_double * 15),
('linear_model5', ctypes.c_double * 15),
('linear_model6', ctypes.c_double * 15),
('linear_model7', ctypes.c_double * 15),
('linear_model8', ctypes.c_double * 15),
('linear_model9', ctypes.c_double * 15),
('linear_model10', ctypes.c_double * 15),
('linear_model11', ctypes.c_double * 15),
('linear_model12', ctypes.c_double * 15),
('linear_model13', ctypes.c_double * 15),
('linear_model14', ctypes.c_double * 15),
('linear_model15', ctypes.c_double * 15),
('linear_model16', ctypes.c_double * 15),
('linear_model17', ctypes.c_double * 15),
('linear_model18', ctypes.c_double * 15),
('linear_model19', ctypes.c_double * 15),
('linear_model20', ctypes.c_double * 15),
('linear_model21', ctypes.c_double * 15),
('linear_model22', ctypes.c_double * 15),
('linear_model23', ctypes.c_double * 15),
('linear_model24', ctypes.c_double * 15),
('linear_model25', ctypes.c_double * 15),
('linear_model26', ctypes.c_double * 15),
('linear_model27', ctypes.c_double * 15),
('linear_model28', ctypes.c_double * 15),
('linear_model29', ctypes.c_double * 15),
('linear_model30', ctypes.c_double * 15),
('linear_model31', ctypes.c_double * 15),
('linear_model32', ctypes.c_double * 15),
('linear_model33', ctypes.c_double * 15),
('linear_model34', ctypes.c_double * 15),
('linear_model35', ctypes.c_double * 15),
('linear_model36', ctypes.c_double * 15),
('linear_model37', ctypes.c_double * 15),
('linear_model38', ctypes.c_double * 15),
('linear_model39', ctypes.c_double * 15),
('linear_model40', ctypes.c_double * 15),
('linear_model41', ctypes.c_double * 15),
('linear_model42', ctypes.c_double * 15),
('linear_model43', ctypes.c_double * 15),
('linear_model44', ctypes.c_double * 15),
('linear_model45', ctypes.c_double * 15),
('linear_model46', ctypes.c_double * 15),
('linear_model47', ctypes.c_double * 15),
('linear_model48', ctypes.c_double * 15),
('linear_model49', ctypes.c_double * 15),
]

MPC_Project_FORCESPRO_params = {'xinit' : np.array([]),
'linear_model1' : np.array([]),
'linear_model2' : np.array([]),
'linear_model3' : np.array([]),
'linear_model4' : np.array([]),
'linear_model5' : np.array([]),
'linear_model6' : np.array([]),
'linear_model7' : np.array([]),
'linear_model8' : np.array([]),
'linear_model9' : np.array([]),
'linear_model10' : np.array([]),
'linear_model11' : np.array([]),
'linear_model12' : np.array([]),
'linear_model13' : np.array([]),
'linear_model14' : np.array([]),
'linear_model15' : np.array([]),
'linear_model16' : np.array([]),
'linear_model17' : np.array([]),
'linear_model18' : np.array([]),
'linear_model19' : np.array([]),
'linear_model20' : np.array([]),
'linear_model21' : np.array([]),
'linear_model22' : np.array([]),
'linear_model23' : np.array([]),
'linear_model24' : np.array([]),
'linear_model25' : np.array([]),
'linear_model26' : np.array([]),
'linear_model27' : np.array([]),
'linear_model28' : np.array([]),
'linear_model29' : np.array([]),
'linear_model30' : np.array([]),
'linear_model31' : np.array([]),
'linear_model32' : np.array([]),
'linear_model33' : np.array([]),
'linear_model34' : np.array([]),
'linear_model35' : np.array([]),
'linear_model36' : np.array([]),
'linear_model37' : np.array([]),
'linear_model38' : np.array([]),
'linear_model39' : np.array([]),
'linear_model40' : np.array([]),
'linear_model41' : np.array([]),
'linear_model42' : np.array([]),
'linear_model43' : np.array([]),
'linear_model44' : np.array([]),
'linear_model45' : np.array([]),
'linear_model46' : np.array([]),
'linear_model47' : np.array([]),
'linear_model48' : np.array([]),
'linear_model49' : np.array([]),
}
params = {'xinit' : np.array([]),
'linear_model1' : np.array([]),
'linear_model2' : np.array([]),
'linear_model3' : np.array([]),
'linear_model4' : np.array([]),
'linear_model5' : np.array([]),
'linear_model6' : np.array([]),
'linear_model7' : np.array([]),
'linear_model8' : np.array([]),
'linear_model9' : np.array([]),
'linear_model10' : np.array([]),
'linear_model11' : np.array([]),
'linear_model12' : np.array([]),
'linear_model13' : np.array([]),
'linear_model14' : np.array([]),
'linear_model15' : np.array([]),
'linear_model16' : np.array([]),
'linear_model17' : np.array([]),
'linear_model18' : np.array([]),
'linear_model19' : np.array([]),
'linear_model20' : np.array([]),
'linear_model21' : np.array([]),
'linear_model22' : np.array([]),
'linear_model23' : np.array([]),
'linear_model24' : np.array([]),
'linear_model25' : np.array([]),
'linear_model26' : np.array([]),
'linear_model27' : np.array([]),
'linear_model28' : np.array([]),
'linear_model29' : np.array([]),
'linear_model30' : np.array([]),
'linear_model31' : np.array([]),
'linear_model32' : np.array([]),
'linear_model33' : np.array([]),
'linear_model34' : np.array([]),
'linear_model35' : np.array([]),
'linear_model36' : np.array([]),
'linear_model37' : np.array([]),
'linear_model38' : np.array([]),
'linear_model39' : np.array([]),
'linear_model40' : np.array([]),
'linear_model41' : np.array([]),
'linear_model42' : np.array([]),
'linear_model43' : np.array([]),
'linear_model44' : np.array([]),
'linear_model45' : np.array([]),
'linear_model46' : np.array([]),
'linear_model47' : np.array([]),
'linear_model48' : np.array([]),
'linear_model49' : np.array([]),
}
MPC_Project_FORCESPRO_params_types = {'xinit' : np.float64,
'linear_model1' : np.float64,
'linear_model2' : np.float64,
'linear_model3' : np.float64,
'linear_model4' : np.float64,
'linear_model5' : np.float64,
'linear_model6' : np.float64,
'linear_model7' : np.float64,
'linear_model8' : np.float64,
'linear_model9' : np.float64,
'linear_model10' : np.float64,
'linear_model11' : np.float64,
'linear_model12' : np.float64,
'linear_model13' : np.float64,
'linear_model14' : np.float64,
'linear_model15' : np.float64,
'linear_model16' : np.float64,
'linear_model17' : np.float64,
'linear_model18' : np.float64,
'linear_model19' : np.float64,
'linear_model20' : np.float64,
'linear_model21' : np.float64,
'linear_model22' : np.float64,
'linear_model23' : np.float64,
'linear_model24' : np.float64,
'linear_model25' : np.float64,
'linear_model26' : np.float64,
'linear_model27' : np.float64,
'linear_model28' : np.float64,
'linear_model29' : np.float64,
'linear_model30' : np.float64,
'linear_model31' : np.float64,
'linear_model32' : np.float64,
'linear_model33' : np.float64,
'linear_model34' : np.float64,
'linear_model35' : np.float64,
'linear_model36' : np.float64,
'linear_model37' : np.float64,
'linear_model38' : np.float64,
'linear_model39' : np.float64,
'linear_model40' : np.float64,
'linear_model41' : np.float64,
'linear_model42' : np.float64,
'linear_model43' : np.float64,
'linear_model44' : np.float64,
'linear_model45' : np.float64,
'linear_model46' : np.float64,
'linear_model47' : np.float64,
'linear_model48' : np.float64,
'linear_model49' : np.float64,
}

class MPC_Project_FORCESPRO_outputs_ctypes(ctypes.Structure):
#    @classmethod
#    def from_param(self):
#        return self
    _fields_ = [('output', ctypes.c_double * 50),
]

MPC_Project_FORCESPRO_outputs = {'output' : np.array([]),
}


class MPC_Project_FORCESPRO_info(ctypes.Structure):
#    @classmethod
#    def from_param(self):
#        return self
    _fields_ = [('it', ctypes.c_int32),
('it2opt', ctypes.c_int32),
('res_eq', ctypes.c_double),
('res_ineq', ctypes.c_double),
('pobj', ctypes.c_double),
('dobj', ctypes.c_double),
('dgap', ctypes.c_double),
('rdgap', ctypes.c_double),
('gradient_lag_norm', ctypes.c_double),
('mu', ctypes.c_double),
('mu_aff', ctypes.c_double),
('sigma', ctypes.c_double),
('lsit_aff', ctypes.c_int32),
('lsit_cc', ctypes.c_int32),
('step_aff', ctypes.c_double),
('step_cc', ctypes.c_double),
('solvetime', ctypes.c_double)
]

class FILE(ctypes.Structure):
        pass
if sys.version_info.major == 2:
    PyFile_AsFile = ctypes.pythonapi.PyFile_AsFile # problem here with python 3 http://stackoverflow.com/questions/16130268/python-3-replacement-for-pyfile-asfile
    PyFile_AsFile.argtypes = [ctypes.py_object]
    PyFile_AsFile.restype = ctypes.POINTER(FILE)

# determine data types for solver function prototype 
csolver.argtypes = ( ctypes.POINTER(MPC_Project_FORCESPRO_params_ctypes), ctypes.POINTER(MPC_Project_FORCESPRO_outputs_ctypes), ctypes.POINTER(MPC_Project_FORCESPRO_info), ctypes.POINTER(FILE))
csolver.restype = ctypes.c_int

def MPC_Project_FORCESPRO_solve(params_arg):
    '''
a Python wrapper for a fast solver generated by FORCESPRO v5.1.0

   OUTPUT = MPC_Project_FORCESPRO_py.MPC_Project_FORCESPRO_solve(PARAMS) solves a multistage problem
   subject to the parameters supplied in the following dictionary:
       PARAMS['xinit'] - column vector of length 3
       PARAMS['linear_model1'] - matrix of size [3 x 5]
       PARAMS['linear_model2'] - matrix of size [3 x 5]
       PARAMS['linear_model3'] - matrix of size [3 x 5]
       PARAMS['linear_model4'] - matrix of size [3 x 5]
       PARAMS['linear_model5'] - matrix of size [3 x 5]
       PARAMS['linear_model6'] - matrix of size [3 x 5]
       PARAMS['linear_model7'] - matrix of size [3 x 5]
       PARAMS['linear_model8'] - matrix of size [3 x 5]
       PARAMS['linear_model9'] - matrix of size [3 x 5]
       PARAMS['linear_model10'] - matrix of size [3 x 5]
       PARAMS['linear_model11'] - matrix of size [3 x 5]
       PARAMS['linear_model12'] - matrix of size [3 x 5]
       PARAMS['linear_model13'] - matrix of size [3 x 5]
       PARAMS['linear_model14'] - matrix of size [3 x 5]
       PARAMS['linear_model15'] - matrix of size [3 x 5]
       PARAMS['linear_model16'] - matrix of size [3 x 5]
       PARAMS['linear_model17'] - matrix of size [3 x 5]
       PARAMS['linear_model18'] - matrix of size [3 x 5]
       PARAMS['linear_model19'] - matrix of size [3 x 5]
       PARAMS['linear_model20'] - matrix of size [3 x 5]
       PARAMS['linear_model21'] - matrix of size [3 x 5]
       PARAMS['linear_model22'] - matrix of size [3 x 5]
       PARAMS['linear_model23'] - matrix of size [3 x 5]
       PARAMS['linear_model24'] - matrix of size [3 x 5]
       PARAMS['linear_model25'] - matrix of size [3 x 5]
       PARAMS['linear_model26'] - matrix of size [3 x 5]
       PARAMS['linear_model27'] - matrix of size [3 x 5]
       PARAMS['linear_model28'] - matrix of size [3 x 5]
       PARAMS['linear_model29'] - matrix of size [3 x 5]
       PARAMS['linear_model30'] - matrix of size [3 x 5]
       PARAMS['linear_model31'] - matrix of size [3 x 5]
       PARAMS['linear_model32'] - matrix of size [3 x 5]
       PARAMS['linear_model33'] - matrix of size [3 x 5]
       PARAMS['linear_model34'] - matrix of size [3 x 5]
       PARAMS['linear_model35'] - matrix of size [3 x 5]
       PARAMS['linear_model36'] - matrix of size [3 x 5]
       PARAMS['linear_model37'] - matrix of size [3 x 5]
       PARAMS['linear_model38'] - matrix of size [3 x 5]
       PARAMS['linear_model39'] - matrix of size [3 x 5]
       PARAMS['linear_model40'] - matrix of size [3 x 5]
       PARAMS['linear_model41'] - matrix of size [3 x 5]
       PARAMS['linear_model42'] - matrix of size [3 x 5]
       PARAMS['linear_model43'] - matrix of size [3 x 5]
       PARAMS['linear_model44'] - matrix of size [3 x 5]
       PARAMS['linear_model45'] - matrix of size [3 x 5]
       PARAMS['linear_model46'] - matrix of size [3 x 5]
       PARAMS['linear_model47'] - matrix of size [3 x 5]
       PARAMS['linear_model48'] - matrix of size [3 x 5]
       PARAMS['linear_model49'] - matrix of size [3 x 5]

   OUTPUT returns the values of the last iteration of the solver where
       OUTPUT['output'] - column vector of size 50

   [OUTPUT, EXITFLAG] = MPC_Project_FORCESPRO_py.MPC_Project_FORCESPRO_solve(PARAMS) returns additionally
   the integer EXITFLAG indicating the state of the solution with 
       1 - Optimal solution has been found (subject to desired accuracy)
       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
       0 - Timeout - maximum number of iterations reached
      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
     -10 - The convex solver could not proceed due to an internal error
    -100 - License error

   [OUTPUT, EXITFLAG, INFO] = MPC_Project_FORCESPRO_py.MPC_Project_FORCESPRO_solve(PARAMS) returns 
   additional information about the last iterate:
       INFO.it        - number of iterations that lead to this result
       INFO.it2opt    - number of convex solves
       INFO.res_eq    - max. equality constraint residual
       INFO.res_ineq  - max. inequality constraint residual
       INFO.pobj      - primal objective
       INFO.dobj      - dual objective
       INFO.dgap      - duality gap := pobj - dobj
       INFO.rdgap     - relative duality gap := |dgap / pobj|
       INFO.gradient_lag_norm - infinity norm of gradient of Lagrangian
       INFO.mu        - duality measure
       INFO.sigma     - centering parameter
       INFO.lsit_aff  - iterations of affine line search
       INFO.lsit_cc   - iterations of line search (combined direction)
       INFO.step_aff  - step size (affine direction)
       INFO.step_cc   - step size (centering direction)
       INFO.solvetime - Time needed for solve (wall clock time)

 See also COPYING

    '''
    global _lib

    # convert parameters
    params_py = MPC_Project_FORCESPRO_params_ctypes()
    for par in params_arg:
        try:
            #setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='A')))
            if isinstance(getattr(params_py, par), ctypes.Array):
                params_arg[par] = np.require(params_arg[par], dtype=MPC_Project_FORCESPRO_params_types[par], requirements='F')
                setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='F')))
            else:
                setattr(params_py, par, params_arg[par])
        except:
            raise ValueError('Parameter ' + par + ' does not have the appropriate dimensions or data type. Please use numpy arrays for parameters.')
    
    outputs_py = MPC_Project_FORCESPRO_outputs_ctypes()
    info_py = MPC_Project_FORCESPRO_info()
    if sys.version_info.major == 2:
        if sys.platform.startswith('win'):
            fp = None # if set to none, the solver prints to stdout by default - necessary because we have an access violation otherwise under windows
        else:
            #fp = open('stdout_temp.txt','w')
            fp = sys.stdout
        try:
            PyFile_AsFile.restype = ctypes.POINTER(FILE)
            exitflag = _lib.MPC_Project_FORCESPRO_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), PyFile_AsFile(fp)  )
            #fp = open('stdout_temp.txt','r')
            #print (fp.read())
            #fp.close()
        except:
            #print 'Problem with solver'
            raise
    elif sys.version_info.major == 3:
        if sys.platform.startswith('win'):
            libc = ctypes.cdll.msvcrt
        elif sys.platform.startswith('darwin'):
            libc = ctypes.CDLL('libc.dylib')
        else:
            libc = ctypes.CDLL('libc.so.6')       # Open libc
        cfopen = getattr(libc,'fopen')        # Get its fopen
        cfopen.restype = ctypes.POINTER(FILE) # Yes, fopen gives a file pointer
        cfopen.argtypes = [ctypes.c_char_p, ctypes.c_char_p] # Yes, fopen gives a file pointer 
        fp = cfopen('stdout_temp.txt'.encode('utf-8'),'w'.encode('utf-8'))    # Use that fopen 

        try:
            if sys.platform.startswith('win'):
                exitflag = _lib.MPC_Project_FORCESPRO_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), None )
            else:
                exitflag = _lib.MPC_Project_FORCESPRO_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), fp )
            libc.fclose(fp)
            fptemp = open('stdout_temp.txt','r')
            print (fptemp.read())
            fptemp.close()            
        except:
            #print 'Problem with solver'
            raise

    # convert outputs
    for out in MPC_Project_FORCESPRO_outputs:
        MPC_Project_FORCESPRO_outputs[out] = npct.as_array(getattr(outputs_py,out))

    return MPC_Project_FORCESPRO_outputs,int(exitflag),info_py

solve = MPC_Project_FORCESPRO_solve


