Index: model/FORCENLPsolver/FORCENLPsolver.m
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>% FORCENLPsolver - a fast solver generated by FORCESPRO v5.1.0\n%\n%   OUTPUT = FORCENLPsolver(PARAMS) solves a multistage problem\n%   subject to the parameters supplied in the following struct:\n%       PARAMS.xinit - column vector of length 3\n%       PARAMS.x0 - column vector of length 100\n%       PARAMS.all_parameters - column vector of length 60\n%       PARAMS.reinitialize - scalar\n%\n%   OUTPUT returns the values of the last iteration of the solver where\n%       OUTPUT.x01 - column vector of size 5\n%       OUTPUT.x02 - column vector of size 5\n%       OUTPUT.x03 - column vector of size 5\n%       OUTPUT.x04 - column vector of size 5\n%       OUTPUT.x05 - column vector of size 5\n%       OUTPUT.x06 - column vector of size 5\n%       OUTPUT.x07 - column vector of size 5\n%       OUTPUT.x08 - column vector of size 5\n%       OUTPUT.x09 - column vector of size 5\n%       OUTPUT.x10 - column vector of size 5\n%       OUTPUT.x11 - column vector of size 5\n%       OUTPUT.x12 - column vector of size 5\n%       OUTPUT.x13 - column vector of size 5\n%       OUTPUT.x14 - column vector of size 5\n%       OUTPUT.x15 - column vector of size 5\n%       OUTPUT.x16 - column vector of size 5\n%       OUTPUT.x17 - column vector of size 5\n%       OUTPUT.x18 - column vector of size 5\n%       OUTPUT.x19 - column vector of size 5\n%       OUTPUT.x20 - column vector of size 5\n%\n%   [OUTPUT, EXITFLAG] = FORCENLPsolver(PARAMS) returns additionally\n%   the integer EXITFLAG indicating the state of the solution with \n%       1 - OPTIMAL solution has been found (subject to desired accuracy)\n%       0 - Timeout - maximum number of iterations reached\n%      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.\n%      -8 - QP solver failed. The QP solver failed to converge. Check your variable bounds and inequality constraints. Consider scaling your problem.\n%    -100 - License error\n%\n%   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver(PARAMS) returns \n%   additional information about the last iterate:\n%       INFO.it        - number of iterations that lead to this result\n%       INFO.res_eq    - max. equality constraint residual\n%       INFO.res_ineq  - max. inequality constraint residual\n%       INFO.pobj      - primal objective\n%       INFO.solvetime - Time needed for solve (wall clock time)\n%       INFO.fevalstime - Time needed for function evaluations (wall clock time)\n%       INFO.QPtime - Cumulative time spent in QP solver (wall clock time)\n%\n% See also COPYING\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver.m b/model/FORCENLPsolver/FORCENLPsolver.m
--- a/model/FORCENLPsolver/FORCENLPsolver.m	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/FORCENLPsolver.m	(date 1646039467384)
@@ -2,32 +2,22 @@
 %
 %   OUTPUT = FORCENLPsolver(PARAMS) solves a multistage problem
 %   subject to the parameters supplied in the following struct:
-%       PARAMS.xinit - column vector of length 3
+%       PARAMS.xinit - column vector of length 6
 %       PARAMS.x0 - column vector of length 100
 %       PARAMS.all_parameters - column vector of length 60
 %       PARAMS.reinitialize - scalar
 %
 %   OUTPUT returns the values of the last iteration of the solver where
-%       OUTPUT.x01 - column vector of size 5
-%       OUTPUT.x02 - column vector of size 5
-%       OUTPUT.x03 - column vector of size 5
-%       OUTPUT.x04 - column vector of size 5
-%       OUTPUT.x05 - column vector of size 5
-%       OUTPUT.x06 - column vector of size 5
-%       OUTPUT.x07 - column vector of size 5
-%       OUTPUT.x08 - column vector of size 5
-%       OUTPUT.x09 - column vector of size 5
-%       OUTPUT.x10 - column vector of size 5
-%       OUTPUT.x11 - column vector of size 5
-%       OUTPUT.x12 - column vector of size 5
-%       OUTPUT.x13 - column vector of size 5
-%       OUTPUT.x14 - column vector of size 5
-%       OUTPUT.x15 - column vector of size 5
-%       OUTPUT.x16 - column vector of size 5
-%       OUTPUT.x17 - column vector of size 5
-%       OUTPUT.x18 - column vector of size 5
-%       OUTPUT.x19 - column vector of size 5
-%       OUTPUT.x20 - column vector of size 5
+%       OUTPUT.x01 - column vector of size 10
+%       OUTPUT.x02 - column vector of size 10
+%       OUTPUT.x03 - column vector of size 10
+%       OUTPUT.x04 - column vector of size 10
+%       OUTPUT.x05 - column vector of size 10
+%       OUTPUT.x06 - column vector of size 10
+%       OUTPUT.x07 - column vector of size 10
+%       OUTPUT.x08 - column vector of size 10
+%       OUTPUT.x09 - column vector of size 10
+%       OUTPUT.x10 - column vector of size 10
 %
 %   [OUTPUT, EXITFLAG] = FORCENLPsolver(PARAMS) returns additionally
 %   the integer EXITFLAG indicating the state of the solution with 
Index: model/FORCENLPsolver/FORCENLPsolver_interface.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * CasADi to FORCESPRO Template - missing information to be filled in by createCasadi.m \n * (C) embotech AG, Zurich, Switzerland, 2013-2021. All rights reserved.\n *\n * This file is part of the FORCESPRO client, and carries the same license.\n */ \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \n#include \"include/FORCENLPsolver.h\"\n\n#ifndef NULL\n#define NULL ((void *) 0)\n#endif\n\n#include \"FORCENLPsolver_model.h\"\n\n\n\n/* copies data from sparse matrix into a dense one */\nstatic void sparse2fullcopy(solver_int32_default nrow, solver_int32_default ncol, const solver_int32_default *colidx, const solver_int32_default *row, FORCENLPsolver_callback_float *data, FORCENLPsolver_float *out)\n{\n    solver_int32_default i, j;\n    \n    /* copy data into dense matrix */\n    for(i=0; i<ncol; i++)\n    {\n        for(j=colidx[i]; j<colidx[i+1]; j++)\n        {\n            out[i*nrow + row[j]] = ((FORCENLPsolver_float) data[j]);\n        }\n    }\n}\n\n\n\n\n/* CasADi to FORCESPRO interface */\nextern void FORCENLPsolver_casadi2forces(FORCENLPsolver_float *x,        /* primal vars                                         */\n                                 FORCENLPsolver_float *y,        /* eq. constraint multiplers                           */\n                                 FORCENLPsolver_float *l,        /* ineq. constraint multipliers                        */\n                                 FORCENLPsolver_float *p,        /* parameters                                          */\n                                 FORCENLPsolver_float *f,        /* objective function (scalar)                         */\n                                 FORCENLPsolver_float *nabla_f,  /* gradient of objective function                      */\n                                 FORCENLPsolver_float *c,        /* dynamics                                            */\n                                 FORCENLPsolver_float *nabla_c,  /* Jacobian of the dynamics (column major)             */\n                                 FORCENLPsolver_float *h,        /* inequality constraints                              */\n                                 FORCENLPsolver_float *nabla_h,  /* Jacobian of inequality constraints (column major)   */\n                                 FORCENLPsolver_float *hess,     /* Hessian (column major)                              */\n                                 solver_int32_default stage,     /* stage number (0 indexed)                           */\n\t\t\t\t\t\t\t\t solver_int32_default iteration, /* iteration number of solver                         */\n\t\t\t\t\t\t\t\t solver_int32_default threadID   /* Id of caller thread                                */)\n{\n    /* CasADi input and output arrays */\n    const FORCENLPsolver_callback_float *in[4];\n    FORCENLPsolver_callback_float *out[7];\n\t\n\n\t/* Allocate working arrays for CasADi */\n\tFORCENLPsolver_float w[14];\n\t\n    /* temporary storage for CasADi sparse output */\n    FORCENLPsolver_callback_float this_f;\n    FORCENLPsolver_float nabla_f_sparse[5];\n    \n    \n    FORCENLPsolver_float c_sparse[3];\n    FORCENLPsolver_float nabla_c_sparse[10];\n            \n    \n    /* pointers to row and column info for \n     * column compressed format used by CasADi */\n    solver_int32_default nrow, ncol;\n    const solver_int32_default *colind, *row;\n    \n    /* set inputs for CasADi */\n    in[0] = x;\n    in[1] = p;\n    in[2] = l;\n    in[3] = y;\n\n\tif ((0 <= stage && stage <= 18))\n\t{\n\t\t\n\t\t\n\t\tif( &this_f )\n\t\t{\n\t\t\tout[0] = &this_f;\n\t\t\tFORCENLPsolver_objective_0(in, out, NULL, w, 0);\n\t\t}\n\t\t\n\t\tif( nabla_f )\n\t\t{\n\t\t\tout[0] = nabla_f_sparse;\n\t\t\tFORCENLPsolver_dobjective_0(in, out, NULL, w, 0);\n\t\t\tnrow = FORCENLPsolver_dobjective_0_sparsity_out(0)[0];\n\t\t\tncol = FORCENLPsolver_dobjective_0_sparsity_out(0)[1];\n\t\t\tcolind = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2;\n\t\t\trow = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2 + (ncol + 1);\n\t\t\tsparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);\n\t\t}\n\t\t\n\t\tif( c )\n\t\t{\n\t\t\tout[0] = c_sparse;\n\t\t\tFORCENLPsolver_dynamics_0(in, out, NULL, w, 0);\n\t\t\tnrow = FORCENLPsolver_dynamics_0_sparsity_out(0)[0];\n\t\t\tncol = FORCENLPsolver_dynamics_0_sparsity_out(0)[1];\n\t\t\tcolind = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2;\n\t\t\trow = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2 + (ncol + 1);\n\t\t\tsparse2fullcopy(nrow, ncol, colind, row, c_sparse, c);\n\t\t}\n\t\t\n\t\tif( nabla_c )\n\t\t{\n\t\t\tout[0] = nabla_c_sparse;\n\t\t\tFORCENLPsolver_ddynamics_0(in, out, NULL, w, 0);\n\t\t\tnrow = FORCENLPsolver_ddynamics_0_sparsity_out(0)[0];\n\t\t\tncol = FORCENLPsolver_ddynamics_0_sparsity_out(0)[1];\n\t\t\tcolind = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2;\n\t\t\trow = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2 + (ncol + 1);\n\t\t\tsparse2fullcopy(nrow, ncol, colind, row, nabla_c_sparse, nabla_c);\n\t\t}\n\t}\n\tif ((19 == stage))\n\t{\n\t\t\n\t\t\n\t\tif( &this_f )\n\t\t{\n\t\t\tout[0] = &this_f;\n\t\t\tFORCENLPsolver_objective_1(in, out, NULL, w, 0);\n\t\t}\n\t\t\n\t\tif( nabla_f )\n\t\t{\n\t\t\tout[0] = nabla_f_sparse;\n\t\t\tFORCENLPsolver_dobjective_1(in, out, NULL, w, 0);\n\t\t\tnrow = FORCENLPsolver_dobjective_1_sparsity_out(0)[0];\n\t\t\tncol = FORCENLPsolver_dobjective_1_sparsity_out(0)[1];\n\t\t\tcolind = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2;\n\t\t\trow = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2 + (ncol + 1);\n\t\t\tsparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);\n\t\t}\n\t}\n    \n    /* add to objective */\n    if (f != NULL)\n    {\n        *f += ((FORCENLPsolver_float) this_f);\n    }\n}\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_interface.c b/model/FORCENLPsolver/FORCENLPsolver_interface.c
--- a/model/FORCENLPsolver/FORCENLPsolver_interface.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/FORCENLPsolver_interface.c	(date 1646039467412)
@@ -59,15 +59,15 @@
 	
 
 	/* Allocate working arrays for CasADi */
-	FORCENLPsolver_float w[14];
+	FORCENLPsolver_float w[22];
 	
     /* temporary storage for CasADi sparse output */
     FORCENLPsolver_callback_float this_f;
-    FORCENLPsolver_float nabla_f_sparse[5];
+    FORCENLPsolver_float nabla_f_sparse[10];
     
     
-    FORCENLPsolver_float c_sparse[3];
-    FORCENLPsolver_float nabla_c_sparse[10];
+    FORCENLPsolver_float c_sparse[6];
+    FORCENLPsolver_float nabla_c_sparse[20];
             
     
     /* pointers to row and column info for 
@@ -81,7 +81,7 @@
     in[2] = l;
     in[3] = y;
 
-	if ((0 <= stage && stage <= 18))
+	if ((0 <= stage && stage <= 8))
 	{
 		
 		
@@ -124,7 +124,7 @@
 			sparse2fullcopy(nrow, ncol, colind, row, nabla_c_sparse, nabla_c);
 		}
 	}
-	if ((19 == stage))
+	if ((9 == stage))
 	{
 		
 		
Index: model/FORCENLPsolver/FORCENLPsolver_model.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* This file was automatically generated by CasADi.\n   The CasADi copyright holders make no ownership claim of its contents. */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* How to prefix internal symbols */\n#ifdef CASADI_CODEGEN_PREFIX\n  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)\n  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID\n  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)\n#else\n  #define CASADI_PREFIX(ID) FORCENLPsolver_model_ ## ID\n#endif\n\n#include <math.h> \n#include \"FORCENLPsolver_model.h\"\n\n#ifndef casadi_real\n#define casadi_real FORCENLPsolver_float\n#endif\n\n#ifndef casadi_int\n#define casadi_int solver_int32_default\n#endif\n\n/* Add prefix to internal symbols */\n#define casadi_f0 CASADI_PREFIX(f0)\n#define casadi_f1 CASADI_PREFIX(f1)\n#define casadi_f2 CASADI_PREFIX(f2)\n#define casadi_f3 CASADI_PREFIX(f3)\n#define casadi_f4 CASADI_PREFIX(f4)\n#define casadi_f5 CASADI_PREFIX(f5)\n#define casadi_s0 CASADI_PREFIX(s0)\n#define casadi_s1 CASADI_PREFIX(s1)\n#define casadi_s2 CASADI_PREFIX(s2)\n#define casadi_s3 CASADI_PREFIX(s3)\n#define casadi_s4 CASADI_PREFIX(s4)\n#define casadi_sq CASADI_PREFIX(sq)\n\n/* Symbol visibility in DLLs */\n#if 0\n  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)\n    #if defined(STATIC_LINKED)\n      #define CASADI_SYMBOL_EXPORT\n    #else\n      #define __declspec(dllexport)\n    #endif\n  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)\n    #define __attribute__ ((visibility (\"default\")))\n  #else\n    #define CASADI_SYMBOL_EXPORT\n  #endif\n#endif\n\ncasadi_real casadi_sq(casadi_real x) { return x*x;}\n\nstatic const casadi_int casadi_s0[9] = {5, 1, 0, 5, 0, 1, 2, 3, 4};\nstatic const casadi_int casadi_s1[7] = {3, 1, 0, 3, 0, 1, 2};\nstatic const casadi_int casadi_s2[5] = {1, 1, 0, 1, 0};\nstatic const casadi_int casadi_s3[13] = {1, 5, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0};\nstatic const casadi_int casadi_s4[18] = {3, 5, 0, 2, 5, 6, 7, 10, 0, 1, 0, 1, 2, 0, 1, 0, 1, 2};\n\n/* FORCENLPsolver_objective_0:(i0[5],i1[3])->(o0) */\nstatic int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real a0, a1, a2, a3, a4;\n  a0=100.;\n  a1=arg[0]? arg[0][2] : 0;\n  a2=arg[1]? arg[1][0] : 0;\n  a3=(a1-a2);\n  a3=(a0*a3);\n  a1=(a1-a2);\n  a3=(a3*a1);\n  a1=arg[0]? arg[0][3] : 0;\n  a2=arg[1]? arg[1][1] : 0;\n  a4=(a1-a2);\n  a0=(a0*a4);\n  a1=(a1-a2);\n  a0=(a0*a1);\n  a3=(a3+a0);\n  a0=10.;\n  a1=arg[0]? arg[0][4] : 0;\n  a2=arg[1]? arg[1][2] : 0;\n  a4=(a1-a2);\n  a0=(a0*a4);\n  a1=(a1-a2);\n  a0=(a0*a1);\n  a3=(a3+a0);\n  a0=1.0000000000000001e-001;\n  a1=arg[0]? arg[0][0] : 0;\n  a1=casadi_sq(a1);\n  a1=(a0*a1);\n  a3=(a3+a1);\n  a1=arg[0]? arg[0][1] : 0;\n  a1=casadi_sq(a1);\n  a0=(a0*a1);\n  a3=(a3+a0);\n  if (res[0]!=0) res[0][0]=a3;\n  return 0;\n}\n\nint FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f0(arg, res, iw, w, mem);\n}\n\nint FORCENLPsolver_objective_0_alloc_mem(void) {\n  return 0;\n}\n\nint FORCENLPsolver_objective_0_init_mem(int mem) {\n  return 0;\n}\n\nvoid FORCENLPsolver_objective_0_free_mem(int mem) {\n}\n\nint FORCENLPsolver_objective_0_checkout(void) {\n  return 0;\n}\n\nvoid FORCENLPsolver_objective_0_release(int mem) {\n}\n\nvoid FORCENLPsolver_objective_0_incref(void) {\n}\n\nvoid FORCENLPsolver_objective_0_decref(void) {\n}\n\ncasadi_int FORCENLPsolver_objective_0_n_in(void) { return 2;}\n\ncasadi_int FORCENLPsolver_objective_0_n_out(void) { return 1;}\n\ncasadi_real FORCENLPsolver_objective_0_default_in(casadi_int i){\n  switch (i) {\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_objective_0_name_in(casadi_int i){\n  switch (i) {\n    case 0: return \"i0\";\n    case 1: return \"i1\";\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_objective_0_name_out(casadi_int i){\n  switch (i) {\n    case 0: return \"o0\";\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_objective_0_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s0;\n    case 1: return casadi_s1;\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s2;\n    default: return 0;\n  }\n}\n\nint FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 2;\n  if (sz_res) *sz_res = 1;\n  if (sz_iw) *sz_iw = 0;\n  if (sz_w) *sz_w = 0;\n  return 0;\n}\n\n/* FORCENLPsolver_dobjective_0:(i0[5],i1[3])->(o0[1x5]) */\nstatic int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real a0, a1, a2, a3;\n  a0=1.0000000000000001e-001;\n  a1=arg[0]? arg[0][0] : 0;\n  a1=(a1+a1);\n  a1=(a0*a1);\n  if (res[0]!=0) res[0][0]=a1;\n  a1=arg[0]? arg[0][1] : 0;\n  a1=(a1+a1);\n  a0=(a0*a1);\n  if (res[0]!=0) res[0][1]=a0;\n  a0=100.;\n  a1=arg[0]? arg[0][2] : 0;\n  a2=arg[1]? arg[1][0] : 0;\n  a3=(a1-a2);\n  a3=(a0*a3);\n  a1=(a1-a2);\n  a1=(a0*a1);\n  a3=(a3+a1);\n  if (res[0]!=0) res[0][2]=a3;\n  a3=arg[0]? arg[0][3] : 0;\n  a1=arg[1]? arg[1][1] : 0;\n  a2=(a3-a1);\n  a2=(a0*a2);\n  a3=(a3-a1);\n  a0=(a0*a3);\n  a2=(a2+a0);\n  if (res[0]!=0) res[0][3]=a2;\n  a2=10.;\n  a0=arg[0]? arg[0][4] : 0;\n  a3=arg[1]? arg[1][2] : 0;\n  a1=(a0-a3);\n  a1=(a2*a1);\n  a0=(a0-a3);\n  a2=(a2*a0);\n  a1=(a1+a2);\n  if (res[0]!=0) res[0][4]=a1;\n  return 0;\n}\n\nint FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f1(arg, res, iw, w, mem);\n}\n\nint FORCENLPsolver_dobjective_0_alloc_mem(void) {\n  return 0;\n}\n\nint FORCENLPsolver_dobjective_0_init_mem(int mem) {\n  return 0;\n}\n\nvoid FORCENLPsolver_dobjective_0_free_mem(int mem) {\n}\n\nint FORCENLPsolver_dobjective_0_checkout(void) {\n  return 0;\n}\n\nvoid FORCENLPsolver_dobjective_0_release(int mem) {\n}\n\nvoid FORCENLPsolver_dobjective_0_incref(void) {\n}\n\nvoid FORCENLPsolver_dobjective_0_decref(void) {\n}\n\ncasadi_int FORCENLPsolver_dobjective_0_n_in(void) { return 2;}\n\ncasadi_int FORCENLPsolver_dobjective_0_n_out(void) { return 1;}\n\ncasadi_real FORCENLPsolver_dobjective_0_default_in(casadi_int i){\n  switch (i) {\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_dobjective_0_name_in(casadi_int i){\n  switch (i) {\n    case 0: return \"i0\";\n    case 1: return \"i1\";\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_dobjective_0_name_out(casadi_int i){\n  switch (i) {\n    case 0: return \"o0\";\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_dobjective_0_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s0;\n    case 1: return casadi_s1;\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s3;\n    default: return 0;\n  }\n}\n\nint FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 2;\n  if (sz_res) *sz_res = 1;\n  if (sz_iw) *sz_iw = 0;\n  if (sz_w) *sz_w = 0;\n  return 0;\n}\n\n/* FORCENLPsolver_dynamics_0:(i0[5],i1[3])->(o0[3]) */\nstatic int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real a0, a1, a10, a2, a3, a4, a5, a6, a7, a8, a9;\n  a0=arg[0]? arg[0][2] : 0;\n  a1=8.3333333333333339e-004;\n  a2=arg[0]? arg[0][0] : 0;\n  a3=arg[0]? arg[0][4] : 0;\n  a4=cos(a3);\n  a4=(a2*a4);\n  a5=2.;\n  a6=2.5000000000000001e-003;\n  a7=arg[0]? arg[0][1] : 0;\n  a8=(a6*a7);\n  a8=(a3+a8);\n  a9=cos(a8);\n  a9=(a2*a9);\n  a9=(a5*a9);\n  a4=(a4+a9);\n  a6=(a6*a7);\n  a6=(a3+a6);\n  a9=cos(a6);\n  a9=(a2*a9);\n  a9=(a5*a9);\n  a4=(a4+a9);\n  a9=5.0000000000000001e-003;\n  a9=(a9*a7);\n  a9=(a3+a9);\n  a10=cos(a9);\n  a10=(a2*a10);\n  a4=(a4+a10);\n  a4=(a1*a4);\n  a0=(a0+a4);\n  if (res[0]!=0) res[0][0]=a0;\n  a0=arg[0]? arg[0][3] : 0;\n  a4=sin(a3);\n  a4=(a2*a4);\n  a8=sin(a8);\n  a8=(a2*a8);\n  a8=(a5*a8);\n  a4=(a4+a8);\n  a6=sin(a6);\n  a6=(a2*a6);\n  a6=(a5*a6);\n  a4=(a4+a6);\n  a9=sin(a9);\n  a2=(a2*a9);\n  a4=(a4+a2);\n  a4=(a1*a4);\n  a0=(a0+a4);\n  if (res[0]!=0) res[0][1]=a0;\n  a0=(a5*a7);\n  a0=(a7+a0);\n  a5=(a5*a7);\n  a0=(a0+a5);\n  a0=(a0+a7);\n  a1=(a1*a0);\n  a3=(a3+a1);\n  if (res[0]!=0) res[0][2]=a3;\n  return 0;\n}\n\nint FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f2(arg, res, iw, w, mem);\n}\n\nint FORCENLPsolver_dynamics_0_alloc_mem(void) {\n  return 0;\n}\n\nint FORCENLPsolver_dynamics_0_init_mem(int mem) {\n  return 0;\n}\n\nvoid FORCENLPsolver_dynamics_0_free_mem(int mem) {\n}\n\nint FORCENLPsolver_dynamics_0_checkout(void) {\n  return 0;\n}\n\nvoid FORCENLPsolver_dynamics_0_release(int mem) {\n}\n\nvoid FORCENLPsolver_dynamics_0_incref(void) {\n}\n\nvoid FORCENLPsolver_dynamics_0_decref(void) {\n}\n\ncasadi_int FORCENLPsolver_dynamics_0_n_in(void) { return 2;}\n\ncasadi_int FORCENLPsolver_dynamics_0_n_out(void) { return 1;}\n\ncasadi_real FORCENLPsolver_dynamics_0_default_in(casadi_int i){\n  switch (i) {\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_dynamics_0_name_in(casadi_int i){\n  switch (i) {\n    case 0: return \"i0\";\n    case 1: return \"i1\";\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_dynamics_0_name_out(casadi_int i){\n  switch (i) {\n    case 0: return \"o0\";\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_dynamics_0_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s0;\n    case 1: return casadi_s1;\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s1;\n    default: return 0;\n  }\n}\n\nint FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 2;\n  if (sz_res) *sz_res = 1;\n  if (sz_iw) *sz_iw = 0;\n  if (sz_w) *sz_w = 0;\n  return 0;\n}\n\n/* FORCENLPsolver_ddynamics_0:(i0[5],i1[3])->(o0[3x5,10nz]) */\nstatic int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real a0, a1, a10, a11, a12, a13, a2, a3, a4, a5, a6, a7, a8, a9;\n  a0=8.3333333333333339e-004;\n  a1=arg[0]? arg[0][4] : 0;\n  a2=cos(a1);\n  a3=2.;\n  a4=2.5000000000000001e-003;\n  a5=arg[0]? arg[0][1] : 0;\n  a6=(a4*a5);\n  a6=(a1+a6);\n  a7=cos(a6);\n  a7=(a3*a7);\n  a2=(a2+a7);\n  a7=(a4*a5);\n  a7=(a1+a7);\n  a8=cos(a7);\n  a8=(a3*a8);\n  a2=(a2+a8);\n  a8=5.0000000000000001e-003;\n  a5=(a8*a5);\n  a5=(a1+a5);\n  a9=cos(a5);\n  a2=(a2+a9);\n  a2=(a0*a2);\n  if (res[0]!=0) res[0][0]=a2;\n  a2=sin(a1);\n  a9=sin(a6);\n  a9=(a3*a9);\n  a2=(a2+a9);\n  a9=sin(a7);\n  a9=(a3*a9);\n  a2=(a2+a9);\n  a9=sin(a5);\n  a2=(a2+a9);\n  a2=(a0*a2);\n  if (res[0]!=0) res[0][1]=a2;\n  a2=arg[0]? arg[0][0] : 0;\n  a9=sin(a6);\n  a10=(a4*a9);\n  a10=(a2*a10);\n  a10=(a3*a10);\n  a11=sin(a7);\n  a12=(a4*a11);\n  a12=(a2*a12);\n  a12=(a3*a12);\n  a10=(a10+a12);\n  a12=sin(a5);\n  a13=(a8*a12);\n  a13=(a2*a13);\n  a10=(a10+a13);\n  a10=(a0*a10);\n  a10=(-a10);\n  if (res[0]!=0) res[0][2]=a10;\n  a6=cos(a6);\n  a10=(a4*a6);\n  a10=(a2*a10);\n  a10=(a3*a10);\n  a7=cos(a7);\n  a4=(a4*a7);\n  a4=(a2*a4);\n  a4=(a3*a4);\n  a10=(a10+a4);\n  a5=cos(a5);\n  a4=(a8*a5);\n  a4=(a2*a4);\n  a10=(a10+a4);\n  a10=(a0*a10);\n  if (res[0]!=0) res[0][3]=a10;\n  if (res[0]!=0) res[0][4]=a8;\n  a8=1.;\n  if (res[0]!=0) res[0][5]=a8;\n  if (res[0]!=0) res[0][6]=a8;\n  a10=sin(a1);\n  a10=(a2*a10);\n  a9=(a2*a9);\n  a9=(a3*a9);\n  a10=(a10+a9);\n  a11=(a2*a11);\n  a11=(a3*a11);\n  a10=(a10+a11);\n  a12=(a2*a12);\n  a10=(a10+a12);\n  a10=(a0*a10);\n  a10=(-a10);\n  if (res[0]!=0) res[0][7]=a10;\n  a1=cos(a1);\n  a1=(a2*a1);\n  a6=(a2*a6);\n  a6=(a3*a6);\n  a1=(a1+a6);\n  a7=(a2*a7);\n  a3=(a3*a7);\n  a1=(a1+a3);\n  a2=(a2*a5);\n  a1=(a1+a2);\n  a0=(a0*a1);\n  if (res[0]!=0) res[0][8]=a0;\n  if (res[0]!=0) res[0][9]=a8;\n  return 0;\n}\n\nint FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f3(arg, res, iw, w, mem);\n}\n\nint FORCENLPsolver_ddynamics_0_alloc_mem(void) {\n  return 0;\n}\n\nint FORCENLPsolver_ddynamics_0_init_mem(int mem) {\n  return 0;\n}\n\nvoid FORCENLPsolver_ddynamics_0_free_mem(int mem) {\n}\n\nint FORCENLPsolver_ddynamics_0_checkout(void) {\n  return 0;\n}\n\nvoid FORCENLPsolver_ddynamics_0_release(int mem) {\n}\n\nvoid FORCENLPsolver_ddynamics_0_incref(void) {\n}\n\nvoid FORCENLPsolver_ddynamics_0_decref(void) {\n}\n\ncasadi_int FORCENLPsolver_ddynamics_0_n_in(void) { return 2;}\n\ncasadi_int FORCENLPsolver_ddynamics_0_n_out(void) { return 1;}\n\ncasadi_real FORCENLPsolver_ddynamics_0_default_in(casadi_int i){\n  switch (i) {\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_ddynamics_0_name_in(casadi_int i){\n  switch (i) {\n    case 0: return \"i0\";\n    case 1: return \"i1\";\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_ddynamics_0_name_out(casadi_int i){\n  switch (i) {\n    case 0: return \"o0\";\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_ddynamics_0_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s0;\n    case 1: return casadi_s1;\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s4;\n    default: return 0;\n  }\n}\n\nint FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 2;\n  if (sz_res) *sz_res = 1;\n  if (sz_iw) *sz_iw = 0;\n  if (sz_w) *sz_w = 0;\n  return 0;\n}\n\n/* FORCENLPsolver_objective_1:(i0[5],i1[3])->(o0) */\nstatic int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real a0, a1, a2, a3, a4;\n  a0=500.;\n  a1=arg[0]? arg[0][2] : 0;\n  a2=arg[1]? arg[1][0] : 0;\n  a3=(a1-a2);\n  a3=(a0*a3);\n  a1=(a1-a2);\n  a3=(a3*a1);\n  a1=arg[0]? arg[0][3] : 0;\n  a2=arg[1]? arg[1][1] : 0;\n  a4=(a1-a2);\n  a0=(a0*a4);\n  a1=(a1-a2);\n  a0=(a0*a1);\n  a3=(a3+a0);\n  a0=100.;\n  a1=arg[0]? arg[0][4] : 0;\n  a2=arg[1]? arg[1][2] : 0;\n  a4=(a1-a2);\n  a0=(a0*a4);\n  a1=(a1-a2);\n  a0=(a0*a1);\n  a3=(a3+a0);\n  a0=1.0000000000000001e-001;\n  a1=arg[0]? arg[0][0] : 0;\n  a1=casadi_sq(a1);\n  a1=(a0*a1);\n  a3=(a3+a1);\n  a1=arg[0]? arg[0][1] : 0;\n  a1=casadi_sq(a1);\n  a0=(a0*a1);\n  a3=(a3+a0);\n  if (res[0]!=0) res[0][0]=a3;\n  return 0;\n}\n\nint FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f4(arg, res, iw, w, mem);\n}\n\nint FORCENLPsolver_objective_1_alloc_mem(void) {\n  return 0;\n}\n\nint FORCENLPsolver_objective_1_init_mem(int mem) {\n  return 0;\n}\n\nvoid FORCENLPsolver_objective_1_free_mem(int mem) {\n}\n\nint FORCENLPsolver_objective_1_checkout(void) {\n  return 0;\n}\n\nvoid FORCENLPsolver_objective_1_release(int mem) {\n}\n\nvoid FORCENLPsolver_objective_1_incref(void) {\n}\n\nvoid FORCENLPsolver_objective_1_decref(void) {\n}\n\ncasadi_int FORCENLPsolver_objective_1_n_in(void) { return 2;}\n\ncasadi_int FORCENLPsolver_objective_1_n_out(void) { return 1;}\n\ncasadi_real FORCENLPsolver_objective_1_default_in(casadi_int i){\n  switch (i) {\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_objective_1_name_in(casadi_int i){\n  switch (i) {\n    case 0: return \"i0\";\n    case 1: return \"i1\";\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_objective_1_name_out(casadi_int i){\n  switch (i) {\n    case 0: return \"o0\";\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_objective_1_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s0;\n    case 1: return casadi_s1;\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s2;\n    default: return 0;\n  }\n}\n\nint FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 2;\n  if (sz_res) *sz_res = 1;\n  if (sz_iw) *sz_iw = 0;\n  if (sz_w) *sz_w = 0;\n  return 0;\n}\n\n/* FORCENLPsolver_dobjective_1:(i0[5],i1[3])->(o0[1x5]) */\nstatic int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {\n  casadi_real a0, a1, a2, a3;\n  a0=1.0000000000000001e-001;\n  a1=arg[0]? arg[0][0] : 0;\n  a1=(a1+a1);\n  a1=(a0*a1);\n  if (res[0]!=0) res[0][0]=a1;\n  a1=arg[0]? arg[0][1] : 0;\n  a1=(a1+a1);\n  a0=(a0*a1);\n  if (res[0]!=0) res[0][1]=a0;\n  a0=500.;\n  a1=arg[0]? arg[0][2] : 0;\n  a2=arg[1]? arg[1][0] : 0;\n  a3=(a1-a2);\n  a3=(a0*a3);\n  a1=(a1-a2);\n  a1=(a0*a1);\n  a3=(a3+a1);\n  if (res[0]!=0) res[0][2]=a3;\n  a3=arg[0]? arg[0][3] : 0;\n  a1=arg[1]? arg[1][1] : 0;\n  a2=(a3-a1);\n  a2=(a0*a2);\n  a3=(a3-a1);\n  a0=(a0*a3);\n  a2=(a2+a0);\n  if (res[0]!=0) res[0][3]=a2;\n  a2=100.;\n  a0=arg[0]? arg[0][4] : 0;\n  a3=arg[1]? arg[1][2] : 0;\n  a1=(a0-a3);\n  a1=(a2*a1);\n  a0=(a0-a3);\n  a2=(a2*a0);\n  a1=(a1+a2);\n  if (res[0]!=0) res[0][4]=a1;\n  return 0;\n}\n\nint FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){\n  return casadi_f5(arg, res, iw, w, mem);\n}\n\nint FORCENLPsolver_dobjective_1_alloc_mem(void) {\n  return 0;\n}\n\nint FORCENLPsolver_dobjective_1_init_mem(int mem) {\n  return 0;\n}\n\nvoid FORCENLPsolver_dobjective_1_free_mem(int mem) {\n}\n\nint FORCENLPsolver_dobjective_1_checkout(void) {\n  return 0;\n}\n\nvoid FORCENLPsolver_dobjective_1_release(int mem) {\n}\n\nvoid FORCENLPsolver_dobjective_1_incref(void) {\n}\n\nvoid FORCENLPsolver_dobjective_1_decref(void) {\n}\n\ncasadi_int FORCENLPsolver_dobjective_1_n_in(void) { return 2;}\n\ncasadi_int FORCENLPsolver_dobjective_1_n_out(void) { return 1;}\n\ncasadi_real FORCENLPsolver_dobjective_1_default_in(casadi_int i){\n  switch (i) {\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_dobjective_1_name_in(casadi_int i){\n  switch (i) {\n    case 0: return \"i0\";\n    case 1: return \"i1\";\n    default: return 0;\n  }\n}\n\nconst char* FORCENLPsolver_dobjective_1_name_out(casadi_int i){\n  switch (i) {\n    case 0: return \"o0\";\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_dobjective_1_sparsity_in(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s0;\n    case 1: return casadi_s1;\n    default: return 0;\n  }\n}\n\nconst casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i) {\n  switch (i) {\n    case 0: return casadi_s3;\n    default: return 0;\n  }\n}\n\nint FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {\n  if (sz_arg) *sz_arg = 2;\n  if (sz_res) *sz_res = 1;\n  if (sz_iw) *sz_iw = 0;\n  if (sz_w) *sz_w = 0;\n  return 0;\n}\n\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_model.c b/model/FORCENLPsolver/FORCENLPsolver_model.c
--- a/model/FORCENLPsolver/FORCENLPsolver_model.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/FORCENLPsolver_model.c	(date 1646039467408)
@@ -55,46 +55,72 @@
 
 casadi_real casadi_sq(casadi_real x) { return x*x;}
 
-static const casadi_int casadi_s0[9] = {5, 1, 0, 5, 0, 1, 2, 3, 4};
-static const casadi_int casadi_s1[7] = {3, 1, 0, 3, 0, 1, 2};
+static const casadi_int casadi_s0[14] = {10, 1, 0, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+static const casadi_int casadi_s1[10] = {6, 1, 0, 6, 0, 1, 2, 3, 4, 5};
 static const casadi_int casadi_s2[5] = {1, 1, 0, 1, 0};
-static const casadi_int casadi_s3[13] = {1, 5, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0};
-static const casadi_int casadi_s4[18] = {3, 5, 0, 2, 5, 6, 7, 10, 0, 1, 0, 1, 2, 0, 1, 0, 1, 2};
+static const casadi_int casadi_s3[23] = {1, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+static const casadi_int casadi_s4[33] = {6, 10, 0, 2, 5, 7, 10, 11, 12, 15, 16, 17, 20, 0, 1, 0, 1, 2, 3, 4, 3, 4, 5, 0, 1, 0, 1, 2, 3, 4, 3, 4, 5};
 
-/* FORCENLPsolver_objective_0:(i0[5],i1[3])->(o0) */
+/* FORCENLPsolver_objective_0:(i0[10],i1[6])->(o0) */
 static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
+  casadi_real a0, a1, a2, a3, a4, a5;
   a0=100.;
-  a1=arg[0]? arg[0][2] : 0;
+  a1=arg[0]? arg[0][4] : 0;
   a2=arg[1]? arg[1][0] : 0;
   a3=(a1-a2);
   a3=(a0*a3);
   a1=(a1-a2);
   a3=(a3*a1);
-  a1=arg[0]? arg[0][3] : 0;
+  a1=arg[0]? arg[0][5] : 0;
   a2=arg[1]? arg[1][1] : 0;
   a4=(a1-a2);
-  a0=(a0*a4);
+  a4=(a0*a4);
   a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=10.;
-  a1=arg[0]? arg[0][4] : 0;
+  a4=(a4*a1);
+  a3=(a3+a4);
+  a4=10.;
+  a1=arg[0]? arg[0][6] : 0;
   a2=arg[1]? arg[1][2] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
+  a5=(a1-a2);
+  a5=(a4*a5);
   a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=casadi_sq(a1);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][1] : 0;
-  a1=casadi_sq(a1);
+  a5=(a5*a1);
+  a3=(a3+a5);
+  a5=arg[0]? arg[0][7] : 0;
+  a1=arg[1]? arg[1][3] : 0;
+  a2=(a5-a1);
+  a2=(a0*a2);
+  a5=(a5-a1);
+  a2=(a2*a5);
+  a3=(a3+a2);
+  a2=arg[0]? arg[0][8] : 0;
+  a5=arg[1]? arg[1][4] : 0;
+  a1=(a2-a5);
   a0=(a0*a1);
+  a2=(a2-a5);
+  a0=(a0*a2);
   a3=(a3+a0);
+  a0=arg[0]? arg[0][9] : 0;
+  a2=arg[1]? arg[1][5] : 0;
+  a5=(a0-a2);
+  a4=(a4*a5);
+  a0=(a0-a2);
+  a4=(a4*a0);
+  a3=(a3+a4);
+  a4=1.0000000000000001e-01;
+  a0=arg[0]? arg[0][0] : 0;
+  a0=casadi_sq(a0);
+  a2=arg[0]? arg[0][1] : 0;
+  a2=casadi_sq(a2);
+  a0=(a0+a2);
+  a2=arg[0]? arg[0][2] : 0;
+  a2=casadi_sq(a2);
+  a0=(a0+a2);
+  a2=arg[0]? arg[0][3] : 0;
+  a2=casadi_sq(a2);
+  a0=(a0+a2);
+  a4=(a4*a0);
+  a3=(a3+a4);
   if (res[0]!=0) res[0][0]=a3;
   return 0;
 }
@@ -175,44 +201,76 @@
   return 0;
 }
 
-/* FORCENLPsolver_dobjective_0:(i0[5],i1[3])->(o0[1x5]) */
+/* FORCENLPsolver_dobjective_0:(i0[10],i1[6])->(o0[1x10]) */
 static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-001;
+  casadi_real a0, a1, a2, a3, a4;
+  a0=1.0000000000000001e-01;
   a1=arg[0]? arg[0][0] : 0;
   a1=(a1+a1);
   a1=(a0*a1);
   if (res[0]!=0) res[0][0]=a1;
   a1=arg[0]? arg[0][1] : 0;
+  a1=(a1+a1);
+  a1=(a0*a1);
+  if (res[0]!=0) res[0][1]=a1;
+  a1=arg[0]? arg[0][2] : 0;
+  a1=(a1+a1);
+  a1=(a0*a1);
+  if (res[0]!=0) res[0][2]=a1;
+  a1=arg[0]? arg[0][3] : 0;
   a1=(a1+a1);
   a0=(a0*a1);
-  if (res[0]!=0) res[0][1]=a0;
+  if (res[0]!=0) res[0][3]=a0;
   a0=100.;
-  a1=arg[0]? arg[0][2] : 0;
+  a1=arg[0]? arg[0][4] : 0;
   a2=arg[1]? arg[1][0] : 0;
   a3=(a1-a2);
   a3=(a0*a3);
   a1=(a1-a2);
   a1=(a0*a1);
   a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  a3=arg[0]? arg[0][3] : 0;
+  if (res[0]!=0) res[0][4]=a3;
+  a3=arg[0]? arg[0][5] : 0;
   a1=arg[1]? arg[1][1] : 0;
   a2=(a3-a1);
   a2=(a0*a2);
   a3=(a3-a1);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][3]=a2;
+  a3=(a0*a3);
+  a2=(a2+a3);
+  if (res[0]!=0) res[0][5]=a2;
   a2=10.;
-  a0=arg[0]? arg[0][4] : 0;
-  a3=arg[1]? arg[1][2] : 0;
-  a1=(a0-a3);
+  a3=arg[0]? arg[0][6] : 0;
+  a1=arg[1]? arg[1][2] : 0;
+  a4=(a3-a1);
+  a4=(a2*a4);
+  a3=(a3-a1);
+  a3=(a2*a3);
+  a4=(a4+a3);
+  if (res[0]!=0) res[0][6]=a4;
+  a4=arg[0]? arg[0][7] : 0;
+  a3=arg[1]? arg[1][3] : 0;
+  a1=(a4-a3);
+  a1=(a0*a1);
+  a4=(a4-a3);
+  a4=(a0*a4);
+  a1=(a1+a4);
+  if (res[0]!=0) res[0][7]=a1;
+  a1=arg[0]? arg[0][8] : 0;
+  a4=arg[1]? arg[1][4] : 0;
+  a3=(a1-a4);
+  a3=(a0*a3);
+  a1=(a1-a4);
+  a0=(a0*a1);
+  a3=(a3+a0);
+  if (res[0]!=0) res[0][8]=a3;
+  a3=arg[0]? arg[0][9] : 0;
+  a0=arg[1]? arg[1][5] : 0;
+  a1=(a3-a0);
   a1=(a2*a1);
-  a0=(a0-a3);
-  a2=(a2*a0);
+  a3=(a3-a0);
+  a2=(a2*a3);
   a1=(a1+a2);
-  if (res[0]!=0) res[0][4]=a1;
+  if (res[0]!=0) res[0][9]=a1;
   return 0;
 }
 
@@ -292,17 +350,17 @@
   return 0;
 }
 
-/* FORCENLPsolver_dynamics_0:(i0[5],i1[3])->(o0[3]) */
+/* FORCENLPsolver_dynamics_0:(i0[10],i1[6])->(o0[6]) */
 static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a2, a3, a4, a5, a6, a7, a8, a9;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=8.3333333333333339e-004;
+  casadi_real a0, a1, a10, a11, a12, a2, a3, a4, a5, a6, a7, a8, a9;
+  a0=arg[0]? arg[0][4] : 0;
+  a1=8.3333333333333339e-04;
   a2=arg[0]? arg[0][0] : 0;
-  a3=arg[0]? arg[0][4] : 0;
+  a3=arg[0]? arg[0][6] : 0;
   a4=cos(a3);
   a4=(a2*a4);
   a5=2.;
-  a6=2.5000000000000001e-003;
+  a6=2.5000000000000001e-03;
   a7=arg[0]? arg[0][1] : 0;
   a8=(a6*a7);
   a8=(a3+a8);
@@ -310,46 +368,97 @@
   a9=(a2*a9);
   a9=(a5*a9);
   a4=(a4+a9);
-  a6=(a6*a7);
-  a6=(a3+a6);
-  a9=cos(a6);
-  a9=(a2*a9);
-  a9=(a5*a9);
-  a4=(a4+a9);
-  a9=5.0000000000000001e-003;
-  a9=(a9*a7);
+  a9=(a6*a7);
   a9=(a3+a9);
   a10=cos(a9);
   a10=(a2*a10);
+  a10=(a5*a10);
   a4=(a4+a10);
+  a10=5.0000000000000001e-03;
+  a11=(a10*a7);
+  a11=(a3+a11);
+  a12=cos(a11);
+  a12=(a2*a12);
+  a4=(a4+a12);
   a4=(a1*a4);
   a0=(a0+a4);
   if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
+  a0=arg[0]? arg[0][5] : 0;
   a4=sin(a3);
   a4=(a2*a4);
   a8=sin(a8);
   a8=(a2*a8);
   a8=(a5*a8);
   a4=(a4+a8);
-  a6=sin(a6);
-  a6=(a2*a6);
-  a6=(a5*a6);
-  a4=(a4+a6);
   a9=sin(a9);
-  a2=(a2*a9);
+  a9=(a2*a9);
+  a9=(a5*a9);
+  a4=(a4+a9);
+  a11=sin(a11);
+  a2=(a2*a11);
   a4=(a4+a2);
   a4=(a1*a4);
   a0=(a0+a4);
   if (res[0]!=0) res[0][1]=a0;
   a0=(a5*a7);
   a0=(a7+a0);
-  a5=(a5*a7);
-  a0=(a0+a5);
+  a4=(a5*a7);
+  a0=(a0+a4);
   a0=(a0+a7);
-  a1=(a1*a0);
-  a3=(a3+a1);
+  a0=(a1*a0);
+  a3=(a3+a0);
   if (res[0]!=0) res[0][2]=a3;
+  a3=arg[0]? arg[0][7] : 0;
+  a0=arg[0]? arg[0][2] : 0;
+  a7=arg[0]? arg[0][9] : 0;
+  a4=cos(a7);
+  a4=(a0*a4);
+  a2=arg[0]? arg[0][3] : 0;
+  a11=(a6*a2);
+  a11=(a7+a11);
+  a9=cos(a11);
+  a9=(a0*a9);
+  a9=(a5*a9);
+  a4=(a4+a9);
+  a6=(a6*a2);
+  a6=(a7+a6);
+  a9=cos(a6);
+  a9=(a0*a9);
+  a9=(a5*a9);
+  a4=(a4+a9);
+  a10=(a10*a2);
+  a10=(a7+a10);
+  a9=cos(a10);
+  a9=(a0*a9);
+  a4=(a4+a9);
+  a4=(a1*a4);
+  a3=(a3+a4);
+  if (res[0]!=0) res[0][3]=a3;
+  a3=arg[0]? arg[0][8] : 0;
+  a4=sin(a7);
+  a4=(a0*a4);
+  a11=sin(a11);
+  a11=(a0*a11);
+  a11=(a5*a11);
+  a4=(a4+a11);
+  a6=sin(a6);
+  a6=(a0*a6);
+  a6=(a5*a6);
+  a4=(a4+a6);
+  a10=sin(a10);
+  a0=(a0*a10);
+  a4=(a4+a0);
+  a4=(a1*a4);
+  a3=(a3+a4);
+  if (res[0]!=0) res[0][4]=a3;
+  a3=(a5*a2);
+  a3=(a2+a3);
+  a5=(a5*a2);
+  a3=(a3+a5);
+  a3=(a3+a2);
+  a1=(a1*a3);
+  a7=(a7+a1);
+  if (res[0]!=0) res[0][5]=a7;
   return 0;
 }
 
@@ -429,14 +538,14 @@
   return 0;
 }
 
-/* FORCENLPsolver_ddynamics_0:(i0[5],i1[3])->(o0[3x5,10nz]) */
+/* FORCENLPsolver_ddynamics_0:(i0[10],i1[6])->(o0[6x10,20nz]) */
 static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a11, a12, a13, a2, a3, a4, a5, a6, a7, a8, a9;
-  a0=8.3333333333333339e-004;
-  a1=arg[0]? arg[0][4] : 0;
+  casadi_real a0, a1, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a2, a20, a21, a3, a4, a5, a6, a7, a8, a9;
+  a0=8.3333333333333339e-04;
+  a1=arg[0]? arg[0][6] : 0;
   a2=cos(a1);
   a3=2.;
-  a4=2.5000000000000001e-003;
+  a4=2.5000000000000001e-03;
   a5=arg[0]? arg[0][1] : 0;
   a6=(a4*a5);
   a6=(a1+a6);
@@ -448,7 +557,7 @@
   a8=cos(a7);
   a8=(a3*a8);
   a2=(a2+a8);
-  a8=5.0000000000000001e-003;
+  a8=5.0000000000000001e-03;
   a5=(a8*a5);
   a5=(a1+a5);
   a9=cos(a5);
@@ -488,46 +597,137 @@
   a10=(a2*a10);
   a10=(a3*a10);
   a7=cos(a7);
-  a4=(a4*a7);
-  a4=(a2*a4);
-  a4=(a3*a4);
-  a10=(a10+a4);
+  a13=(a4*a7);
+  a13=(a2*a13);
+  a13=(a3*a13);
+  a10=(a10+a13);
   a5=cos(a5);
-  a4=(a8*a5);
-  a4=(a2*a4);
-  a10=(a10+a4);
+  a13=(a8*a5);
+  a13=(a2*a13);
+  a10=(a10+a13);
   a10=(a0*a10);
   if (res[0]!=0) res[0][3]=a10;
   if (res[0]!=0) res[0][4]=a8;
+  a10=arg[0]? arg[0][9] : 0;
+  a13=cos(a10);
+  a14=arg[0]? arg[0][3] : 0;
+  a15=(a4*a14);
+  a15=(a10+a15);
+  a16=cos(a15);
+  a16=(a3*a16);
+  a13=(a13+a16);
+  a16=(a4*a14);
+  a16=(a10+a16);
+  a17=cos(a16);
+  a17=(a3*a17);
+  a13=(a13+a17);
+  a14=(a8*a14);
+  a14=(a10+a14);
+  a17=cos(a14);
+  a13=(a13+a17);
+  a13=(a0*a13);
+  if (res[0]!=0) res[0][5]=a13;
+  a13=sin(a10);
+  a17=sin(a15);
+  a17=(a3*a17);
+  a13=(a13+a17);
+  a17=sin(a16);
+  a17=(a3*a17);
+  a13=(a13+a17);
+  a17=sin(a14);
+  a13=(a13+a17);
+  a13=(a0*a13);
+  if (res[0]!=0) res[0][6]=a13;
+  a13=arg[0]? arg[0][2] : 0;
+  a17=sin(a15);
+  a18=(a4*a17);
+  a18=(a13*a18);
+  a18=(a3*a18);
+  a19=sin(a16);
+  a20=(a4*a19);
+  a20=(a13*a20);
+  a20=(a3*a20);
+  a18=(a18+a20);
+  a20=sin(a14);
+  a21=(a8*a20);
+  a21=(a13*a21);
+  a18=(a18+a21);
+  a18=(a0*a18);
+  a18=(-a18);
+  if (res[0]!=0) res[0][7]=a18;
+  a15=cos(a15);
+  a18=(a4*a15);
+  a18=(a13*a18);
+  a18=(a3*a18);
+  a16=cos(a16);
+  a4=(a4*a16);
+  a4=(a13*a4);
+  a4=(a3*a4);
+  a18=(a18+a4);
+  a14=cos(a14);
+  a4=(a8*a14);
+  a4=(a13*a4);
+  a18=(a18+a4);
+  a18=(a0*a18);
+  if (res[0]!=0) res[0][8]=a18;
+  if (res[0]!=0) res[0][9]=a8;
   a8=1.;
-  if (res[0]!=0) res[0][5]=a8;
-  if (res[0]!=0) res[0][6]=a8;
-  a10=sin(a1);
-  a10=(a2*a10);
+  if (res[0]!=0) res[0][10]=a8;
+  if (res[0]!=0) res[0][11]=a8;
+  a18=sin(a1);
+  a18=(a2*a18);
   a9=(a2*a9);
   a9=(a3*a9);
-  a10=(a10+a9);
+  a18=(a18+a9);
   a11=(a2*a11);
   a11=(a3*a11);
-  a10=(a10+a11);
+  a18=(a18+a11);
   a12=(a2*a12);
-  a10=(a10+a12);
-  a10=(a0*a10);
-  a10=(-a10);
-  if (res[0]!=0) res[0][7]=a10;
+  a18=(a18+a12);
+  a18=(a0*a18);
+  a18=(-a18);
+  if (res[0]!=0) res[0][12]=a18;
   a1=cos(a1);
   a1=(a2*a1);
   a6=(a2*a6);
   a6=(a3*a6);
   a1=(a1+a6);
   a7=(a2*a7);
-  a3=(a3*a7);
-  a1=(a1+a3);
+  a7=(a3*a7);
+  a1=(a1+a7);
   a2=(a2*a5);
   a1=(a1+a2);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][8]=a0;
-  if (res[0]!=0) res[0][9]=a8;
+  a1=(a0*a1);
+  if (res[0]!=0) res[0][13]=a1;
+  if (res[0]!=0) res[0][14]=a8;
+  if (res[0]!=0) res[0][15]=a8;
+  if (res[0]!=0) res[0][16]=a8;
+  a1=sin(a10);
+  a1=(a13*a1);
+  a17=(a13*a17);
+  a17=(a3*a17);
+  a1=(a1+a17);
+  a19=(a13*a19);
+  a19=(a3*a19);
+  a1=(a1+a19);
+  a20=(a13*a20);
+  a1=(a1+a20);
+  a1=(a0*a1);
+  a1=(-a1);
+  if (res[0]!=0) res[0][17]=a1;
+  a10=cos(a10);
+  a10=(a13*a10);
+  a15=(a13*a15);
+  a15=(a3*a15);
+  a10=(a10+a15);
+  a16=(a13*a16);
+  a3=(a3*a16);
+  a10=(a10+a3);
+  a13=(a13*a14);
+  a10=(a10+a13);
+  a0=(a0*a10);
+  if (res[0]!=0) res[0][18]=a0;
+  if (res[0]!=0) res[0][19]=a8;
   return 0;
 }
 
@@ -607,40 +807,66 @@
   return 0;
 }
 
-/* FORCENLPsolver_objective_1:(i0[5],i1[3])->(o0) */
+/* FORCENLPsolver_objective_1:(i0[10],i1[6])->(o0) */
 static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
+  casadi_real a0, a1, a2, a3, a4, a5;
   a0=500.;
-  a1=arg[0]? arg[0][2] : 0;
+  a1=arg[0]? arg[0][4] : 0;
   a2=arg[1]? arg[1][0] : 0;
   a3=(a1-a2);
   a3=(a0*a3);
   a1=(a1-a2);
   a3=(a3*a1);
-  a1=arg[0]? arg[0][3] : 0;
+  a1=arg[0]? arg[0][5] : 0;
   a2=arg[1]? arg[1][1] : 0;
   a4=(a1-a2);
-  a0=(a0*a4);
+  a4=(a0*a4);
   a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
+  a4=(a4*a1);
+  a3=(a3+a4);
+  a4=100.;
+  a1=arg[0]? arg[0][6] : 0;
   a2=arg[1]? arg[1][2] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
+  a5=(a1-a2);
+  a5=(a4*a5);
   a1=(a1-a2);
+  a5=(a5*a1);
+  a3=(a3+a5);
+  a5=arg[0]? arg[0][7] : 0;
+  a1=arg[1]? arg[1][3] : 0;
+  a2=(a5-a1);
+  a2=(a0*a2);
+  a5=(a5-a1);
+  a2=(a2*a5);
+  a3=(a3+a2);
+  a2=arg[0]? arg[0][8] : 0;
+  a5=arg[1]? arg[1][4] : 0;
+  a1=(a2-a5);
   a0=(a0*a1);
+  a2=(a2-a5);
+  a0=(a0*a2);
   a3=(a3+a0);
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=casadi_sq(a1);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][1] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0*a1);
-  a3=(a3+a0);
+  a0=arg[0]? arg[0][9] : 0;
+  a2=arg[1]? arg[1][5] : 0;
+  a5=(a0-a2);
+  a4=(a4*a5);
+  a0=(a0-a2);
+  a4=(a4*a0);
+  a3=(a3+a4);
+  a4=1.0000000000000001e-01;
+  a0=arg[0]? arg[0][0] : 0;
+  a0=casadi_sq(a0);
+  a2=arg[0]? arg[0][1] : 0;
+  a2=casadi_sq(a2);
+  a0=(a0+a2);
+  a2=arg[0]? arg[0][2] : 0;
+  a2=casadi_sq(a2);
+  a0=(a0+a2);
+  a2=arg[0]? arg[0][3] : 0;
+  a2=casadi_sq(a2);
+  a0=(a0+a2);
+  a4=(a4*a0);
+  a3=(a3+a4);
   if (res[0]!=0) res[0][0]=a3;
   return 0;
 }
@@ -721,44 +947,76 @@
   return 0;
 }
 
-/* FORCENLPsolver_dobjective_1:(i0[5],i1[3])->(o0[1x5]) */
+/* FORCENLPsolver_dobjective_1:(i0[10],i1[6])->(o0[1x10]) */
 static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-001;
+  casadi_real a0, a1, a2, a3, a4;
+  a0=1.0000000000000001e-01;
   a1=arg[0]? arg[0][0] : 0;
   a1=(a1+a1);
   a1=(a0*a1);
   if (res[0]!=0) res[0][0]=a1;
   a1=arg[0]? arg[0][1] : 0;
+  a1=(a1+a1);
+  a1=(a0*a1);
+  if (res[0]!=0) res[0][1]=a1;
+  a1=arg[0]? arg[0][2] : 0;
+  a1=(a1+a1);
+  a1=(a0*a1);
+  if (res[0]!=0) res[0][2]=a1;
+  a1=arg[0]? arg[0][3] : 0;
   a1=(a1+a1);
   a0=(a0*a1);
-  if (res[0]!=0) res[0][1]=a0;
+  if (res[0]!=0) res[0][3]=a0;
   a0=500.;
-  a1=arg[0]? arg[0][2] : 0;
+  a1=arg[0]? arg[0][4] : 0;
   a2=arg[1]? arg[1][0] : 0;
   a3=(a1-a2);
   a3=(a0*a3);
   a1=(a1-a2);
   a1=(a0*a1);
   a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  a3=arg[0]? arg[0][3] : 0;
+  if (res[0]!=0) res[0][4]=a3;
+  a3=arg[0]? arg[0][5] : 0;
   a1=arg[1]? arg[1][1] : 0;
   a2=(a3-a1);
   a2=(a0*a2);
   a3=(a3-a1);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][3]=a2;
+  a3=(a0*a3);
+  a2=(a2+a3);
+  if (res[0]!=0) res[0][5]=a2;
   a2=100.;
-  a0=arg[0]? arg[0][4] : 0;
-  a3=arg[1]? arg[1][2] : 0;
-  a1=(a0-a3);
+  a3=arg[0]? arg[0][6] : 0;
+  a1=arg[1]? arg[1][2] : 0;
+  a4=(a3-a1);
+  a4=(a2*a4);
+  a3=(a3-a1);
+  a3=(a2*a3);
+  a4=(a4+a3);
+  if (res[0]!=0) res[0][6]=a4;
+  a4=arg[0]? arg[0][7] : 0;
+  a3=arg[1]? arg[1][3] : 0;
+  a1=(a4-a3);
+  a1=(a0*a1);
+  a4=(a4-a3);
+  a4=(a0*a4);
+  a1=(a1+a4);
+  if (res[0]!=0) res[0][7]=a1;
+  a1=arg[0]? arg[0][8] : 0;
+  a4=arg[1]? arg[1][4] : 0;
+  a3=(a1-a4);
+  a3=(a0*a3);
+  a1=(a1-a4);
+  a0=(a0*a1);
+  a3=(a3+a0);
+  if (res[0]!=0) res[0][8]=a3;
+  a3=arg[0]? arg[0][9] : 0;
+  a0=arg[1]? arg[1][5] : 0;
+  a1=(a3-a0);
   a1=(a2*a1);
-  a0=(a0-a3);
-  a2=(a2*a0);
+  a3=(a3-a0);
+  a2=(a2*a3);
   a1=(a1+a2);
-  if (res[0]!=0) res[0][4]=a1;
+  if (res[0]!=0) res[0][9]=a1;
   return 0;
 }
 
Index: model/FORCENLPsolver/interface/FORCENLPsolver.m
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>% FORCENLPsolver - a fast solver generated by FORCESPRO v5.1.0\n%\n%   OUTPUT = FORCENLPsolver(PARAMS) solves a multistage problem\n%   subject to the parameters supplied in the following struct:\n%       PARAMS.xinit - column vector of length 3\n%       PARAMS.x0 - column vector of length 100\n%       PARAMS.all_parameters - column vector of length 60\n%       PARAMS.reinitialize - scalar\n%\n%   OUTPUT returns the values of the last iteration of the solver where\n%       OUTPUT.x01 - column vector of size 5\n%       OUTPUT.x02 - column vector of size 5\n%       OUTPUT.x03 - column vector of size 5\n%       OUTPUT.x04 - column vector of size 5\n%       OUTPUT.x05 - column vector of size 5\n%       OUTPUT.x06 - column vector of size 5\n%       OUTPUT.x07 - column vector of size 5\n%       OUTPUT.x08 - column vector of size 5\n%       OUTPUT.x09 - column vector of size 5\n%       OUTPUT.x10 - column vector of size 5\n%       OUTPUT.x11 - column vector of size 5\n%       OUTPUT.x12 - column vector of size 5\n%       OUTPUT.x13 - column vector of size 5\n%       OUTPUT.x14 - column vector of size 5\n%       OUTPUT.x15 - column vector of size 5\n%       OUTPUT.x16 - column vector of size 5\n%       OUTPUT.x17 - column vector of size 5\n%       OUTPUT.x18 - column vector of size 5\n%       OUTPUT.x19 - column vector of size 5\n%       OUTPUT.x20 - column vector of size 5\n%\n%   [OUTPUT, EXITFLAG] = FORCENLPsolver(PARAMS) returns additionally\n%   the integer EXITFLAG indicating the state of the solution with \n%       1 - OPTIMAL solution has been found (subject to desired accuracy)\n%       0 - Timeout - maximum number of iterations reached\n%      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.\n%      -8 - QP solver failed. The QP solver failed to converge. Check your variable bounds and inequality constraints. Consider scaling your problem.\n%    -100 - License error\n%\n%   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver(PARAMS) returns \n%   additional information about the last iterate:\n%       INFO.it        - number of iterations that lead to this result\n%       INFO.res_eq    - max. equality constraint residual\n%       INFO.res_ineq  - max. inequality constraint residual\n%       INFO.pobj      - primal objective\n%       INFO.solvetime - Time needed for solve (wall clock time)\n%       INFO.fevalstime - Time needed for function evaluations (wall clock time)\n%       INFO.QPtime - Cumulative time spent in QP solver (wall clock time)\n%\n% See also COPYING\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver.m b/model/FORCENLPsolver/interface/FORCENLPsolver.m
--- a/model/FORCENLPsolver/interface/FORCENLPsolver.m	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver.m	(date 1646039467400)
@@ -2,32 +2,22 @@
 %
 %   OUTPUT = FORCENLPsolver(PARAMS) solves a multistage problem
 %   subject to the parameters supplied in the following struct:
-%       PARAMS.xinit - column vector of length 3
+%       PARAMS.xinit - column vector of length 6
 %       PARAMS.x0 - column vector of length 100
 %       PARAMS.all_parameters - column vector of length 60
 %       PARAMS.reinitialize - scalar
 %
 %   OUTPUT returns the values of the last iteration of the solver where
-%       OUTPUT.x01 - column vector of size 5
-%       OUTPUT.x02 - column vector of size 5
-%       OUTPUT.x03 - column vector of size 5
-%       OUTPUT.x04 - column vector of size 5
-%       OUTPUT.x05 - column vector of size 5
-%       OUTPUT.x06 - column vector of size 5
-%       OUTPUT.x07 - column vector of size 5
-%       OUTPUT.x08 - column vector of size 5
-%       OUTPUT.x09 - column vector of size 5
-%       OUTPUT.x10 - column vector of size 5
-%       OUTPUT.x11 - column vector of size 5
-%       OUTPUT.x12 - column vector of size 5
-%       OUTPUT.x13 - column vector of size 5
-%       OUTPUT.x14 - column vector of size 5
-%       OUTPUT.x15 - column vector of size 5
-%       OUTPUT.x16 - column vector of size 5
-%       OUTPUT.x17 - column vector of size 5
-%       OUTPUT.x18 - column vector of size 5
-%       OUTPUT.x19 - column vector of size 5
-%       OUTPUT.x20 - column vector of size 5
+%       OUTPUT.x01 - column vector of size 10
+%       OUTPUT.x02 - column vector of size 10
+%       OUTPUT.x03 - column vector of size 10
+%       OUTPUT.x04 - column vector of size 10
+%       OUTPUT.x05 - column vector of size 10
+%       OUTPUT.x06 - column vector of size 10
+%       OUTPUT.x07 - column vector of size 10
+%       OUTPUT.x08 - column vector of size 10
+%       OUTPUT.x09 - column vector of size 10
+%       OUTPUT.x10 - column vector of size 10
 %
 %   [OUTPUT, EXITFLAG] = FORCENLPsolver(PARAMS) returns additionally
 %   the integer EXITFLAG indicating the state of the solution with 
Index: model/FORCENLPsolver/interface/definitions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy\nimport ctypes\n\nname = \"FORCENLPsolver\"\nrequires_callback = True\nlib = \"lib/FORCENLPsolver.dll\"\nlib_static = \"lib/FORCENLPsolver_static.lib\"\nc_header = \"include/FORCENLPsolver.h\"\nnstages = 20\n\n# Parameter             | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len\nparams = \\\n[(\"xinit\"               , \"dense\" , \"\"               , ctypes.c_double, numpy.float64, (  3,   1),    3),\n (\"x0\"                  , \"dense\" , \"\"               , ctypes.c_double, numpy.float64, (100,   1),  100),\n (\"all_parameters\"      , \"dense\" , \"\"               , ctypes.c_double, numpy.float64, ( 60,   1),   60),\n (\"reinitialize\"        , \"\"      , \"FORCENLPsolver_int\", ctypes.c_int   , numpy.int32  , (  0,   1),    1)]\n\n# Output                | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len\noutputs = \\\n[(\"x01\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x02\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x03\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x04\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x05\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x06\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x07\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x08\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x09\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x10\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x11\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x12\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x13\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x14\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x15\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x16\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x17\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x18\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x19\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5),\n (\"x20\"                 , \"\"      , \"\"               , ctypes.c_double, numpy.float64,     (  5,),    5)]\n\n# Info Struct Fields\ninfo = \\\n[(\"it\", ctypes.c_int),\n (\"res_eq\", ctypes.c_double),\n (\"rsnorm\", ctypes.c_double),\n (\"pobj\", ctypes.c_double),\n (\"solvetime\", ctypes.c_double),\n (\"fevalstime\", ctypes.c_double),\n (\"QPtime\", ctypes.c_double)]\n\n# Dynamics dimensions\n#   nvar    |   neq   |   dimh    |   dimp    |   diml    |   dimu    |   dimhl   |   dimhu    \ndynamics_dims = [\n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0), \n\t(5, 3, 0, 3, 0, 0, 0, 0)\n]
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/definitions.py b/model/FORCENLPsolver/interface/definitions.py
--- a/model/FORCENLPsolver/interface/definitions.py	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/definitions.py	(date 1646039467400)
@@ -3,40 +3,30 @@
 
 name = "FORCENLPsolver"
 requires_callback = True
-lib = "lib/FORCENLPsolver.dll"
-lib_static = "lib/FORCENLPsolver_static.lib"
+lib = "lib/libFORCENLPsolver.so"
+lib_static = "lib/libFORCENLPsolver.a"
 c_header = "include/FORCENLPsolver.h"
-nstages = 20
+nstages = 10
 
 # Parameter             | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
 params = \
-[("xinit"               , "dense" , ""               , ctypes.c_double, numpy.float64, (  3,   1),    3),
+[("xinit"               , "dense" , ""               , ctypes.c_double, numpy.float64, (  6,   1),    6),
  ("x0"                  , "dense" , ""               , ctypes.c_double, numpy.float64, (100,   1),  100),
  ("all_parameters"      , "dense" , ""               , ctypes.c_double, numpy.float64, ( 60,   1),   60),
  ("reinitialize"        , ""      , "FORCENLPsolver_int", ctypes.c_int   , numpy.int32  , (  0,   1),    1)]
 
 # Output                | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
 outputs = \
-[("x01"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x02"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x03"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x04"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x05"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x06"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x07"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x08"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x09"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x10"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x11"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x12"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x13"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x14"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x15"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x16"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x17"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x18"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x19"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x20"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5)]
+[("x01"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x02"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x03"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x04"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x05"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x06"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x07"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x08"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x09"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10),
+ ("x10"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 10,),   10)]
 
 # Info Struct Fields
 info = \
@@ -51,24 +41,14 @@
 # Dynamics dimensions
 #   nvar    |   neq   |   dimh    |   dimp    |   diml    |   dimu    |   dimhl   |   dimhu    
 dynamics_dims = [
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0), 
-	(5, 3, 0, 3, 0, 0, 0, 0)
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0), 
+	(10, 6, 0, 6, 0, 0, 0, 0)
 ]
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_py.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#FORCENLPsolver : A fast customized optimization solver.\n#\n#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n#\n#\n#This software is intended for simulation and testing purposes only. \n#Use of this software for any commercial purpose is prohibited.\n#\n#This program is distributed in the hope that it will be useful.\n#EMBOTECH makes NO WARRANTIES with respect to the use of the software \n#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \n#PARTICULAR PURPOSE. \n#\n#EMBOTECH shall not have any liability for any damage arising from the use\n#of the software.\n#\n#This Agreement shall exclusively be governed by and interpreted in \n#accordance with the laws of Switzerland, excluding its principles\n#of conflict of laws. The Courts of Zurich-City shall have exclusive \n#jurisdiction in case of any dispute.\n#\n#def __init__():\n'''\na Python wrapper for a fast solver generated by FORCESPRO v5.1.0\n\n   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem\n   subject to the parameters supplied in the following dictionary:\n       PARAMS['xinit'] - column vector of length 3\n       PARAMS['x0'] - column vector of length 100\n       PARAMS['all_parameters'] - column vector of length 60\n       PARAMS['reinitialize'] - scalar\n\n   OUTPUT returns the values of the last iteration of the solver where\n       OUTPUT['x01'] - column vector of size 5\n       OUTPUT['x02'] - column vector of size 5\n       OUTPUT['x03'] - column vector of size 5\n       OUTPUT['x04'] - column vector of size 5\n       OUTPUT['x05'] - column vector of size 5\n       OUTPUT['x06'] - column vector of size 5\n       OUTPUT['x07'] - column vector of size 5\n       OUTPUT['x08'] - column vector of size 5\n       OUTPUT['x09'] - column vector of size 5\n       OUTPUT['x10'] - column vector of size 5\n       OUTPUT['x11'] - column vector of size 5\n       OUTPUT['x12'] - column vector of size 5\n       OUTPUT['x13'] - column vector of size 5\n       OUTPUT['x14'] - column vector of size 5\n       OUTPUT['x15'] - column vector of size 5\n       OUTPUT['x16'] - column vector of size 5\n       OUTPUT['x17'] - column vector of size 5\n       OUTPUT['x18'] - column vector of size 5\n       OUTPUT['x19'] - column vector of size 5\n       OUTPUT['x20'] - column vector of size 5\n\n   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally\n   the integer EXITFLAG indicating the state of the solution with \n       1 - Optimal solution has been found (subject to desired accuracy)\n       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum \n       0 - Timeout - maximum number of iterations reached\n      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)\n      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.\n      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.\n      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.\n     -10 - The convex solver could not proceed due to an internal error\n    -100 - License error\n\n   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns \n   additional information about the last iterate:\n       INFO.it        - number of iterations that lead to this result\n       INFO.it2opt    - number of convex solves\n       INFO.res_eq    - max. equality constraint residual\n       INFO.res_ineq  - max. inequality constraint residual\n       INFO.pobj      - primal objective\n       INFO.dobj      - dual objective\n       INFO.dgap      - duality gap := pobj - dobj\n       INFO.rdgap     - relative duality gap := |dgap / pobj|\n       INFO.mu        - duality measure\n       INFO.sigma     - centering parameter\n       INFO.lsit_aff  - iterations of affine line search\n       INFO.lsit_cc   - iterations of line search (combined direction)\n       INFO.step_aff  - step size (affine direction)\n       INFO.step_cc   - step size (centering direction)\n       INFO.solvetime - Time needed for solve (wall clock time)\n\n See also COPYING\n\n'''\n\nimport ctypes\nimport os\nimport numpy as np\nimport numpy.ctypeslib as npct\nimport sys\n\n#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'FORCENLPsolver/lib/FORCENLPsolver.dll')) \ntry:\n    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/FORCENLPsolver.dll'))\n    csolver = getattr(_lib,'FORCENLPsolver_solve')\nexcept:\n    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/libFORCENLPsolver.dll'))\n    csolver = getattr(_lib,'FORCENLPsolver_solve')\n\nclass FORCENLPsolver_params_ctypes(ctypes.Structure):\n#    @classmethod\n#    def from_param(self):\n#        return self\n    _fields_ = [('xinit', ctypes.c_double * 3),\n('x0', ctypes.c_double * 100),\n('all_parameters', ctypes.c_double * 60),\n('reinitialize', ctypes.c_int),\n]\n\nFORCENLPsolver_params = {'xinit' : np.array([]),\n'x0' : np.array([]),\n'all_parameters' : np.array([]),\n'reinitialize' : np.array([]),\n}\nparams = {'xinit' : np.array([]),\n'x0' : np.array([]),\n'all_parameters' : np.array([]),\n'reinitialize' : np.array([]),\n}\nFORCENLPsolver_params_types = {'xinit' : np.float64,\n'x0' : np.float64,\n'all_parameters' : np.float64,\n'reinitialize' : np.int32,\n}\n\nclass FORCENLPsolver_outputs_ctypes(ctypes.Structure):\n#    @classmethod\n#    def from_param(self):\n#        return self\n    _fields_ = [('x01', ctypes.c_double * 5),\n('x02', ctypes.c_double * 5),\n('x03', ctypes.c_double * 5),\n('x04', ctypes.c_double * 5),\n('x05', ctypes.c_double * 5),\n('x06', ctypes.c_double * 5),\n('x07', ctypes.c_double * 5),\n('x08', ctypes.c_double * 5),\n('x09', ctypes.c_double * 5),\n('x10', ctypes.c_double * 5),\n('x11', ctypes.c_double * 5),\n('x12', ctypes.c_double * 5),\n('x13', ctypes.c_double * 5),\n('x14', ctypes.c_double * 5),\n('x15', ctypes.c_double * 5),\n('x16', ctypes.c_double * 5),\n('x17', ctypes.c_double * 5),\n('x18', ctypes.c_double * 5),\n('x19', ctypes.c_double * 5),\n('x20', ctypes.c_double * 5),\n]\n\nFORCENLPsolver_outputs = {'x01' : np.array([]),\n'x02' : np.array([]),\n'x03' : np.array([]),\n'x04' : np.array([]),\n'x05' : np.array([]),\n'x06' : np.array([]),\n'x07' : np.array([]),\n'x08' : np.array([]),\n'x09' : np.array([]),\n'x10' : np.array([]),\n'x11' : np.array([]),\n'x12' : np.array([]),\n'x13' : np.array([]),\n'x14' : np.array([]),\n'x15' : np.array([]),\n'x16' : np.array([]),\n'x17' : np.array([]),\n'x18' : np.array([]),\n'x19' : np.array([]),\n'x20' : np.array([]),\n}\n\n\nclass FORCENLPsolver_info(ctypes.Structure):\n#    @classmethod\n#    def from_param(self):\n#        return self\n    _fields_ = [(\"it\", ctypes.c_int),\n (\"res_eq\", ctypes.c_double),\n (\"rsnorm\", ctypes.c_double),\n (\"pobj\", ctypes.c_double),\n (\"solvetime\", ctypes.c_double),\n (\"fevalstime\", ctypes.c_double),\n (\"QPtime\", ctypes.c_double)]\n\nclass FILE(ctypes.Structure):\n        pass\nif sys.version_info.major == 2:\n    PyFile_AsFile = ctypes.pythonapi.PyFile_AsFile # problem here with python 3 http://stackoverflow.com/questions/16130268/python-3-replacement-for-pyfile-asfile\n    PyFile_AsFile.argtypes = [ctypes.py_object]\n    PyFile_AsFile.restype = ctypes.POINTER(FILE)\n\n# determine data types for solver function prototype \ncsolver.argtypes = ( ctypes.POINTER(FORCENLPsolver_params_ctypes), ctypes.POINTER(FORCENLPsolver_outputs_ctypes), ctypes.POINTER(FORCENLPsolver_info), ctypes.POINTER(FILE))\ncsolver.restype = ctypes.c_int\n\ndef FORCENLPsolver_solve(params_arg):\n    '''\na Python wrapper for a fast solver generated by FORCESPRO v5.1.0\n\n   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem\n   subject to the parameters supplied in the following dictionary:\n       PARAMS['xinit'] - column vector of length 3\n       PARAMS['x0'] - column vector of length 100\n       PARAMS['all_parameters'] - column vector of length 60\n       PARAMS['reinitialize'] - scalar\n\n   OUTPUT returns the values of the last iteration of the solver where\n       OUTPUT['x01'] - column vector of size 5\n       OUTPUT['x02'] - column vector of size 5\n       OUTPUT['x03'] - column vector of size 5\n       OUTPUT['x04'] - column vector of size 5\n       OUTPUT['x05'] - column vector of size 5\n       OUTPUT['x06'] - column vector of size 5\n       OUTPUT['x07'] - column vector of size 5\n       OUTPUT['x08'] - column vector of size 5\n       OUTPUT['x09'] - column vector of size 5\n       OUTPUT['x10'] - column vector of size 5\n       OUTPUT['x11'] - column vector of size 5\n       OUTPUT['x12'] - column vector of size 5\n       OUTPUT['x13'] - column vector of size 5\n       OUTPUT['x14'] - column vector of size 5\n       OUTPUT['x15'] - column vector of size 5\n       OUTPUT['x16'] - column vector of size 5\n       OUTPUT['x17'] - column vector of size 5\n       OUTPUT['x18'] - column vector of size 5\n       OUTPUT['x19'] - column vector of size 5\n       OUTPUT['x20'] - column vector of size 5\n\n   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally\n   the integer EXITFLAG indicating the state of the solution with \n       1 - Optimal solution has been found (subject to desired accuracy)\n       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum \n       0 - Timeout - maximum number of iterations reached\n      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)\n      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.\n      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.\n      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.\n     -10 - The convex solver could not proceed due to an internal error\n    -100 - License error\n\n   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns \n   additional information about the last iterate:\n       INFO.it        - number of iterations that lead to this result\n       INFO.it2opt    - number of convex solves\n       INFO.res_eq    - max. equality constraint residual\n       INFO.res_ineq  - max. inequality constraint residual\n       INFO.pobj      - primal objective\n       INFO.dobj      - dual objective\n       INFO.dgap      - duality gap := pobj - dobj\n       INFO.rdgap     - relative duality gap := |dgap / pobj|\n       INFO.mu        - duality measure\n       INFO.sigma     - centering parameter\n       INFO.lsit_aff  - iterations of affine line search\n       INFO.lsit_cc   - iterations of line search (combined direction)\n       INFO.step_aff  - step size (affine direction)\n       INFO.step_cc   - step size (centering direction)\n       INFO.solvetime - Time needed for solve (wall clock time)\n\n See also COPYING\n\n    '''\n    global _lib\n\n    # convert parameters\n    params_py = FORCENLPsolver_params_ctypes()\n    for par in params_arg:\n        try:\n            #setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='A')))\n            if isinstance(getattr(params_py, par), ctypes.Array):\n                params_arg[par] = np.require(params_arg[par], dtype=FORCENLPsolver_params_types[par], requirements='F')\n                setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='F')))\n            else:\n                setattr(params_py, par, params_arg[par])\n        except:\n            raise ValueError('Parameter ' + par + ' does not have the appropriate dimensions or data type. Please use numpy arrays for parameters.')\n    \n    outputs_py = FORCENLPsolver_outputs_ctypes()\n    info_py = FORCENLPsolver_info()\n    if sys.version_info.major == 2:\n        if sys.platform.startswith('win'):\n            fp = None # if set to none, the solver prints to stdout by default - necessary because we have an access violation otherwise under windows\n        else:\n            #fp = open('stdout_temp.txt','w')\n            fp = sys.stdout\n        try:\n            PyFile_AsFile.restype = ctypes.POINTER(FILE)\n            exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), PyFile_AsFile(fp)  )\n            #fp = open('stdout_temp.txt','r')\n            #print (fp.read())\n            #fp.close()\n        except:\n            #print 'Problem with solver'\n            raise\n    elif sys.version_info.major == 3:\n        if sys.platform.startswith('win'):\n            libc = ctypes.cdll.msvcrt\n        elif sys.platform.startswith('darwin'):\n            libc = ctypes.CDLL('libc.dylib')\n        else:\n            libc = ctypes.CDLL('libc.so.6')       # Open libc\n        cfopen = getattr(libc,'fopen')        # Get its fopen\n        cfopen.restype = ctypes.POINTER(FILE) # Yes, fopen gives a file pointer\n        cfopen.argtypes = [ctypes.c_char_p, ctypes.c_char_p] # Yes, fopen gives a file pointer \n        fp = cfopen('stdout_temp.txt'.encode('utf-8'),'w'.encode('utf-8'))    # Use that fopen \n\n        try:\n            if sys.platform.startswith('win'):\n                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), None )\n            else:\n                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), fp )\n            libc.fclose(fp)\n            fptemp = open('stdout_temp.txt','r')\n            print (fptemp.read())\n            fptemp.close()            \n        except:\n            #print 'Problem with solver'\n            raise\n\n    # convert outputs\n    for out in FORCENLPsolver_outputs:\n        FORCENLPsolver_outputs[out] = npct.as_array(getattr(outputs_py,out))\n\n    return FORCENLPsolver_outputs,int(exitflag),info_py\n\nsolve = FORCENLPsolver_solve\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_py.py b/model/FORCENLPsolver/interface/FORCENLPsolver_py.py
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_py.py	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_py.py	(date 1646039467396)
@@ -25,32 +25,22 @@
 
    OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
    subject to the parameters supplied in the following dictionary:
-       PARAMS['xinit'] - column vector of length 3
+       PARAMS['xinit'] - column vector of length 6
        PARAMS['x0'] - column vector of length 100
        PARAMS['all_parameters'] - column vector of length 60
        PARAMS['reinitialize'] - scalar
 
    OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 5
-       OUTPUT['x02'] - column vector of size 5
-       OUTPUT['x03'] - column vector of size 5
-       OUTPUT['x04'] - column vector of size 5
-       OUTPUT['x05'] - column vector of size 5
-       OUTPUT['x06'] - column vector of size 5
-       OUTPUT['x07'] - column vector of size 5
-       OUTPUT['x08'] - column vector of size 5
-       OUTPUT['x09'] - column vector of size 5
-       OUTPUT['x10'] - column vector of size 5
-       OUTPUT['x11'] - column vector of size 5
-       OUTPUT['x12'] - column vector of size 5
-       OUTPUT['x13'] - column vector of size 5
-       OUTPUT['x14'] - column vector of size 5
-       OUTPUT['x15'] - column vector of size 5
-       OUTPUT['x16'] - column vector of size 5
-       OUTPUT['x17'] - column vector of size 5
-       OUTPUT['x18'] - column vector of size 5
-       OUTPUT['x19'] - column vector of size 5
-       OUTPUT['x20'] - column vector of size 5
+       OUTPUT['x01'] - column vector of size 10
+       OUTPUT['x02'] - column vector of size 10
+       OUTPUT['x03'] - column vector of size 10
+       OUTPUT['x04'] - column vector of size 10
+       OUTPUT['x05'] - column vector of size 10
+       OUTPUT['x06'] - column vector of size 10
+       OUTPUT['x07'] - column vector of size 10
+       OUTPUT['x08'] - column vector of size 10
+       OUTPUT['x09'] - column vector of size 10
+       OUTPUT['x10'] - column vector of size 10
 
    [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
    the integer EXITFLAG indicating the state of the solution with 
@@ -92,19 +82,19 @@
 import numpy.ctypeslib as npct
 import sys
 
-#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'FORCENLPsolver/lib/FORCENLPsolver.dll')) 
+#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'FORCENLPsolver/lib/FORCENLPsolver.so')) 
 try:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/FORCENLPsolver.dll'))
+    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/FORCENLPsolver.so'))
     csolver = getattr(_lib,'FORCENLPsolver_solve')
 except:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/libFORCENLPsolver.dll'))
+    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/libFORCENLPsolver.so'))
     csolver = getattr(_lib,'FORCENLPsolver_solve')
 
 class FORCENLPsolver_params_ctypes(ctypes.Structure):
 #    @classmethod
 #    def from_param(self):
 #        return self
-    _fields_ = [('xinit', ctypes.c_double * 3),
+    _fields_ = [('xinit', ctypes.c_double * 6),
 ('x0', ctypes.c_double * 100),
 ('all_parameters', ctypes.c_double * 60),
 ('reinitialize', ctypes.c_int),
@@ -130,26 +120,16 @@
 #    @classmethod
 #    def from_param(self):
 #        return self
-    _fields_ = [('x01', ctypes.c_double * 5),
-('x02', ctypes.c_double * 5),
-('x03', ctypes.c_double * 5),
-('x04', ctypes.c_double * 5),
-('x05', ctypes.c_double * 5),
-('x06', ctypes.c_double * 5),
-('x07', ctypes.c_double * 5),
-('x08', ctypes.c_double * 5),
-('x09', ctypes.c_double * 5),
-('x10', ctypes.c_double * 5),
-('x11', ctypes.c_double * 5),
-('x12', ctypes.c_double * 5),
-('x13', ctypes.c_double * 5),
-('x14', ctypes.c_double * 5),
-('x15', ctypes.c_double * 5),
-('x16', ctypes.c_double * 5),
-('x17', ctypes.c_double * 5),
-('x18', ctypes.c_double * 5),
-('x19', ctypes.c_double * 5),
-('x20', ctypes.c_double * 5),
+    _fields_ = [('x01', ctypes.c_double * 10),
+('x02', ctypes.c_double * 10),
+('x03', ctypes.c_double * 10),
+('x04', ctypes.c_double * 10),
+('x05', ctypes.c_double * 10),
+('x06', ctypes.c_double * 10),
+('x07', ctypes.c_double * 10),
+('x08', ctypes.c_double * 10),
+('x09', ctypes.c_double * 10),
+('x10', ctypes.c_double * 10),
 ]
 
 FORCENLPsolver_outputs = {'x01' : np.array([]),
@@ -162,16 +142,6 @@
 'x08' : np.array([]),
 'x09' : np.array([]),
 'x10' : np.array([]),
-'x11' : np.array([]),
-'x12' : np.array([]),
-'x13' : np.array([]),
-'x14' : np.array([]),
-'x15' : np.array([]),
-'x16' : np.array([]),
-'x17' : np.array([]),
-'x18' : np.array([]),
-'x19' : np.array([]),
-'x20' : np.array([]),
 }
 
 
@@ -204,32 +174,22 @@
 
    OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
    subject to the parameters supplied in the following dictionary:
-       PARAMS['xinit'] - column vector of length 3
+       PARAMS['xinit'] - column vector of length 6
        PARAMS['x0'] - column vector of length 100
        PARAMS['all_parameters'] - column vector of length 60
        PARAMS['reinitialize'] - scalar
 
    OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 5
-       OUTPUT['x02'] - column vector of size 5
-       OUTPUT['x03'] - column vector of size 5
-       OUTPUT['x04'] - column vector of size 5
-       OUTPUT['x05'] - column vector of size 5
-       OUTPUT['x06'] - column vector of size 5
-       OUTPUT['x07'] - column vector of size 5
-       OUTPUT['x08'] - column vector of size 5
-       OUTPUT['x09'] - column vector of size 5
-       OUTPUT['x10'] - column vector of size 5
-       OUTPUT['x11'] - column vector of size 5
-       OUTPUT['x12'] - column vector of size 5
-       OUTPUT['x13'] - column vector of size 5
-       OUTPUT['x14'] - column vector of size 5
-       OUTPUT['x15'] - column vector of size 5
-       OUTPUT['x16'] - column vector of size 5
-       OUTPUT['x17'] - column vector of size 5
-       OUTPUT['x18'] - column vector of size 5
-       OUTPUT['x19'] - column vector of size 5
-       OUTPUT['x20'] - column vector of size 5
+       OUTPUT['x01'] - column vector of size 10
+       OUTPUT['x02'] - column vector of size 10
+       OUTPUT['x03'] - column vector of size 10
+       OUTPUT['x04'] - column vector of size 10
+       OUTPUT['x05'] - column vector of size 10
+       OUTPUT['x06'] - column vector of size 10
+       OUTPUT['x07'] - column vector of size 10
+       OUTPUT['x08'] - column vector of size 10
+       OUTPUT['x09'] - column vector of size 10
+       OUTPUT['x10'] - column vector of size 10
 
    [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
    the integer EXITFLAG indicating the state of the solution with 
Index: model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nFORCENLPsolver : A fast customized optimization solver.\n\nCopyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n\n\nThis software is intended for simulation and testing purposes only. \nUse of this software for any commercial purpose is prohibited.\n\nThis program is distributed in the hope that it will be useful.\nEMBOTECH makes NO WARRANTIES with respect to the use of the software \nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. \n\nEMBOTECH shall not have any liability for any damage arising from the use\nof the software.\n\nThis Agreement shall exclusively be governed by and interpreted in \naccordance with the laws of Switzerland, excluding its principles\nof conflict of laws. The Courts of Zurich-City shall have exclusive \njurisdiction in case of any dispute.\n\n*/\n\n#include \"mex.h\"\n#include \"math.h\"\n#include <string.h>\n#include \"../include/FORCENLPsolver.h\"\n#ifndef SOLVER_STDIO_H\n#define SOLVER_STDIO_H\n#include <stdio.h>\n#endif\n\ntypedef FORCENLPsolver_float solver_float;\ntypedef solver_int32_default solver_int;\n#define NSTAGES ( 20 )\n#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))\n\n/* For compatibility with Microsoft Visual Studio 2015 */\n#if _MSC_VER >= 1900\nFILE _iob[3];\nFILE * __cdecl __iob_func(void)\n{\n\t_iob[0] = *stdin;\n\t_iob[1] = *stdout;\n\t_iob[2] = *stderr;\n\treturn _iob;\n}\n#endif\n\n/* copy functions */\n\nvoid copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (double)*src++;\n    }\n}\n\nvoid copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)\n{\n    *dest = (double)*src;\n}\n\nvoid copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (FORCENLPsolver_float) (*src++) ;\n    }\n}\n\nvoid copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)\n{\n\t*dest = (FORCENLPsolver_float) *src;\n}\n\n\n\nextern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);\nFORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;\n\n\nstatic void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, \n             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)\n{\n    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; \n    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\n    *nvar = nvarArr[stage];\n    *neq = neqArr[stage];\n    *dimh = dimhArr[stage];\n    *dimp = dimpArr[stage];\n    *diml = dimlArr[stage];\n    *dimu = dimuArr[stage];\n    *dimhl = dimhlArr[stage];\n    *dimhu = dimhuArr[stage];\n}\n\n/* Checks all inputs and returns stage number (1-indexed) */\nstatic void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, \n                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)\n{\n    mxArray *arr;\n\n    if (nrhs > 3 || nrhs < 1)\n\t{\n\t\tmexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"This function takes at least one input: z. And at most 3 inputs: z, p, stage.\");\n\t}     \n\n    // get stage\n    *stage = (solver_int) 1;\n    if (nrhs == 3)\n    {\n        arr = prhs[2];\n        if ( !mxIsDouble(arr) )\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The third input (stage number) must be an integer.\");\n        }\n        *stage = (solver_int) *mxGetPr(arr);\n    }\n    if ( *stage < 1 || (NSTAGES) < *stage )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"Stage must be between %d and %d.\", 1, (NSTAGES));\n    }    \n\n    /* Get other dimensions */\n    *stage -= 1; /* 0-indexed stages */\n    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);\n\n    /* Check that passed z and p have correct dims */  \n    arr = prhs[0];\n    if ( !mxIsDouble(arr) )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The first input (z) must be a column vector.\");\n    }    \n    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The first input (z) must be a column vector of length %d.\", *nvar);\n    }\n    if (nrhs > 1)\n\t{\n        arr = prhs[1];\n        if ( *dimp > 0 && mxIsEmpty(arr))\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector of length %d.\", *dimp);\n        }   \n        if ( !mxIsEmpty(arr) )\n        {\n            if ( !mxIsDouble(arr) )\n            {\n                mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector.\");\n            }    \n            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )\n            {\n                mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector of length %d.\", *dimp);\n            }            \n        }\n\t}\n    else\n    {\n        if ( *dimp > 0 )\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"Run time parameters are required as a second input for evaluating this fcn.\");\n        }         \n    } \n}\n\n/* THE mex-function */\nvoid mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  \n{\n\tmxArray *arr;\n    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;\n\n    // Allocate memory \n    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;\n\n\tmxArray* h_mex;\n\tmxArray* jach_mex;\n\n\n    // get data\n    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);\n    dimmul = diml+dimu+dimhl+dimhu;\n\n    // Allocate memory \n    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));\n    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));\n    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));\n    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));\n    obj = (solver_float *) malloc(sizeof(solver_float));\n    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));\n    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));\n    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));\n    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));\n    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));\n    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));\n\n    /* Initialize all inputs */\n    arr = prhs[0];\n    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);\n    if (nrhs > 1)\n\t{\n        arr = prhs[1];\n        if ( !mxIsEmpty(arr) )\n        {\n            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);\n        }\n\t}   \n    memset(y, 0, sizeof(solver_float)*neq);\n    memset(l, 0, sizeof(solver_float)*dimmul);\n    memset(obj, 0, sizeof(solver_float));\n    memset(jacobj, 0, sizeof(solver_float)*nvar);\n    memset(c, 0, sizeof(solver_float)*neq);\n    memset(jacc, 0, sizeof(solver_float)*neq*nvar);\n    memset(h, 0, sizeof(solver_float)*dimh);\n    memset(jach, 0, sizeof(solver_float)*dimh*nvar);\n    memset(hess, 0, sizeof(solver_float)*nvar*nvar);\n\n    // Evaluate fcns and read output into mex format\n\t(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);\n\th_mex = mxCreateDoubleMatrix(dimh, 1, mxREAL);\n\tjach_mex = mxCreateDoubleMatrix(dimh, nvar, mxREAL);\n\tcopyCArrayToM_FORCENLPsolver(h, mxGetPr(h_mex), dimh);\n\tcopyCArrayToM_FORCENLPsolver(jach, mxGetPr(jach_mex), dimh*nvar);\n\tplhs[0] = h_mex;\n\tplhs[1] = jach_mex;\n\n\n    // Free memory\n    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c	(date 1646039467400)
@@ -33,7 +33,7 @@
 
 typedef FORCENLPsolver_float solver_float;
 typedef solver_int32_default solver_int;
-#define NSTAGES ( 20 )
+#define NSTAGES ( 10 )
 #define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
 
 /* For compatibility with Microsoft Visual Studio 2015 */
@@ -87,14 +87,14 @@
 static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
              solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
 {
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int nvarArr[NSTAGES] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10}; 
+    const solver_int neqArr[NSTAGES] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
+    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimpArr[NSTAGES] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
+    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
     *nvar = nvarArr[stage];
     *neq = neqArr[stage];
Index: model/FORCENLPsolver/interface/FORCENLPsolver_lib.mdl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Model {\n  Name\t\t\t  \"FORCENLPsolver\"\n  Version\t\t  8.0\n  MdlSubVersion\t\t  0\n  GraphicalInterface {\n    NumRootInports\t    0\n    NumRootOutports\t    0\n    ParameterArgumentNames  \"\"\n    ComputedModelVersion    \"1.2\"\n    NumModelReferences\t    0\n    NumTestPointedSignals   0\n  }\n  SavedCharacterEncoding  \"windows-1252\"\n  SaveDefaultBlockParams  on\n  ScopeRefreshTime\t  0.035000\n  OverrideScopeRefreshTime on\n  DisableAllScopes\t  off\n  DataTypeOverride\t  \"UseLocalSettings\"\n  DataTypeOverrideAppliesTo \"AllNumericTypes\"\n  MinMaxOverflowLogging\t  \"UseLocalSettings\"\n  MinMaxOverflowArchiveMode \"Overwrite\"\n  FPTRunName\t\t  \"Run 1\"\n  MaxMDLFileLineLength\t  120\n  Object {\n    $PropName\t\t    \"BdWindowsInfo\"\n    $ObjectID\t\t    1\n    $ClassName\t\t    \"Simulink.BDWindowsInfo\"\n    Object {\n      $PropName\t\t      \"WindowsInfo\"\n      $ObjectID\t\t      2\n      $ClassName\t      \"Simulink.WindowInfo\"\n      IsActive\t\t      [1]\n      Location\t\t      [385.0, 84.0, 816.0, 539.0]\n      Object {\n\t$PropName\t\t\"ModelBrowserInfo\"\n\t$ObjectID\t\t3\n\t$ClassName\t\t\"Simulink.ModelBrowserInfo\"\n\tVisible\t\t\t[1]\n\tDockPosition\t\t\"Left\"\n\tWidth\t\t\t[50]\n\tHeight\t\t\t[50]\n\tFilter\t\t\t[9]\n      }\n      Object {\n\t$PropName\t\t\"ExplorerBarInfo\"\n\t$ObjectID\t\t4\n\t$ClassName\t\t\"Simulink.ExplorerBarInfo\"\n\tVisible\t\t\t[1]\n      }\n      Object {\n\t$PropName\t\t\"EditorsInfo\"\n\t$ObjectID\t\t5\n\t$ClassName\t\t\"Simulink.EditorInfo\"\n\tIsActive\t\t[1]\n\tViewObjType\t\t\"SimulinkTopLevel\"\n\tLoadSaveID\t\t\"0\"\n\tExtents\t\t\t[569.0, 363.0]\n\tZoomFactor\t\t[1.0]\n\tOffset\t\t\t[0.0, 0.0]\n      }\n    }\n  }\n  Created\t\t  \"2/27/2022 3:20:15 PM\"\n  Creator\t\t  \"embotech AG\"\n  UpdateHistory\t\t  \"UpdateHistoryNever\"\n  ModifiedByFormat\t  \"%<Auto>\"\n  LastModifiedBy\t  \"embotech AG\"\n  ModifiedDateFormat\t  \"%<Auto>\"\n  LastModifiedDate\t  \"2/27/2022 3:20:15 PM\"\n  RTWModifiedTimeStamp\t  315310195\n  ModelVersionFormat\t  \"1.%<AutoIncrement:2>\"\n  ConfigurationManager\t  \"None\"\n  SampleTimeColors\t  off\n  SampleTimeAnnotations\t  off\n  LibraryLinkDisplay\t  \"disabled\"\n  WideLines\t\t  off\n  ShowLineDimensions\t  off\n  ShowPortDataTypes\t  off\n  ShowDesignRanges\t  off\n  ShowLoopsOnError\t  on\n  IgnoreBidirectionalLines off\n  ShowStorageClass\t  off\n  ShowTestPointIcons\t  on\n  ShowSignalResolutionIcons on\n  ShowViewerIcons\t  on\n  SortedOrder\t\t  off\n  ExecutionContextIcon\t  off\n  ShowLinearizationAnnotations on\n  BlockNameDataTip\t  off\n  BlockParametersDataTip  off\n  BlockDescriptionStringDataTip\toff\n  ToolBar\t\t  on\n  StatusBar\t\t  on\n  BrowserShowLibraryLinks off\n  BrowserLookUnderMasks\t  off\n  SimulationMode\t  \"normal\"\n  LinearizationMsg\t  \"none\"\n  Profile\t\t  off\n  ParamWorkspaceSource\t  \"MATLABWorkspace\"\n  AccelSystemTargetFile\t  \"accel.tlc\"\n  AccelTemplateMakefile\t  \"accel_default_tmf\"\n  AccelMakeCommand\t  \"make_rtw\"\n  TryForcingSFcnDF\t  off\n  Object {\n    $PropName\t\t    \"DataLoggingOverride\"\n    $ObjectID\t\t    6\n    $ClassName\t\t    \"Simulink.SimulationData.ModelLoggingInfo\"\n    model_\t\t    \"model_2012b\"\n    overrideMode_\t    [0.0]\n    Array {\n      Type\t\t      \"Cell\"\n      Dimension\t\t      1\n      Cell\t\t      \"model_2012b\"\n      PropName\t\t      \"logAsSpecifiedByModels_\"\n    }\n    Array {\n      Type\t\t      \"Cell\"\n      Dimension\t\t      1\n      Cell\t\t      []\n      PropName\t\t      \"logAsSpecifiedByModelsSSIDs_\"\n    }\n  }\n  RecordCoverage\t  off\n  CovPath\t\t  \"/\"\n  CovSaveName\t\t  \"covdata\"\n  CovMetricSettings\t  \"dw\"\n  CovNameIncrementing\t  off\n  CovHtmlReporting\t  on\n  CovForceBlockReductionOff on\n  covSaveCumulativeToWorkspaceVar on\n  CovSaveSingleToWorkspaceVar on\n  CovCumulativeVarName\t  \"covCumulativeData\"\n  CovCumulativeReport\t  off\n  CovReportOnPause\t  on\n  CovModelRefEnable\t  \"Off\"\n  CovExternalEMLEnable\t  off\n  ExtModeBatchMode\t  off\n  ExtModeEnableFloating\t  on\n  ExtModeTrigType\t  \"manual\"\n  ExtModeTrigMode\t  \"normal\"\n  ExtModeTrigPort\t  \"1\"\n  ExtModeTrigElement\t  \"any\"\n  ExtModeTrigDuration\t  1000\n  ExtModeTrigDurationFloating \"auto\"\n  ExtModeTrigHoldOff\t  0\n  ExtModeTrigDelay\t  0\n  ExtModeTrigDirection\t  \"rising\"\n  ExtModeTrigLevel\t  0\n  ExtModeArchiveMode\t  \"off\"\n  ExtModeAutoIncOneShot\t  off\n  ExtModeIncDirWhenArm\t  off\n  ExtModeAddSuffixToVar\t  off\n  ExtModeWriteAllDataToWs off\n  ExtModeArmWhenConnect\t  on\n  ExtModeSkipDownloadWhenConnect off\n  ExtModeLogAll\t\t  on\n  ExtModeAutoUpdateStatusClock on\n  BufferReuse\t\t  on\n  ShowModelReferenceBlockVersion off\n  ShowModelReferenceBlockIO off\n  Array {\n    Type\t\t    \"Handle\"\n    Dimension\t\t    1\n    Simulink.ConfigSet {\n      $ObjectID\t\t      7\n      Version\t\t      \"1.12.1\"\n      Array {\n\tType\t\t\t\"Handle\"\n\tDimension\t\t8\n\tSimulink.SolverCC {\n\t  $ObjectID\t\t  8\n\t  Version\t\t  \"1.12.1\"\n\t  StartTime\t\t  \"0.0\"\n\t  StopTime\t\t  \"10.0\"\n\t  AbsTol\t\t  \"auto\"\n\t  FixedStep\t\t  \"auto\"\n\t  InitialStep\t\t  \"auto\"\n\t  MaxNumMinSteps\t  \"-1\"\n\t  MaxOrder\t\t  5\n\t  ZcThreshold\t\t  \"auto\"\n\t  ConsecutiveZCsStepRelTol \"10*128*eps\"\n\t  MaxConsecutiveZCs\t  \"1000\"\n\t  ExtrapolationOrder\t  4\n\t  NumberNewtonIterations  1\n\t  MaxStep\t\t  \"auto\"\n\t  MinStep\t\t  \"auto\"\n\t  MaxConsecutiveMinStep\t  \"1\"\n\t  RelTol\t\t  \"1e-3\"\n\t  SolverMode\t\t  \"Auto\"\n\t  EnableConcurrentExecution off\n\t  ConcurrentTasks\t  off\n\t  Solver\t\t  \"ode45\"\n\t  SolverName\t\t  \"ode45\"\n\t  SolverJacobianMethodControl \"auto\"\n\t  ShapePreserveControl\t  \"DisableAll\"\n\t  ZeroCrossControl\t  \"UseLocalSettings\"\n\t  ZeroCrossAlgorithm\t  \"Nonadaptive\"\n\t  AlgebraicLoopSolver\t  \"TrustRegion\"\n\t  SolverResetMethod\t  \"Fast\"\n\t  PositivePriorityOrder\t  off\n\t  AutoInsertRateTranBlk\t  off\n\t  SampleTimeConstraint\t  \"Unconstrained\"\n\t  InsertRTBMode\t\t  \"Whenever possible\"\n\t}\n\tSimulink.DataIOCC {\n\t  $ObjectID\t\t  9\n\t  Version\t\t  \"1.12.1\"\n\t  Decimation\t\t  \"1\"\n\t  ExternalInput\t\t  \"[t, u]\"\n\t  FinalStateName\t  \"xFinal\"\n\t  InitialState\t\t  \"xInitial\"\n\t  LimitDataPoints\t  on\n\t  MaxDataPoints\t\t  \"1000\"\n\t  LoadExternalInput\t  off\n\t  LoadInitialState\t  off\n\t  SaveFinalState\t  off\n\t  SaveCompleteFinalSimState off\n\t  SaveFormat\t\t  \"Array\"\n\t  SignalLoggingSaveFormat \"Dataset\"\n\t  SaveOutput\t\t  on\n\t  SaveState\t\t  off\n\t  SignalLogging\t\t  on\n\t  DSMLogging\t\t  on\n\t  InspectSignalLogs\t  off\n\t  SaveTime\t\t  on\n\t  ReturnWorkspaceOutputs  off\n\t  StateSaveName\t\t  \"xout\"\n\t  TimeSaveName\t\t  \"tout\"\n\t  OutputSaveName\t  \"yout\"\n\t  SignalLoggingName\t  \"logsout\"\n\t  DSMLoggingName\t  \"dsmout\"\n\t  OutputOption\t\t  \"RefineOutputTimes\"\n\t  OutputTimes\t\t  \"[]\"\n\t  ReturnWorkspaceOutputsName \"out\"\n\t  Refine\t\t  \"1\"\n\t}\n\tSimulink.OptimizationCC {\n\t  $ObjectID\t\t  10\n\t  Version\t\t  \"1.12.1\"\n\t  Array {\n\t    Type\t\t    \"Cell\"\n\t    Dimension\t\t    8\n\t    Cell\t\t    \"BooleansAsBitfields\"\n\t    Cell\t\t    \"PassReuseOutputArgsAs\"\n\t    Cell\t\t    \"PassReuseOutputArgsThreshold\"\n\t    Cell\t\t    \"ZeroExternalMemoryAtStartup\"\n\t    Cell\t\t    \"ZeroInternalMemoryAtStartup\"\n\t    Cell\t\t    \"OptimizeModelRefInitCode\"\n\t    Cell\t\t    \"NoFixptDivByZeroProtection\"\n\t    Cell\t\t    \"UseSpecifiedMinMax\"\n\t    PropName\t\t    \"DisabledProps\"\n\t  }\n\t  BlockReduction\t  on\n\t  BooleanDataType\t  on\n\t  ConditionallyExecuteInputs on\n\t  InlineParams\t\t  off\n\t  UseIntDivNetSlope\t  off\n\t  UseFloatMulNetSlope\t  off\n\t  UseSpecifiedMinMax\t  off\n\t  InlineInvariantSignals  off\n\t  OptimizeBlockIOStorage  on\n\t  BufferReuse\t\t  on\n\t  EnhancedBackFolding\t  off\n\t  StrengthReduction\t  off\n\t  ExpressionFolding\t  on\n\t  BooleansAsBitfields\t  off\n\t  BitfieldContainerType\t  \"uint_T\"\n\t  EnableMemcpy\t\t  on\n\t  MemcpyThreshold\t  64\n\t  PassReuseOutputArgsAs\t  \"Structure reference\"\n\t  ExpressionDepthLimit\t  2147483647\n\t  FoldNonRolledExpr\t  on\n\t  LocalBlockOutputs\t  on\n\t  RollThreshold\t\t  5\n\t  SystemCodeInlineAuto\t  off\n\t  StateBitsets\t\t  off\n\t  DataBitsets\t\t  off\n\t  UseTempVars\t\t  off\n\t  ZeroExternalMemoryAtStartup on\n\t  ZeroInternalMemoryAtStartup on\n\t  InitFltsAndDblsToZero\t  off\n\t  NoFixptDivByZeroProtection off\n\t  EfficientFloat2IntCast  off\n\t  EfficientMapNaN2IntZero on\n\t  OptimizeModelRefInitCode off\n\t  LifeSpan\t\t  \"inf\"\n\t  MaxStackSize\t\t  \"Inherit from target\"\n\t  BufferReusableBoundary  on\n\t  SimCompilerOptimization \"Off\"\n\t  AccelVerboseBuild\t  off\n\t  ParallelExecutionInRapidAccelerator on\n\t}\n\tSimulink.DebuggingCC {\n\t  $ObjectID\t\t  11\n\t  Version\t\t  \"1.12.1\"\n\t  RTPrefix\t\t  \"error\"\n\t  ConsistencyChecking\t  \"none\"\n\t  ArrayBoundsChecking\t  \"none\"\n\t  SignalInfNanChecking\t  \"none\"\n\t  SignalRangeChecking\t  \"none\"\n\t  ReadBeforeWriteMsg\t  \"UseLocalSettings\"\n\t  WriteAfterWriteMsg\t  \"UseLocalSettings\"\n\t  WriteAfterReadMsg\t  \"UseLocalSettings\"\n\t  AlgebraicLoopMsg\t  \"warning\"\n\t  ArtificialAlgebraicLoopMsg \"warning\"\n\t  SaveWithDisabledLinksMsg \"warning\"\n\t  SaveWithParameterizedLinksMsg\t\"warning\"\n\t  CheckSSInitialOutputMsg on\n\t  UnderspecifiedInitializationDetection\t\"Classic\"\n\t  MergeDetectMultiDrivingBlocksExec \"none\"\n\t  CheckExecutionContextPreStartOutputMsg off\n\t  CheckExecutionContextRuntimeOutputMsg\toff\n\t  SignalResolutionControl \"UseLocalSettings\"\n\t  BlockPriorityViolationMsg \"warning\"\n\t  MinStepSizeMsg\t  \"warning\"\n\t  TimeAdjustmentMsg\t  \"none\"\n\t  MaxConsecutiveZCsMsg\t  \"error\"\n\t  MaskedZcDiagnostic\t  \"warning\"\n\t  IgnoredZcDiagnostic\t  \"warning\"\n\t  SolverPrmCheckMsg\t  \"warning\"\n\t  InheritedTsInSrcMsg\t  \"warning\"\n\t  DiscreteInheritContinuousMsg \"warning\"\n\t  MultiTaskDSMMsg\t  \"error\"\n\t  MultiTaskCondExecSysMsg \"error\"\n\t  MultiTaskRateTransMsg\t  \"error\"\n\t  SingleTaskRateTransMsg  \"none\"\n\t  TasksWithSamePriorityMsg \"warning\"\n\t  SigSpecEnsureSampleTimeMsg \"warning\"\n\t  CheckMatrixSingularityMsg \"none\"\n\t  IntegerOverflowMsg\t  \"warning\"\n\t  Int32ToFloatConvMsg\t  \"warning\"\n\t  ParameterDowncastMsg\t  \"error\"\n\t  ParameterOverflowMsg\t  \"error\"\n\t  ParameterUnderflowMsg\t  \"none\"\n\t  ParameterPrecisionLossMsg \"warning\"\n\t  ParameterTunabilityLossMsg \"warning\"\n\t  FixptConstUnderflowMsg  \"none\"\n\t  FixptConstOverflowMsg\t  \"none\"\n\t  FixptConstPrecisionLossMsg \"none\"\n\t  UnderSpecifiedDataTypeMsg \"none\"\n\t  UnnecessaryDatatypeConvMsg \"none\"\n\t  VectorMatrixConversionMsg \"none\"\n\t  InvalidFcnCallConnMsg\t  \"error\"\n\t  FcnCallInpInsideContextMsg \"EnableAllAsError\"\n\t  SignalLabelMismatchMsg  \"none\"\n\t  UnconnectedInputMsg\t  \"warning\"\n\t  UnconnectedOutputMsg\t  \"warning\"\n\t  UnconnectedLineMsg\t  \"warning\"\n\t  SFcnCompatibilityMsg\t  \"none\"\n\t  FrameProcessingCompatibilityMsg \"warning\"\n\t  UniqueDataStoreMsg\t  \"none\"\n\t  BusObjectLabelMismatch  \"warning\"\n\t  RootOutportRequireBusObject \"warning\"\n\t  AssertControl\t\t  \"UseLocalSettings\"\n\t  EnableOverflowDetection off\n\t  ModelReferenceIOMsg\t  \"none\"\n\t  ModelReferenceMultiInstanceNormalModeStructChecksumCheck \"error\"\n\t  ModelReferenceVersionMismatchMessage \"none\"\n\t  ModelReferenceIOMismatchMessage \"none\"\n\t  ModelReferenceCSMismatchMessage \"none\"\n\t  UnknownTsInhSupMsg\t  \"warning\"\n\t  ModelReferenceDataLoggingMessage \"warning\"\n\t  ModelReferenceSymbolNameMessage \"warning\"\n\t  ModelReferenceExtraNoncontSigs \"error\"\n\t  StateNameClashWarn\t  \"warning\"\n\t  SimStateInterfaceChecksumMismatchMsg \"warning\"\n\t  SimStateOlderReleaseMsg \"error\"\n\t  InitInArrayFormatMsg\t  \"warning\"\n\t  StrictBusMsg\t\t  \"ErrorLevel1\"\n\t  BusNameAdapt\t\t  \"WarnAndRepair\"\n\t  NonBusSignalsTreatedAsBus \"none\"\n\t  LoggingUnavailableSignals \"error\"\n\t  BlockIODiagnostic\t  \"none\"\n\t  SFUnusedDataAndEventsDiag \"warning\"\n\t  SFUnexpectedBacktrackingDiag \"warning\"\n\t  SFInvalidInputDataAccessInChartInitDiag \"warning\"\n\t  SFNoUnconditionalDefaultTransitionDiag \"warning\"\n\t  SFTransitionOutsideNaturalParentDiag \"warning\"\n\t  SFUnconditionalTransitionShadowingDiag \"warning\"\n\t  SFUndirectedBroadcastEventsDiag \"warning\"\n\t  SFTransitionActionBeforeConditionDiag\t\"warning\"\n\t}\n\tSimulink.HardwareCC {\n\t  $ObjectID\t\t  12\n\t  Version\t\t  \"1.12.1\"\n\t  ProdBitPerChar\t  8\n\t  ProdBitPerShort\t  16\n\t  ProdBitPerInt\t\t  32\n\t  ProdBitPerLong\t  32\n\t  ProdBitPerFloat\t  32\n\t  ProdBitPerDouble\t  64\n\t  ProdBitPerPointer\t  32\n\t  ProdLargestAtomicInteger \"Char\"\n\t  ProdLargestAtomicFloat  \"None\"\n\t  ProdIntDivRoundTo\t  \"Undefined\"\n\t  ProdEndianess\t\t  \"Unspecified\"\n\t  ProdWordSize\t\t  32\n\t  ProdShiftRightIntArith  on\n\t  ProdHWDeviceType\t  \"32-bit Generic\"\n\t  TargetBitPerChar\t  8\n\t  TargetBitPerShort\t  16\n\t  TargetBitPerInt\t  32\n\t  TargetBitPerLong\t  32\n\t  TargetBitPerFloat\t  32\n\t  TargetBitPerDouble\t  64\n\t  TargetBitPerPointer\t  32\n\t  TargetLargestAtomicInteger \"Char\"\n\t  TargetLargestAtomicFloat \"None\"\n\t  TargetShiftRightIntArith on\n\t  TargetIntDivRoundTo\t  \"Undefined\"\n\t  TargetEndianess\t  \"Unspecified\"\n\t  TargetWordSize\t  32\n\t  TargetTypeEmulationWarnSuppressLevel 0\n\t  TargetPreprocMaxBitsSint 32\n\t  TargetPreprocMaxBitsUint 32\n\t  TargetHWDeviceType\t  \"Specified\"\n\t  TargetUnknown\t\t  off\n\t  ProdEqTarget\t\t  on\n\t}\n\tSimulink.ModelReferenceCC {\n\t  $ObjectID\t\t  13\n\t  Version\t\t  \"1.12.1\"\n\t  UpdateModelReferenceTargets \"IfOutOfDateOrStructuralChange\"\n\t  CheckModelReferenceTargetMessage \"error\"\n\t  EnableParallelModelReferenceBuilds off\n\t  ParallelModelReferenceErrorOnInvalidPool on\n\t  ParallelModelReferenceMATLABWorkerInit \"None\"\n\t  ModelReferenceNumInstancesAllowed \"Multi\"\n\t  PropagateVarSize\t  \"Infer from blocks in model\"\n\t  ModelReferencePassRootInputsByReference on\n\t  ModelReferenceMinAlgLoopOccurrences off\n\t  PropagateSignalLabelsOutOfModel off\n\t  SupportModelReferenceSimTargetCustomCode off\n\t}\n\tSimulink.SFSimCC {\n\t  $ObjectID\t\t  14\n\t  Version\t\t  \"1.12.1\"\n\t  SFSimEnableDebug\t  on\n\t  SFSimOverflowDetection  on\n\t  SFSimEcho\t\t  on\n\t  SimBlas\t\t  on\n\t  SimCtrlC\t\t  on\n\t  SimExtrinsic\t\t  on\n\t  SimIntegrity\t\t  on\n\t  SimUseLocalCustomCode\t  off\n\t  SimParseCustomCode\t  on\n\t  SimBuildMode\t\t  \"sf_incremental_build\"\n\t}\n\tSimulink.RTWCC {\n\t  $BackupClass\t\t  \"Simulink.RTWCC\"\n\t  $ObjectID\t\t  15\n\t  Version\t\t  \"1.12.1\"\n\t  Array {\n\t    Type\t\t    \"Cell\"\n\t    Dimension\t\t    15\n\t    Cell\t\t    \"IncludeHyperlinkInReport\"\n\t    Cell\t\t    \"GenerateTraceInfo\"\n\t    Cell\t\t    \"GenerateTraceReport\"\n\t    Cell\t\t    \"GenerateTraceReportSl\"\n\t    Cell\t\t    \"GenerateTraceReportSf\"\n\t    Cell\t\t    \"GenerateTraceReportEml\"\n\t    Cell\t\t    \"PortableWordSizes\"\n\t    Cell\t\t    \"GenerateWebview\"\n\t    Cell\t\t    \"GenerateCodeMetricsReport\"\n\t    Cell\t\t    \"GenerateCodeReplacementReport\"\n\t    Cell\t\t    \"GenerateErtSFunction\"\n\t    Cell\t\t    \"CreateSILPILBlock\"\n\t    Cell\t\t    \"CodeExecutionProfiling\"\n\t    Cell\t\t    \"CodeProfilingSaveOptions\"\n\t    Cell\t\t    \"CodeProfilingInstrumentation\"\n\t    PropName\t\t    \"DisabledProps\"\n\t  }\n\t  SystemTargetFile\t  \"grt.tlc\"\n\t  GenCodeOnly\t\t  off\n\t  MakeCommand\t\t  \"make_rtw\"\n\t  GenerateMakefile\t  on\n\t  PackageGeneratedCodeAndArtifacts off\n\t  TemplateMakefile\t  \"grt_default_tmf\"\n\t  GenerateReport\t  off\n\t  SaveLog\t\t  off\n\t  RTWVerbose\t\t  on\n\t  RetainRTWFile\t\t  off\n\t  ProfileTLC\t\t  off\n\t  TLCDebug\t\t  off\n\t  TLCCoverage\t\t  off\n\t  TLCAssert\t\t  off\n\t  ProcessScriptMode\t  \"Default\"\n\t  ConfigurationMode\t  \"Optimized\"\n\t  ConfigAtBuild\t\t  off\n\t  RTWUseLocalCustomCode\t  off\n\t  RTWUseSimCustomCode\t  off\n\t  IncludeHyperlinkInReport off\n\t  LaunchReport\t\t  off\n\t  PortableWordSizes\t  off\n\t  GenerateErtSFunction\t  off\n\t  CreateSILPILBlock\t  \"None\"\n\t  CodeExecutionProfiling  off\n\t  CodeExecutionProfileVariable \"executionProfile\"\n\t  CodeProfilingSaveOptions \"SummaryOnly\"\n\t  CodeProfilingInstrumentation off\n\t  TargetLang\t\t  \"C\"\n\t  IncludeBusHierarchyInRTWFileBlockHierarchyMap\toff\n\t  IncludeERTFirstTime\t  off\n\t  GenerateTraceInfo\t  off\n\t  GenerateTraceReport\t  off\n\t  GenerateTraceReportSl\t  off\n\t  GenerateTraceReportSf\t  off\n\t  GenerateTraceReportEml  off\n\t  GenerateCodeInfo\t  off\n\t  GenerateWebview\t  off\n\t  GenerateCodeMetricsReport off\n\t  GenerateCodeReplacementReport\toff\n\t  RTWCompilerOptimization \"Off\"\n\t  CheckMdlBeforeBuild\t  \"Off\"\n\t  CustomRebuildMode\t  \"OnUpdate\"\n\t  Array {\n\t    Type\t\t    \"Handle\"\n\t    Dimension\t\t    2\n\t    Simulink.CodeAppCC {\n\t      $ObjectID\t\t      16\n\t      Version\t\t      \"1.12.1\"\n\t      Array {\n\t\tType\t\t\t\"Cell\"\n\t\tDimension\t\t22\n\t\tCell\t\t\t\"IgnoreCustomStorageClasses\"\n\t\tCell\t\t\t\"IgnoreTestpoints\"\n\t\tCell\t\t\t\"InsertBlockDesc\"\n\t\tCell\t\t\t\"InsertPolySpaceComments\"\n\t\tCell\t\t\t\"SFDataObjDesc\"\n\t\tCell\t\t\t\"MATLABFcnDesc\"\n\t\tCell\t\t\t\"SimulinkDataObjDesc\"\n\t\tCell\t\t\t\"DefineNamingRule\"\n\t\tCell\t\t\t\"SignalNamingRule\"\n\t\tCell\t\t\t\"ParamNamingRule\"\n\t\tCell\t\t\t\"InternalIdentifier\"\n\t\tCell\t\t\t\"InlinedPrmAccess\"\n\t\tCell\t\t\t\"CustomSymbolStr\"\n\t\tCell\t\t\t\"CustomSymbolStrGlobalVar\"\n\t\tCell\t\t\t\"CustomSymbolStrType\"\n\t\tCell\t\t\t\"CustomSymbolStrField\"\n\t\tCell\t\t\t\"CustomSymbolStrFcn\"\n\t\tCell\t\t\t\"CustomSymbolStrFcnArg\"\n\t\tCell\t\t\t\"CustomSymbolStrBlkIO\"\n\t\tCell\t\t\t\"CustomSymbolStrTmpVar\"\n\t\tCell\t\t\t\"CustomSymbolStrMacro\"\n\t\tCell\t\t\t\"ReqsInCode\"\n\t\tPropName\t\t\"DisabledProps\"\n\t      }\n\t      ForceParamTrailComments off\n\t      GenerateComments\t      on\n\t      IgnoreCustomStorageClasses on\n\t      IgnoreTestpoints\t      off\n\t      IncHierarchyInIds\t      off\n\t      MaxIdLength\t      31\n\t      PreserveName\t      off\n\t      PreserveNameWithParent  off\n\t      ShowEliminatedStatement off\n\t      OperatorAnnotations     off\n\t      IncAutoGenComments      off\n\t      SimulinkDataObjDesc     off\n\t      SFDataObjDesc\t      off\n\t      MATLABFcnDesc\t      off\n\t      IncDataTypeInIds\t      off\n\t      MangleLength\t      1\n\t      CustomSymbolStrGlobalVar \"$R$N$M\"\n\t      CustomSymbolStrType     \"$N$R$M\"\n\t      CustomSymbolStrField    \"$N$M\"\n\t      CustomSymbolStrFcn      \"$R$N$M$F\"\n\t      CustomSymbolStrFcnArg   \"rt$I$N$M\"\n\t      CustomSymbolStrBlkIO    \"rtb_$N$M\"\n\t      CustomSymbolStrTmpVar   \"$N$M\"\n\t      CustomSymbolStrMacro    \"$R$N$M\"\n\t      DefineNamingRule\t      \"None\"\n\t      ParamNamingRule\t      \"None\"\n\t      SignalNamingRule\t      \"None\"\n\t      InsertBlockDesc\t      off\n\t      InsertPolySpaceComments off\n\t      SimulinkBlockComments   on\n\t      MATLABSourceComments    off\n\t      EnableCustomComments    off\n\t      InternalIdentifier      \"Classic\"\n\t      InlinedPrmAccess\t      \"Literals\"\n\t      ReqsInCode\t      off\n\t      UseSimReservedNames     off\n\t    }\n\t    Simulink.GRTTargetCC {\n\t      $BackupClass\t      \"Simulink.TargetCC\"\n\t      $ObjectID\t\t      17\n\t      Version\t\t      \"1.12.1\"\n\t      Array {\n\t\tType\t\t\t\"Cell\"\n\t\tDimension\t\t15\n\t\tCell\t\t\t\"GeneratePreprocessorConditionals\"\n\t\tCell\t\t\t\"IncludeMdlTerminateFcn\"\n\t\tCell\t\t\t\"CombineOutputUpdateFcns\"\n\t\tCell\t\t\t\"SuppressErrorStatus\"\n\t\tCell\t\t\t\"ERTCustomFileBanners\"\n\t\tCell\t\t\t\"GenerateSampleERTMain\"\n\t\tCell\t\t\t\"GenerateTestInterfaces\"\n\t\tCell\t\t\t\"ModelStepFunctionPrototypeControlCompliant\"\n\t\tCell\t\t\t\"CPPClassGenCompliant\"\n\t\tCell\t\t\t\"MultiInstanceERTCode\"\n\t\tCell\t\t\t\"PurelyIntegerCode\"\n\t\tCell\t\t\t\"SupportComplex\"\n\t\tCell\t\t\t\"SupportAbsoluteTime\"\n\t\tCell\t\t\t\"SupportContinuousTime\"\n\t\tCell\t\t\t\"SupportNonInlinedSFcns\"\n\t\tPropName\t\t\"DisabledProps\"\n\t      }\n\t      TargetFcnLib\t      \"ansi_tfl_table_tmw.mat\"\n\t      TargetLibSuffix\t      \"\"\n\t      TargetPreCompLibLocation \"\"\n\t      CodeReplacementLibrary  \"ANSI_C\"\n\t      UtilityFuncGeneration   \"Auto\"\n\t      ERTMultiwordTypeDef     \"System defined\"\n\t      ERTMultiwordLength      256\n\t      MultiwordLength\t      2048\n\t      GenerateFullHeader      on\n\t      GenerateSampleERTMain   off\n\t      GenerateTestInterfaces  off\n\t      IsPILTarget\t      off\n\t      ModelReferenceCompliant on\n\t      ParMdlRefBuildCompliant on\n\t      CompOptLevelCompliant   on\n\t      ConcurrentExecutionCompliant on\n\t      IncludeMdlTerminateFcn  on\n\t      GeneratePreprocessorConditionals \"Disable all\"\n\t      CombineOutputUpdateFcns on\n\t      CombineSignalStateStructs\toff\n\t      SuppressErrorStatus     off\n\t      ERTFirstTimeCompliant   off\n\t      IncludeFileDelimiter    \"Auto\"\n\t      ERTCustomFileBanners    off\n\t      SupportAbsoluteTime     on\n\t      LogVarNameModifier      \"rt_\"\n\t      MatFileLogging\t      on\n\t      MultiInstanceERTCode    off\n\t      SupportNonFinite\t      on\n\t      SupportComplex\t      on\n\t      PurelyIntegerCode\t      off\n\t      SupportContinuousTime   on\n\t      SupportNonInlinedSFcns  on\n\t      SupportVariableSizeSignals off\n\t      EnableShiftOperators    on\n\t      ParenthesesLevel\t      \"Nominal\"\n\t      ModelStepFunctionPrototypeControlCompliant off\n\t      CPPClassGenCompliant    off\n\t      AutosarCompliant\t      off\n\t      GRTInterface\t      off\n\t      UseMalloc\t\t      off\n\t      ExtMode\t\t      off\n\t      ExtModeStaticAlloc      off\n\t      ExtModeTesting\t      off\n\t      ExtModeStaticAllocSize  1000000\n\t      ExtModeTransport\t      0\n\t      ExtModeMexFile\t      \"ext_comm\"\n\t      ExtModeIntrfLevel\t      \"Level1\"\n\t      RTWCAPISignals\t      off\n\t      RTWCAPIParams\t      off\n\t      RTWCAPIStates\t      off\n\t      RTWCAPIRootIO\t      off\n\t      GenerateASAP2\t      off\n\t    }\n\t    PropName\t\t    \"Components\"\n\t  }\n\t}\n\tPropName\t\t\"Components\"\n      }\n      Name\t\t      \"Configuration\"\n      CurrentDlgPage\t      \"Solver\"\n      ConfigPrmDlgPosition     [ 520, 225, 1400, 855 ] \n    }\n    PropName\t\t    \"ConfigurationSets\"\n  }\n  Simulink.ConfigSet {\n    $PropName\t\t    \"ActiveConfigurationSet\"\n    $ObjectID\t\t    7\n  }\n  Object {\n    $PropName\t\t    \"DataTransfer\"\n    $ObjectID\t\t    18\n    $ClassName\t\t    \"Simulink.GlobalDataTransfer\"\n    DefaultTransitionBetweenSyncTasks \"Ensure deterministic transfer (maximum delay)\"\n    DefaultTransitionBetweenAsyncTasks \"Ensure data integrity only\"\n    DefaultTransitionBetweenContTasks \"Ensure deterministic transfer (minimum delay)\"\n    DefaultExtrapolationMethodBetweenContTasks \"None\"\n    AutoInsertRateTranBlk   [0]\n  }\n  ExplicitPartitioning\t  off\n  BlockDefaults {\n    ForegroundColor\t    \"black\"\n    BackgroundColor\t    \"white\"\n    DropShadow\t\t    off\n    NamePlacement\t    \"normal\"\n    FontName\t\t    \"Helvetica\"\n    FontSize\t\t    10\n    FontWeight\t\t    \"normal\"\n    FontAngle\t\t    \"normal\"\n    ShowName\t\t    on\n    BlockRotation\t    0\n    BlockMirror\t\t    off\n  }\n  AnnotationDefaults {\n    HorizontalAlignment\t    \"center\"\n    VerticalAlignment\t    \"middle\"\n    ForegroundColor\t    \"black\"\n    BackgroundColor\t    \"white\"\n    DropShadow\t\t    off\n    FontName\t\t    \"Helvetica\"\n    FontSize\t\t    10\n    FontWeight\t\t    \"normal\"\n    FontAngle\t\t    \"normal\"\n    UseDisplayTextAsClickCallback off\n  }\n  LineDefaults {\n    FontName\t\t    \"Helvetica\"\n    FontSize\t\t    9\n    FontWeight\t\t    \"normal\"\n    FontAngle\t\t    \"normal\"\n  }\n  MaskDefaults {\n    SelfModifiable\t    \"off\"\n    IconFrame\t\t    \"on\"\n    IconOpaque\t\t    \"on\"\n    RunInitForIconRedraw    \"off\"\n    IconRotate\t\t    \"none\"\n    PortRotate\t\t    \"default\"\n    IconUnits\t\t    \"autoscale\"\n  }\n  MaskParameterDefaults {\n    Evaluate\t\t    \"on\"\n    Tunable\t\t    \"on\"\n    NeverSave\t\t    \"off\"\n    Internal\t\t    \"off\"\n    ReadOnly\t\t    \"off\"\n    Enabled\t\t    \"on\"\n    Visible\t\t    \"on\"\n    ToolTip\t\t    \"on\"\n  }\n  BlockParameterDefaults {\n    Block {\n      BlockType\t\t      S-Function\n      FunctionName\t      \"system\"\n      SFunctionModules\t      \"''\"\n      PortCounts\t      \"[]\"\n      SFunctionDeploymentMode off\n    }\n  }\n  System {\n    Name\t\t    \"FORCENLPsolver\"\n    Location\t\t    [385, 84, 1201, 623]\n    Open\t\t    on\n    ModelBrowserVisibility  on\n    ModelBrowserWidth\t    200\n    ScreenColor\t\t    \"white\"\n    PaperOrientation\t    \"landscape\"\n    PaperPositionMode\t    \"auto\"\n    PaperType\t\t    \"A4\"\n    PaperUnits\t\t    \"centimeters\"\n    TiledPaperMargins\t    [1.270000, 1.270000, 1.270000, 1.270000]\n    TiledPageScale\t    1\n    ShowPageBoundaries\t    off\n    ZoomFactor\t\t    \"100\"\n    ReportName\t\t    \"simulink-default.rpt\"\n    SIDHighWatermark\t    \"1\"\n    Block {\n      BlockType\t\t      S-Function\n      Name\t\t      \"FORCENLPsolver\"\n      SID\t\t      \"1\"\n      Ports\t\t      [4, 20]\n      Position\t\t      [170, 99, 650, 340]\n      ZOrder\t\t      1\n      FunctionName\t      \"FORCENLPsolver_simulinkBlock\"\n\t  SFunctionModules\t      \"FORCENLPsolver FORCENLPsolver_simulinkBlock\"\n      EnableBusSupport\t      off\n      Object {\n\t$PropName\t\t\"MaskObject\"\n\t$ObjectID\t\t19\n\t$ClassName\t\t\"Simulink.Mask\"\n\tType\t\t\t\"FORCENLPsolver_simulinkBlock\"\n\tDescription\t\t\" ---- Simulink block encapsulating your customized solver FORCENLPsolver ---- \\n\\n\"\n\t\t\t\t\"FORCENLPsolver : A fast customized optimization solver.\\n\"\n\"\\n\"\n\"Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\\n\"\n\"\\n\"\n\"\\n\"\n\"This software is intended for simulation and testing purposes only. \\n\"\n\"Use of this software for any commercial purpose is prohibited.\\n\"\n\"\\n\"\n\"This program is distributed in the hope that it will be useful.\\n\"\n\"EMBOTECH makes NO WARRANTIES with respect to the use of the software \\n\"\n\"without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \\n\"\n\"PARTICULAR PURPOSE. \\n\"\n\"\\n\"\n\"EMBOTECH shall not have any liability for any damage arising from the use\\n\"\n\"of the software.\\n\"\n\"\\n\"\n\"This Agreement shall exclusively be governed by and interpreted in \\n\"\n\"accordance with the laws of Switzerland, excluding its principles\\n\"\n\"of conflict of laws. The Courts of Zurich-City shall have exclusive \\n\"\n\"jurisdiction in case of any dispute.\\n\"\n\"\\n\"\n\n\tHelp\t\t\t\"FORCENLPsolver_simulinkBlock provides an easy Simulink interface for simulating your customized solver.  \\n\"\n\t\"\\nOUTPUTS = FORCENLPsolver(INPUTS) solves an optimization problem where:\\n\\n\"\n\t\"INPUTS:\\n\"\n\t\" - xinit - column vector of length 3\\n \"\n\" - x0 - column vector of length 100\\n \"\n\" - all_parameters - column vector of length 60\\n \"\n\" - reinitialize - column vector of length 0\\n \"\n\n\t\"\\nOUTPUTS:\\n\"\n\t\" - x01 - column vector of length 5\\n \"\n\" - x02 - column vector of length 5\\n \"\n\" - x03 - column vector of length 5\\n \"\n\" - x04 - column vector of length 5\\n \"\n\" - x05 - column vector of length 5\\n \"\n\" - x06 - column vector of length 5\\n \"\n\" - x07 - column vector of length 5\\n \"\n\" - x08 - column vector of length 5\\n \"\n\" - x09 - column vector of length 5\\n \"\n\" - x10 - column vector of length 5\\n \"\n\" - x11 - column vector of length 5\\n \"\n\" - x12 - column vector of length 5\\n \"\n\" - x13 - column vector of length 5\\n \"\n\" - x14 - column vector of length 5\\n \"\n\" - x15 - column vector of length 5\\n \"\n\" - x16 - column vector of length 5\\n \"\n\" - x17 - column vector of length 5\\n \"\n\" - x18 - column vector of length 5\\n \"\n\" - x19 - column vector of length 5\\n \"\n\" - x20 - column vector of length 5\\n \"\n\n\t\"\\n For more information, see https://forces.embotech.com/Documentation/graphical_interface/index.html \\n \"\n\n\tDisplay\t\t\t\"port_label('input', 1, 'xinit') \\n  \"\n\"port_label('input', 2, 'x0') \\n  \"\n\"port_label('input', 3, 'all_parameters') \\n  \"\n\"port_label('input', 4, 'reinitialize') \\n  \"\n\"port_label('output', 1, 'x01') \\n \"\n\"port_label('output', 2, 'x02') \\n \"\n\"port_label('output', 3, 'x03') \\n \"\n\"port_label('output', 4, 'x04') \\n \"\n\"port_label('output', 5, 'x05') \\n \"\n\"port_label('output', 6, 'x06') \\n \"\n\"port_label('output', 7, 'x07') \\n \"\n\"port_label('output', 8, 'x08') \\n \"\n\"port_label('output', 9, 'x09') \\n \"\n\"port_label('output', 10, 'x10') \\n \"\n\"port_label('output', 11, 'x11') \\n \"\n\"port_label('output', 12, 'x12') \\n \"\n\"port_label('output', 13, 'x13') \\n \"\n\"port_label('output', 14, 'x14') \\n \"\n\"port_label('output', 15, 'x15') \\n \"\n\"port_label('output', 16, 'x16') \\n \"\n\"port_label('output', 17, 'x17') \\n \"\n\"port_label('output', 18, 'x18') \\n \"\n\"port_label('output', 19, 'x19') \\n \"\n\"port_label('output', 20, 'x20') \\n \"\n\"if( exist('FORCES_PRO_Logo.jpg','file') ), image(imread('FORCES_PRO_Logo.jpg'),'center','on'); elseif( exist(['interface',filesep,'FORCES_PRO_Logo.jpg'],'file') ), image(imread(['interface',filesep,'FORCES_PRO_Logo.jpg']),'center','on'); elseif( exist(['FORCENLPsolver',filesep,'interface',filesep,'FORCES_PRO_Logo.jpg'],'file') ), image(imread(['FORCENLPsolver',filesep,'interface',filesep,'FORCES_PRO_Logo.jpg']),'center','on'); end \\n \"\n\n      }\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_lib.mdl b/model/FORCENLPsolver/interface/FORCENLPsolver_lib.mdl
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_lib.mdl	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_lib.mdl	(date 1646039467396)
@@ -60,13 +60,13 @@
       }
     }
   }
-  Created		  "2/27/2022 3:20:15 PM"
+  Created		  "2/28/2022 9:11:02 AM"
   Creator		  "embotech AG"
   UpdateHistory		  "UpdateHistoryNever"
   ModifiedByFormat	  "%<Auto>"
   LastModifiedBy	  "embotech AG"
   ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "2/27/2022 3:20:15 PM"
+  LastModifiedDate	  "2/28/2022 9:11:02 AM"
   RTWModifiedTimeStamp	  315310195
   ModelVersionFormat	  "1.%<AutoIncrement:2>"
   ConfigurationManager	  "None"
@@ -767,8 +767,8 @@
       BlockType		      S-Function
       Name		      "FORCENLPsolver"
       SID		      "1"
-      Ports		      [4, 20]
-      Position		      [170, 99, 650, 340]
+      Ports		      [4, 10]
+      Position		      [170, 99, 650, 180]
       ZOrder		      1
       FunctionName	      "FORCENLPsolver_simulinkBlock"
 	  SFunctionModules	      "FORCENLPsolver FORCENLPsolver_simulinkBlock"
@@ -804,32 +804,22 @@
 	Help			"FORCENLPsolver_simulinkBlock provides an easy Simulink interface for simulating your customized solver.  \n"
 	"\nOUTPUTS = FORCENLPsolver(INPUTS) solves an optimization problem where:\n\n"
 	"INPUTS:\n"
-	" - xinit - column vector of length 3\n "
+	" - xinit - column vector of length 6\n "
 " - x0 - column vector of length 100\n "
 " - all_parameters - column vector of length 60\n "
 " - reinitialize - column vector of length 0\n "
 
 	"\nOUTPUTS:\n"
-	" - x01 - column vector of length 5\n "
-" - x02 - column vector of length 5\n "
-" - x03 - column vector of length 5\n "
-" - x04 - column vector of length 5\n "
-" - x05 - column vector of length 5\n "
-" - x06 - column vector of length 5\n "
-" - x07 - column vector of length 5\n "
-" - x08 - column vector of length 5\n "
-" - x09 - column vector of length 5\n "
-" - x10 - column vector of length 5\n "
-" - x11 - column vector of length 5\n "
-" - x12 - column vector of length 5\n "
-" - x13 - column vector of length 5\n "
-" - x14 - column vector of length 5\n "
-" - x15 - column vector of length 5\n "
-" - x16 - column vector of length 5\n "
-" - x17 - column vector of length 5\n "
-" - x18 - column vector of length 5\n "
-" - x19 - column vector of length 5\n "
-" - x20 - column vector of length 5\n "
+	" - x01 - column vector of length 10\n "
+" - x02 - column vector of length 10\n "
+" - x03 - column vector of length 10\n "
+" - x04 - column vector of length 10\n "
+" - x05 - column vector of length 10\n "
+" - x06 - column vector of length 10\n "
+" - x07 - column vector of length 10\n "
+" - x08 - column vector of length 10\n "
+" - x09 - column vector of length 10\n "
+" - x10 - column vector of length 10\n "
 
 	"\n For more information, see https://forces.embotech.com/Documentation/graphical_interface/index.html \n "
 
@@ -847,16 +837,6 @@
 "port_label('output', 8, 'x08') \n "
 "port_label('output', 9, 'x09') \n "
 "port_label('output', 10, 'x10') \n "
-"port_label('output', 11, 'x11') \n "
-"port_label('output', 12, 'x12') \n "
-"port_label('output', 13, 'x13') \n "
-"port_label('output', 14, 'x14') \n "
-"port_label('output', 15, 'x15') \n "
-"port_label('output', 16, 'x16') \n "
-"port_label('output', 17, 'x17') \n "
-"port_label('output', 18, 'x18') \n "
-"port_label('output', 19, 'x19') \n "
-"port_label('output', 20, 'x20') \n "
 "if( exist('FORCES_PRO_Logo.jpg','file') ), image(imread('FORCES_PRO_Logo.jpg'),'center','on'); elseif( exist(['interface',filesep,'FORCES_PRO_Logo.jpg'],'file') ), image(imread(['interface',filesep,'FORCES_PRO_Logo.jpg']),'center','on'); elseif( exist(['FORCENLPsolver',filesep,'interface',filesep,'FORCES_PRO_Logo.jpg'],'file') ), image(imread(['FORCENLPsolver',filesep,'interface',filesep,'FORCES_PRO_Logo.jpg']),'center','on'); end \n "
 
       }
Index: model/FORCENLPsolver/interface/FORCENLPsolver_mex.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nFORCENLPsolver : A fast customized optimization solver.\n\nCopyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n\n\nThis software is intended for simulation and testing purposes only. \nUse of this software for any commercial purpose is prohibited.\n\nThis program is distributed in the hope that it will be useful.\nEMBOTECH makes NO WARRANTIES with respect to the use of the software \nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. \n\nEMBOTECH shall not have any liability for any damage arising from the use\nof the software.\n\nThis Agreement shall exclusively be governed by and interpreted in \naccordance with the laws of Switzerland, excluding its principles\nof conflict of laws. The Courts of Zurich-City shall have exclusive \njurisdiction in case of any dispute.\n\n*/\n\n#include \"mex.h\"\n#include \"math.h\"\n#include \"../include/FORCENLPsolver.h\"\n#ifndef SOLVER_STDIO_H\n#define SOLVER_STDIO_H\n#include <stdio.h>\n#endif\n\n/* For compatibility with Microsoft Visual Studio 2015 */\n#if _MSC_VER >= 1900\nFILE _iob[3];\nFILE * __cdecl __iob_func(void)\n{\n\t_iob[0] = *stdin;\n\t_iob[1] = *stdout;\n\t_iob[2] = *stderr;\n\treturn _iob;\n}\n#endif\n\n/* copy functions */\n\nvoid copyCArrayToM_double(double *src, double *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (double)*src++;\n    }\n}\n\nvoid copyMArrayToC_double(double *src, double *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (double) (*src++) ;\n    }\n}\n\nvoid copyMValueToC_double(double * src, double * dest)\n{\n\t*dest = (double) *src;\n}\n\n/* copy functions */\n\nvoid copyCArrayToM_FORCENLPsolver_int(FORCENLPsolver_int *src, double *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (double)*src++;\n    }\n}\n\nvoid copyMArrayToC_FORCENLPsolver_int(double *src, FORCENLPsolver_int *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (FORCENLPsolver_int) (*src++) ;\n    }\n}\n\nvoid copyMValueToC_FORCENLPsolver_int(double * src, FORCENLPsolver_int * dest)\n{\n\t*dest = (FORCENLPsolver_int) *src;\n}\n\n\n\nextern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);\nFORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;\n\n\n/* Some memory for mex-function */\nstatic FORCENLPsolver_params params;\nstatic FORCENLPsolver_output output;\nstatic FORCENLPsolver_info info;\n\n/* THE mex-function */\nvoid mexFunction( solver_int32_default nlhs, mxArray *plhs[], solver_int32_default nrhs, const mxArray *prhs[] )  \n{\n\t/* file pointer for printing */\n\tFILE *fp = NULL;\n\n\t/* define variables */\t\n\tmxArray *par;\n\tmxArray *outvar;\n\tconst mxArray *PARAMS = prhs[0]; \n\tdouble *pvalue;\n\tsolver_int32_default i;\n\tsolver_int32_default exitflag;\n\tconst solver_int8_default *fname;\n\tconst solver_int8_default *outputnames[20] = {\"x01\",\"x02\",\"x03\",\"x04\",\"x05\",\"x06\",\"x07\",\"x08\",\"x09\",\"x10\",\"x11\",\"x12\",\"x13\",\"x14\",\"x15\",\"x16\",\"x17\",\"x18\",\"x19\",\"x20\"};\n\tconst solver_int8_default *infofields[7] = { \"it\", \"res_eq\", \"rsnorm\", \"pobj\", \"solvetime\",  \"fevalstime\", \"QPtime\"};\n\t\n\t/* Check for proper number of arguments */\n    if (nrhs != 1)\n\t{\n\t\tmexErrMsgTxt(\"This function requires exactly 1 input: PARAMS struct.\\nType 'help FORCENLPsolver_mex' for details.\");\n\t}    \n\tif (nlhs > 3) \n\t{\n        mexErrMsgTxt(\"This function returns at most 3 outputs.\\nType 'help FORCENLPsolver_mex' for details.\");\n    }\n\n\t/* Check whether params is actually a structure */\n\tif( !mxIsStruct(PARAMS) ) \n\t{\n\t\tmexErrMsgTxt(\"PARAMS must be a structure.\");\n\t}\n\t \n\n\t/* copy parameters into the right location */\n\tpar = mxGetField(PARAMS, 0, \"xinit\");\n#ifdef MEXARGMUENTCHECKS\n    if( par == NULL )\t\n\t{\n        mexErrMsgTxt(\"PARAMS.xinit not found\");\n    }\n    if( !mxIsDouble(par) )\n    {\n    mexErrMsgTxt(\"PARAMS.xinit must be a double.\");\n    }\n    if( mxGetM(par) != 3 || mxGetN(par) != 1 ) \n\t{\n    mexErrMsgTxt(\"PARAMS.xinit must be of size [3 x 1]\");\n    }\n#endif\t \n\tif ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )\n\t{\n\t\tcopyMArrayToC_double(mxGetPr(par), params.xinit,3);\n\n\t}\n\tpar = mxGetField(PARAMS, 0, \"x0\");\n#ifdef MEXARGMUENTCHECKS\n    if( par == NULL )\t\n\t{\n        mexErrMsgTxt(\"PARAMS.x0 not found\");\n    }\n    if( !mxIsDouble(par) )\n    {\n    mexErrMsgTxt(\"PARAMS.x0 must be a double.\");\n    }\n    if( mxGetM(par) != 100 || mxGetN(par) != 1 ) \n\t{\n    mexErrMsgTxt(\"PARAMS.x0 must be of size [100 x 1]\");\n    }\n#endif\t \n\tif ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )\n\t{\n\t\tcopyMArrayToC_double(mxGetPr(par), params.x0,100);\n\n\t}\n\tpar = mxGetField(PARAMS, 0, \"all_parameters\");\n#ifdef MEXARGMUENTCHECKS\n    if( par == NULL )\t\n\t{\n        mexErrMsgTxt(\"PARAMS.all_parameters not found\");\n    }\n    if( !mxIsDouble(par) )\n    {\n    mexErrMsgTxt(\"PARAMS.all_parameters must be a double.\");\n    }\n    if( mxGetM(par) != 60 || mxGetN(par) != 1 ) \n\t{\n    mexErrMsgTxt(\"PARAMS.all_parameters must be of size [60 x 1]\");\n    }\n#endif\t \n\tif ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )\n\t{\n\t\tcopyMArrayToC_double(mxGetPr(par), params.all_parameters,60);\n\n\t}\n\tpar = mxGetField(PARAMS, 0, \"reinitialize\");\n\tif ( (par != NULL) && (mxGetN(par) != 0) && (mxGetM(par) != 0) )\n\t{\n\t\tcopyMValueToC_FORCENLPsolver_int(mxGetPr(par), &params.reinitialize);\n\n\t}\n\n\n\n\n\t#if SET_PRINTLEVEL_FORCENLPsolver > 0\n\t\t/* Prepare file for printfs */\n        fp = fopen(\"stdout_temp\",\"w+\");\n\t\tif( fp == NULL ) \n\t\t{\n\t\t\tmexErrMsgTxt(\"freopen of stdout did not work.\");\n\t\t}\n\t\trewind(fp);\n\t#endif\n\n\t/* call solver */\n\texitflag = FORCENLPsolver_solve(&params, &output, &info, fp, pt2function_FORCENLPsolver);\n\t\n\t#if SET_PRINTLEVEL_FORCENLPsolver > 0\n\t\t/* Read contents of printfs printed to file */\n\t\trewind(fp);\n\t\twhile( (i = fgetc(fp)) != EOF ) \n\t\t{\n\t\t\tmexPrintf(\"%c\",i);\n\t\t}\n\t\tfclose(fp);\n\t#endif\n\n\t/* copy output to matlab arrays */\n\tplhs[0] = mxCreateStructMatrix(1, 1, 20, outputnames);\n\t\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x01, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x01\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x02, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x02\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x03, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x03\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x04, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x04\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x05, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x05\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x06, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x06\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x07, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x07\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x08, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x08\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x09, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x09\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x10, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x10\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x11, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x11\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x12, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x12\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x13, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x13\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x14, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x14\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x15, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x15\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x16, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x16\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x17, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x17\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x18, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x18\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x19, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x19\", outvar);\n\n\toutvar = mxCreateDoubleMatrix(5, 1, mxREAL);\n\tcopyCArrayToM_double( output.x20, mxGetPr(outvar), 5);\n\tmxSetField(plhs[0], 0, \"x20\", outvar);\n\n\n\n\t/* copy exitflag */\n\tif( nlhs > 1 )\n\t{\n\tplhs[1] = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t*mxGetPr(plhs[1]) = (double)exitflag;\n\t}\n\n\t/* copy info struct */\n\tif( nlhs > 2 )\n\t{\n\t        plhs[2] = mxCreateStructMatrix(1, 1, 7, infofields);\n        \n\t\t/* iterations */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = (double)info.it;\n\t\tmxSetField(plhs[2], 0, \"it\", outvar);\n\n\t\t/* res_eq */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = info.res_eq;\n\t\tmxSetField(plhs[2], 0, \"res_eq\", outvar);\n\n\t\t/* rsnorm */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = info.rsnorm;\n\t\tmxSetField(plhs[2], 0, \"rsnorm\", outvar);\n\n\t\t/* pobj */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = info.pobj;\n\t\tmxSetField(plhs[2], 0, \"pobj\", outvar);\n\n\t\t/* solver time */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = info.solvetime;\n\t\tmxSetField(plhs[2], 0, \"solvetime\", outvar);\n\n\t\t/* fevals time */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = info.fevalstime;\n\t\tmxSetField(plhs[2], 0, \"fevalstime\", outvar);\n\t\t\n\t\t/* QP time */\n\t\toutvar = mxCreateDoubleMatrix(1, 1, mxREAL);\n\t\t*mxGetPr(outvar) = info.QPtime;\n\t\tmxSetField(plhs[2], 0, \"QPtime\", outvar);\t\t\n\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c	(date 1646039467400)
@@ -30,17 +30,7 @@
 #include <stdio.h>
 #endif
 
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
+
 
 /* copy functions */
 
@@ -117,7 +107,7 @@
 	solver_int32_default i;
 	solver_int32_default exitflag;
 	const solver_int8_default *fname;
-	const solver_int8_default *outputnames[20] = {"x01","x02","x03","x04","x05","x06","x07","x08","x09","x10","x11","x12","x13","x14","x15","x16","x17","x18","x19","x20"};
+	const solver_int8_default *outputnames[10] = {"x01","x02","x03","x04","x05","x06","x07","x08","x09","x10"};
 	const solver_int8_default *infofields[7] = { "it", "res_eq", "rsnorm", "pobj", "solvetime",  "fevalstime", "QPtime"};
 	
 	/* Check for proper number of arguments */
@@ -148,14 +138,14 @@
     {
     mexErrMsgTxt("PARAMS.xinit must be a double.");
     }
-    if( mxGetM(par) != 3 || mxGetN(par) != 1 ) 
+    if( mxGetM(par) != 6 || mxGetN(par) != 1 ) 
 	{
-    mexErrMsgTxt("PARAMS.xinit must be of size [3 x 1]");
+    mexErrMsgTxt("PARAMS.xinit must be of size [6 x 1]");
     }
 #endif	 
 	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
 	{
-		copyMArrayToC_double(mxGetPr(par), params.xinit,3);
+		copyMArrayToC_double(mxGetPr(par), params.xinit,6);
 
 	}
 	par = mxGetField(PARAMS, 0, "x0");
@@ -232,87 +222,47 @@
 	#endif
 
 	/* copy output to matlab arrays */
-	plhs[0] = mxCreateStructMatrix(1, 1, 20, outputnames);
-		outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x01, mxGetPr(outvar), 5);
+	plhs[0] = mxCreateStructMatrix(1, 1, 10, outputnames);
+		outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x01, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x01", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x02, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x02, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x02", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x03, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x03, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x03", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x04, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x04, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x04", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x05, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x05, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x05", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x06, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x06, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x06", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x07, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x07, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x07", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x08, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x08, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x08", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x09, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x09, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x09", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x10, mxGetPr(outvar), 5);
+	outvar = mxCreateDoubleMatrix(10, 1, mxREAL);
+	copyCArrayToM_double( output.x10, mxGetPr(outvar), 10);
 	mxSetField(plhs[0], 0, "x10", outvar);
 
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x11, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x11", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x12, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x12", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x13, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x13", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x14, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x14", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x15, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x15", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x16, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x16", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x17, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x17", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x18, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x18", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x19, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x19", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x20, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x20", outvar);
-
 
 
 	/* copy exitflag */
Index: model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nFORCENLPsolver : A fast customized optimization solver.\n\nCopyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n\n\nThis software is intended for simulation and testing purposes only. \nUse of this software for any commercial purpose is prohibited.\n\nThis program is distributed in the hope that it will be useful.\nEMBOTECH makes NO WARRANTIES with respect to the use of the software \nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. \n\nEMBOTECH shall not have any liability for any damage arising from the use\nof the software.\n\nThis Agreement shall exclusively be governed by and interpreted in \naccordance with the laws of Switzerland, excluding its principles\nof conflict of laws. The Courts of Zurich-City shall have exclusive \njurisdiction in case of any dispute.\n\n*/\n\n\n#define S_FUNCTION_LEVEL 2\n#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlock\n\n#include \"simstruc.h\"\n\n/* For compatibility with Microsoft Visual Studio 2015 */\n#if _MSC_VER >= 1900\nFILE _iob[3];\nFILE * __cdecl __iob_func(void)\n{\n\t_iob[0] = *stdin;\n\t_iob[1] = *stdout;\n\t_iob[2] = *stderr;\n\treturn _iob;\n}\n#endif\n\n/* include FORCESPRO functions and defs */\n#include \"../include/FORCENLPsolver.h\" \n\n/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */\n\n\n#if defined(MATLAB_MEX_FILE)\n#include \"tmwtypes.h\"\n#include \"simstruc_types.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\ntypedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;\n\nextern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);\nFORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;\n\n\n\n\n/*====================*\n * S-function methods *\n *====================*/\n/* Function: mdlInitializeSizes =========================================\n * Abstract:\n *   Setup sizes of the various vectors.\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n\n    DECL_AND_INIT_DIMSINFO(inputDimsInfo);\n    DECL_AND_INIT_DIMSINFO(outputDimsInfo);\n    ssSetNumSFcnParams(S, 0);\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) \n\t{\n\t\treturn; /* Parameter mismatch will be reported by Simulink */\n    }\n\n\t/* initialize size of continuous and discrete states to zero */\n    ssSetNumContStates(S, 0);\n    ssSetNumDiscStates(S, 0);\n\n\t/* initialize input ports - there are 4 in total */\n    if (!ssSetNumInputPorts(S, 4)) return;\n    \t\n\t/* Input Port 0 */\n    ssSetInputPortMatrixDimensions(S,  0, 3, 1);\n    ssSetInputPortDataType(S, 0, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/\n\t\n\t/* Input Port 1 */\n    ssSetInputPortMatrixDimensions(S,  1, 100, 1);\n    ssSetInputPortDataType(S, 1, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/\n\t\n\t/* Input Port 2 */\n    ssSetInputPortMatrixDimensions(S,  2, 60, 1);\n    ssSetInputPortDataType(S, 2, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/\n\t\n\t/* Input Port 3 */\n    ssSetInputPortMatrixDimensions(S,  3, 1, 1);\n    ssSetInputPortDataType(S, 3, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/\n \n\n\n\t/* initialize output ports - there are 20 in total */\n    if (!ssSetNumOutputPorts(S, 20)) return;    \n\t\t\n\t/* Output Port 0 */\n    ssSetOutputPortMatrixDimensions(S,  0, 5, 1);\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 1 */\n    ssSetOutputPortMatrixDimensions(S,  1, 5, 1);\n    ssSetOutputPortDataType(S, 1, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 2 */\n    ssSetOutputPortMatrixDimensions(S,  2, 5, 1);\n    ssSetOutputPortDataType(S, 2, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 3 */\n    ssSetOutputPortMatrixDimensions(S,  3, 5, 1);\n    ssSetOutputPortDataType(S, 3, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 4 */\n    ssSetOutputPortMatrixDimensions(S,  4, 5, 1);\n    ssSetOutputPortDataType(S, 4, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 5 */\n    ssSetOutputPortMatrixDimensions(S,  5, 5, 1);\n    ssSetOutputPortDataType(S, 5, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 6 */\n    ssSetOutputPortMatrixDimensions(S,  6, 5, 1);\n    ssSetOutputPortDataType(S, 6, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 6, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 7 */\n    ssSetOutputPortMatrixDimensions(S,  7, 5, 1);\n    ssSetOutputPortDataType(S, 7, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 7, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 8 */\n    ssSetOutputPortMatrixDimensions(S,  8, 5, 1);\n    ssSetOutputPortDataType(S, 8, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 8, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 9 */\n    ssSetOutputPortMatrixDimensions(S,  9, 5, 1);\n    ssSetOutputPortDataType(S, 9, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 9, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 10 */\n    ssSetOutputPortMatrixDimensions(S,  10, 5, 1);\n    ssSetOutputPortDataType(S, 10, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 10, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 11 */\n    ssSetOutputPortMatrixDimensions(S,  11, 5, 1);\n    ssSetOutputPortDataType(S, 11, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 11, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 12 */\n    ssSetOutputPortMatrixDimensions(S,  12, 5, 1);\n    ssSetOutputPortDataType(S, 12, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 12, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 13 */\n    ssSetOutputPortMatrixDimensions(S,  13, 5, 1);\n    ssSetOutputPortDataType(S, 13, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 13, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 14 */\n    ssSetOutputPortMatrixDimensions(S,  14, 5, 1);\n    ssSetOutputPortDataType(S, 14, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 14, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 15 */\n    ssSetOutputPortMatrixDimensions(S,  15, 5, 1);\n    ssSetOutputPortDataType(S, 15, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 15, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 16 */\n    ssSetOutputPortMatrixDimensions(S,  16, 5, 1);\n    ssSetOutputPortDataType(S, 16, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 16, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 17 */\n    ssSetOutputPortMatrixDimensions(S,  17, 5, 1);\n    ssSetOutputPortDataType(S, 17, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 17, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 18 */\n    ssSetOutputPortMatrixDimensions(S,  18, 5, 1);\n    ssSetOutputPortDataType(S, 18, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 18, COMPLEX_NO); /* no complex signals suppported */\n\t\n\t/* Output Port 19 */\n    ssSetOutputPortMatrixDimensions(S,  19, 5, 1);\n    ssSetOutputPortDataType(S, 19, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 19, COMPLEX_NO); /* no complex signals suppported */\n\n\n\t/* set sampling time */\n    ssSetNumSampleTimes(S, 1);\n\n\t/* set internal memory of block */\n    ssSetNumRWork(S, 0);\n    ssSetNumIWork(S, 0);\n    ssSetNumPWork(S, 0);\n    ssSetNumModes(S, 0);\n    ssSetNumNonsampledZCs(S, 0);\n\n    /* Take care when specifying exception free code - see sfuntmpl_doc.c */\n\t/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ \n\t/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ \n    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |\n\t\t             SS_OPTION_WORKS_WITH_CODE_REUSE)); */\n\tssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );\n\n\t\n}\n\n#if defined(MATLAB_MEX_FILE)\n#define MDL_SET_INPUT_PORT_DIMENSION_INFO\nstatic void mdlSetInputPortDimensionInfo(SimStruct        *S, \n                                         int_T            port,\n                                         const DimsInfo_T *dimsInfo)\n{\n    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;\n}\n#endif\n\n#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO\n#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)\nstatic void mdlSetOutputPortDimensionInfo(SimStruct        *S, \n                                          int_T            port, \n                                          const DimsInfo_T *dimsInfo)\n{\n    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;\n}\n#endif\n# define MDL_SET_INPUT_PORT_FRAME_DATA\nstatic void mdlSetInputPortFrameData(SimStruct  *S, \n                                     int_T      port,\n                                     Frame_T    frameData)\n{\n    ssSetInputPortFrameData(S, port, frameData);\n}\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    Specifiy  the sample time.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n}\n\n#define MDL_SET_INPUT_PORT_DATA_TYPE\nstatic void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)\n{\n    ssSetInputPortDataType( S, 0, dType);\n}\n#define MDL_SET_OUTPUT_PORT_DATA_TYPE\nstatic void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)\n{\n    ssSetOutputPortDataType(S, 0, dType);\n}\n\n#define MDL_SET_DEFAULT_PORT_DATA_TYPES\nstatic void mdlSetDefaultPortDataTypes(SimStruct *S)\n{\n    ssSetInputPortDataType( S, 0, SS_DOUBLE);\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\n}\n\n\n\n\n\n/* Function: mdlOutputs =======================================================\n *\n*/\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n\tsolver_int32_default i, j, k;\n\t\n\t/* file pointer for printing */\n\tFILE *fp = NULL;\n\n\t/* Simulink data */\n\tconst real_T *xinit = (const real_T*) ssGetInputPortSignal(S,0);\n\tconst real_T *x0 = (const real_T*) ssGetInputPortSignal(S,1);\n\tconst real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,2);\n\tconst FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,3);\n\t\n    real_T *x01 = (real_T*) ssGetOutputPortSignal(S,0);\n\treal_T *x02 = (real_T*) ssGetOutputPortSignal(S,1);\n\treal_T *x03 = (real_T*) ssGetOutputPortSignal(S,2);\n\treal_T *x04 = (real_T*) ssGetOutputPortSignal(S,3);\n\treal_T *x05 = (real_T*) ssGetOutputPortSignal(S,4);\n\treal_T *x06 = (real_T*) ssGetOutputPortSignal(S,5);\n\treal_T *x07 = (real_T*) ssGetOutputPortSignal(S,6);\n\treal_T *x08 = (real_T*) ssGetOutputPortSignal(S,7);\n\treal_T *x09 = (real_T*) ssGetOutputPortSignal(S,8);\n\treal_T *x10 = (real_T*) ssGetOutputPortSignal(S,9);\n\treal_T *x11 = (real_T*) ssGetOutputPortSignal(S,10);\n\treal_T *x12 = (real_T*) ssGetOutputPortSignal(S,11);\n\treal_T *x13 = (real_T*) ssGetOutputPortSignal(S,12);\n\treal_T *x14 = (real_T*) ssGetOutputPortSignal(S,13);\n\treal_T *x15 = (real_T*) ssGetOutputPortSignal(S,14);\n\treal_T *x16 = (real_T*) ssGetOutputPortSignal(S,15);\n\treal_T *x17 = (real_T*) ssGetOutputPortSignal(S,16);\n\treal_T *x18 = (real_T*) ssGetOutputPortSignal(S,17);\n\treal_T *x19 = (real_T*) ssGetOutputPortSignal(S,18);\n\treal_T *x20 = (real_T*) ssGetOutputPortSignal(S,19);\n\t\n\t\n\n\t/* Solver data */\n\tstatic FORCENLPsolver_params params;\n\tstatic FORCENLPsolver_output output;\n\tstatic FORCENLPsolver_info info;\t\n\tsolver_int32_default exitflag;\n\n\t/* Extra NMPC data */\n\t\n\n\t/* Copy inputs */\n\tfor( i=0; i<3; i++)\n\t{ \n\t\tparams.xinit[i] = (double) xinit[i]; \n\t}\n\n\tfor( i=0; i<100; i++)\n\t{ \n\t\tparams.x0[i] = (double) x0[i]; \n\t}\n\n\tfor( i=0; i<60; i++)\n\t{ \n\t\tparams.all_parameters[i] = (double) all_parameters[i]; \n\t}\n\n\tparams.reinitialize = *reinitialize;\n\n\t\n\n\t\n\n    #if SET_PRINTLEVEL_FORCENLPsolver > 0\n\t\t/* Prepare file for printfs */\n        fp = fopen(\"stdout_temp\",\"w+\");\n\t\tif( fp == NULL ) \n\t\t{\n\t\t\tmexErrMsgTxt(\"freopen of stdout did not work.\");\n\t\t}\n\t\trewind(fp);\n\t#endif\n\n\t/* Call solver */\n\texitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);\n\n\t#if SET_PRINTLEVEL_FORCENLPsolver > 0\n\t\t/* Read contents of printfs printed to file */\n\t\trewind(fp);\n\t\twhile( (i = fgetc(fp)) != EOF ) \n\t\t{\n\t\t\tssPrintf(\"%c\",i);\n\t\t}\n\t\tfclose(fp);\n\t#endif\n\n\t\n\n\t/* Copy outputs */\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx01[i] = (real_T) output.x01[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx02[i] = (real_T) output.x02[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx03[i] = (real_T) output.x03[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx04[i] = (real_T) output.x04[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx05[i] = (real_T) output.x05[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx06[i] = (real_T) output.x06[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx07[i] = (real_T) output.x07[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx08[i] = (real_T) output.x08[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx09[i] = (real_T) output.x09[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx10[i] = (real_T) output.x10[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx11[i] = (real_T) output.x11[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx12[i] = (real_T) output.x12[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx13[i] = (real_T) output.x13[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx14[i] = (real_T) output.x14[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx15[i] = (real_T) output.x15[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx16[i] = (real_T) output.x16[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx17[i] = (real_T) output.x17[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx18[i] = (real_T) output.x18[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx19[i] = (real_T) output.x19[i]; \n\t}\n\n\tfor( i=0; i<5; i++)\n\t{ \n\t\tx20[i] = (real_T) output.x20[i]; \n\t}\n\n\t\n}\n\n\n\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    In this function, you should perform any actions that are necessary\n *    at the termination of a simulation.  For example, if memory was\n *    allocated in mdlStart, this is the place to free it.\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c	(date 1646039467400)
@@ -28,17 +28,7 @@
 
 #include "simstruc.h"
 
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
+
 
 /* include FORCESPRO functions and defs */
 #include "../include/FORCENLPsolver.h" 
@@ -87,7 +77,7 @@
     if (!ssSetNumInputPorts(S, 4)) return;
     	
 	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 3, 1);
+    ssSetInputPortMatrixDimensions(S,  0, 6, 1);
     ssSetInputPortDataType(S, 0, SS_DOUBLE);
     ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
     ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
@@ -116,108 +106,58 @@
  
 
 
-	/* initialize output ports - there are 20 in total */
-    if (!ssSetNumOutputPorts(S, 20)) return;    
+	/* initialize output ports - there are 10 in total */
+    if (!ssSetNumOutputPorts(S, 10)) return;    
 		
 	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  0, 10, 1);
     ssSetOutputPortDataType(S, 0, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 1 */
-    ssSetOutputPortMatrixDimensions(S,  1, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  1, 10, 1);
     ssSetOutputPortDataType(S, 1, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 2 */
-    ssSetOutputPortMatrixDimensions(S,  2, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  2, 10, 1);
     ssSetOutputPortDataType(S, 2, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 3 */
-    ssSetOutputPortMatrixDimensions(S,  3, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  3, 10, 1);
     ssSetOutputPortDataType(S, 3, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 4 */
-    ssSetOutputPortMatrixDimensions(S,  4, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  4, 10, 1);
     ssSetOutputPortDataType(S, 4, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 5 */
-    ssSetOutputPortMatrixDimensions(S,  5, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  5, 10, 1);
     ssSetOutputPortDataType(S, 5, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 6 */
-    ssSetOutputPortMatrixDimensions(S,  6, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  6, 10, 1);
     ssSetOutputPortDataType(S, 6, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 6, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 7 */
-    ssSetOutputPortMatrixDimensions(S,  7, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  7, 10, 1);
     ssSetOutputPortDataType(S, 7, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 7, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 8 */
-    ssSetOutputPortMatrixDimensions(S,  8, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  8, 10, 1);
     ssSetOutputPortDataType(S, 8, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 8, COMPLEX_NO); /* no complex signals suppported */
 	
 	/* Output Port 9 */
-    ssSetOutputPortMatrixDimensions(S,  9, 5, 1);
+    ssSetOutputPortMatrixDimensions(S,  9, 10, 1);
     ssSetOutputPortDataType(S, 9, SS_DOUBLE);
     ssSetOutputPortComplexSignal(S, 9, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 10 */
-    ssSetOutputPortMatrixDimensions(S,  10, 5, 1);
-    ssSetOutputPortDataType(S, 10, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 10, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 11 */
-    ssSetOutputPortMatrixDimensions(S,  11, 5, 1);
-    ssSetOutputPortDataType(S, 11, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 11, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 12 */
-    ssSetOutputPortMatrixDimensions(S,  12, 5, 1);
-    ssSetOutputPortDataType(S, 12, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 12, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 13 */
-    ssSetOutputPortMatrixDimensions(S,  13, 5, 1);
-    ssSetOutputPortDataType(S, 13, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 13, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 14 */
-    ssSetOutputPortMatrixDimensions(S,  14, 5, 1);
-    ssSetOutputPortDataType(S, 14, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 14, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 15 */
-    ssSetOutputPortMatrixDimensions(S,  15, 5, 1);
-    ssSetOutputPortDataType(S, 15, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 15, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 16 */
-    ssSetOutputPortMatrixDimensions(S,  16, 5, 1);
-    ssSetOutputPortDataType(S, 16, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 16, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 17 */
-    ssSetOutputPortMatrixDimensions(S,  17, 5, 1);
-    ssSetOutputPortDataType(S, 17, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 17, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 18 */
-    ssSetOutputPortMatrixDimensions(S,  18, 5, 1);
-    ssSetOutputPortDataType(S, 18, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 18, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 19 */
-    ssSetOutputPortMatrixDimensions(S,  19, 5, 1);
-    ssSetOutputPortDataType(S, 19, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 19, COMPLEX_NO); /* no complex signals suppported */
 
 
 	/* set sampling time */
@@ -324,16 +264,6 @@
 	real_T *x08 = (real_T*) ssGetOutputPortSignal(S,7);
 	real_T *x09 = (real_T*) ssGetOutputPortSignal(S,8);
 	real_T *x10 = (real_T*) ssGetOutputPortSignal(S,9);
-	real_T *x11 = (real_T*) ssGetOutputPortSignal(S,10);
-	real_T *x12 = (real_T*) ssGetOutputPortSignal(S,11);
-	real_T *x13 = (real_T*) ssGetOutputPortSignal(S,12);
-	real_T *x14 = (real_T*) ssGetOutputPortSignal(S,13);
-	real_T *x15 = (real_T*) ssGetOutputPortSignal(S,14);
-	real_T *x16 = (real_T*) ssGetOutputPortSignal(S,15);
-	real_T *x17 = (real_T*) ssGetOutputPortSignal(S,16);
-	real_T *x18 = (real_T*) ssGetOutputPortSignal(S,17);
-	real_T *x19 = (real_T*) ssGetOutputPortSignal(S,18);
-	real_T *x20 = (real_T*) ssGetOutputPortSignal(S,19);
 	
 	
 
@@ -347,7 +277,7 @@
 	
 
 	/* Copy inputs */
-	for( i=0; i<3; i++)
+	for( i=0; i<6; i++)
 	{ 
 		params.xinit[i] = (double) xinit[i]; 
 	}
@@ -394,106 +324,56 @@
 	
 
 	/* Copy outputs */
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x01[i] = (real_T) output.x01[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x02[i] = (real_T) output.x02[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x03[i] = (real_T) output.x03[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x04[i] = (real_T) output.x04[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x05[i] = (real_T) output.x05[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x06[i] = (real_T) output.x06[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x07[i] = (real_T) output.x07[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x08[i] = (real_T) output.x08[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x09[i] = (real_T) output.x09[i]; 
 	}
 
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		x10[i] = (real_T) output.x10[i]; 
 	}
 
-	for( i=0; i<5; i++)
-	{ 
-		x11[i] = (real_T) output.x11[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x12[i] = (real_T) output.x12[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x13[i] = (real_T) output.x13[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x14[i] = (real_T) output.x14[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x15[i] = (real_T) output.x15[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x16[i] = (real_T) output.x16[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x17[i] = (real_T) output.x17[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x18[i] = (real_T) output.x18[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x19[i] = (real_T) output.x19[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x20[i] = (real_T) output.x20[i]; 
-	}
-
 	
 }
 
Index: model/FORCENLPsolver/interface/FORCENLPsolvercompact_lib.mdl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Model {\n  Name\t\t\t  \"FORCENLPsolver\"\n  Version\t\t  8.0\n  MdlSubVersion\t\t  0\n  GraphicalInterface {\n    NumRootInports\t    0\n    NumRootOutports\t    0\n    ParameterArgumentNames  \"\"\n    ComputedModelVersion    \"1.2\"\n    NumModelReferences\t    0\n    NumTestPointedSignals   0\n  }\n  SavedCharacterEncoding  \"windows-1252\"\n  SaveDefaultBlockParams  on\n  ScopeRefreshTime\t  0.035000\n  OverrideScopeRefreshTime on\n  DisableAllScopes\t  off\n  DataTypeOverride\t  \"UseLocalSettings\"\n  DataTypeOverrideAppliesTo \"AllNumericTypes\"\n  MinMaxOverflowLogging\t  \"UseLocalSettings\"\n  MinMaxOverflowArchiveMode \"Overwrite\"\n  FPTRunName\t\t  \"Run 1\"\n  MaxMDLFileLineLength\t  120\n  Object {\n    $PropName\t\t    \"BdWindowsInfo\"\n    $ObjectID\t\t    1\n    $ClassName\t\t    \"Simulink.BDWindowsInfo\"\n    Object {\n      $PropName\t\t      \"WindowsInfo\"\n      $ObjectID\t\t      2\n      $ClassName\t      \"Simulink.WindowInfo\"\n      IsActive\t\t      [1]\n      Location\t\t      [385.0, 84.0, 816.0, 539.0]\n      Object {\n\t$PropName\t\t\"ModelBrowserInfo\"\n\t$ObjectID\t\t3\n\t$ClassName\t\t\"Simulink.ModelBrowserInfo\"\n\tVisible\t\t\t[1]\n\tDockPosition\t\t\"Left\"\n\tWidth\t\t\t[50]\n\tHeight\t\t\t[50]\n\tFilter\t\t\t[9]\n      }\n      Object {\n\t$PropName\t\t\"ExplorerBarInfo\"\n\t$ObjectID\t\t4\n\t$ClassName\t\t\"Simulink.ExplorerBarInfo\"\n\tVisible\t\t\t[1]\n      }\n      Object {\n\t$PropName\t\t\"EditorsInfo\"\n\t$ObjectID\t\t5\n\t$ClassName\t\t\"Simulink.EditorInfo\"\n\tIsActive\t\t[1]\n\tViewObjType\t\t\"SimulinkTopLevel\"\n\tLoadSaveID\t\t\"0\"\n\tExtents\t\t\t[569.0, 363.0]\n\tZoomFactor\t\t[1.0]\n\tOffset\t\t\t[0.0, 0.0]\n      }\n    }\n  }\n  Created\t\t  \"2/27/2022 3:20:15 PM\"\n  Creator\t\t  \"embotech AG\"\n  UpdateHistory\t\t  \"UpdateHistoryNever\"\n  ModifiedByFormat\t  \"%<Auto>\"\n  LastModifiedBy\t  \"embotech AG\"\n  ModifiedDateFormat\t  \"%<Auto>\"\n  LastModifiedDate\t  \"2/27/2022 3:20:15 PM\"\n  RTWModifiedTimeStamp\t  315310195\n  ModelVersionFormat\t  \"1.%<AutoIncrement:2>\"\n  ConfigurationManager\t  \"None\"\n  SampleTimeColors\t  off\n  SampleTimeAnnotations\t  off\n  LibraryLinkDisplay\t  \"disabled\"\n  WideLines\t\t  off\n  ShowLineDimensions\t  off\n  ShowPortDataTypes\t  off\n  ShowDesignRanges\t  off\n  ShowLoopsOnError\t  on\n  IgnoreBidirectionalLines off\n  ShowStorageClass\t  off\n  ShowTestPointIcons\t  on\n  ShowSignalResolutionIcons on\n  ShowViewerIcons\t  on\n  SortedOrder\t\t  off\n  ExecutionContextIcon\t  off\n  ShowLinearizationAnnotations on\n  BlockNameDataTip\t  off\n  BlockParametersDataTip  off\n  BlockDescriptionStringDataTip\toff\n  ToolBar\t\t  on\n  StatusBar\t\t  on\n  BrowserShowLibraryLinks off\n  BrowserLookUnderMasks\t  off\n  SimulationMode\t  \"normal\"\n  LinearizationMsg\t  \"none\"\n  Profile\t\t  off\n  ParamWorkspaceSource\t  \"MATLABWorkspace\"\n  AccelSystemTargetFile\t  \"accel.tlc\"\n  AccelTemplateMakefile\t  \"accel_default_tmf\"\n  AccelMakeCommand\t  \"make_rtw\"\n  TryForcingSFcnDF\t  off\n  Object {\n    $PropName\t\t    \"DataLoggingOverride\"\n    $ObjectID\t\t    6\n    $ClassName\t\t    \"Simulink.SimulationData.ModelLoggingInfo\"\n    model_\t\t    \"model_2012b\"\n    overrideMode_\t    [0.0]\n    Array {\n      Type\t\t      \"Cell\"\n      Dimension\t\t      1\n      Cell\t\t      \"model_2012b\"\n      PropName\t\t      \"logAsSpecifiedByModels_\"\n    }\n    Array {\n      Type\t\t      \"Cell\"\n      Dimension\t\t      1\n      Cell\t\t      []\n      PropName\t\t      \"logAsSpecifiedByModelsSSIDs_\"\n    }\n  }\n  RecordCoverage\t  off\n  CovPath\t\t  \"/\"\n  CovSaveName\t\t  \"covdata\"\n  CovMetricSettings\t  \"dw\"\n  CovNameIncrementing\t  off\n  CovHtmlReporting\t  on\n  CovForceBlockReductionOff on\n  covSaveCumulativeToWorkspaceVar on\n  CovSaveSingleToWorkspaceVar on\n  CovCumulativeVarName\t  \"covCumulativeData\"\n  CovCumulativeReport\t  off\n  CovReportOnPause\t  on\n  CovModelRefEnable\t  \"Off\"\n  CovExternalEMLEnable\t  off\n  ExtModeBatchMode\t  off\n  ExtModeEnableFloating\t  on\n  ExtModeTrigType\t  \"manual\"\n  ExtModeTrigMode\t  \"normal\"\n  ExtModeTrigPort\t  \"1\"\n  ExtModeTrigElement\t  \"any\"\n  ExtModeTrigDuration\t  1000\n  ExtModeTrigDurationFloating \"auto\"\n  ExtModeTrigHoldOff\t  0\n  ExtModeTrigDelay\t  0\n  ExtModeTrigDirection\t  \"rising\"\n  ExtModeTrigLevel\t  0\n  ExtModeArchiveMode\t  \"off\"\n  ExtModeAutoIncOneShot\t  off\n  ExtModeIncDirWhenArm\t  off\n  ExtModeAddSuffixToVar\t  off\n  ExtModeWriteAllDataToWs off\n  ExtModeArmWhenConnect\t  on\n  ExtModeSkipDownloadWhenConnect off\n  ExtModeLogAll\t\t  on\n  ExtModeAutoUpdateStatusClock on\n  BufferReuse\t\t  on\n  ShowModelReferenceBlockVersion off\n  ShowModelReferenceBlockIO off\n  Array {\n    Type\t\t    \"Handle\"\n    Dimension\t\t    1\n    Simulink.ConfigSet {\n      $ObjectID\t\t      7\n      Version\t\t      \"1.12.1\"\n      Array {\n\tType\t\t\t\"Handle\"\n\tDimension\t\t8\n\tSimulink.SolverCC {\n\t  $ObjectID\t\t  8\n\t  Version\t\t  \"1.12.1\"\n\t  StartTime\t\t  \"0.0\"\n\t  StopTime\t\t  \"10.0\"\n\t  AbsTol\t\t  \"auto\"\n\t  FixedStep\t\t  \"auto\"\n\t  InitialStep\t\t  \"auto\"\n\t  MaxNumMinSteps\t  \"-1\"\n\t  MaxOrder\t\t  5\n\t  ZcThreshold\t\t  \"auto\"\n\t  ConsecutiveZCsStepRelTol \"10*128*eps\"\n\t  MaxConsecutiveZCs\t  \"1000\"\n\t  ExtrapolationOrder\t  4\n\t  NumberNewtonIterations  1\n\t  MaxStep\t\t  \"auto\"\n\t  MinStep\t\t  \"auto\"\n\t  MaxConsecutiveMinStep\t  \"1\"\n\t  RelTol\t\t  \"1e-3\"\n\t  SolverMode\t\t  \"Auto\"\n\t  EnableConcurrentExecution off\n\t  ConcurrentTasks\t  off\n\t  Solver\t\t  \"ode45\"\n\t  SolverName\t\t  \"ode45\"\n\t  SolverJacobianMethodControl \"auto\"\n\t  ShapePreserveControl\t  \"DisableAll\"\n\t  ZeroCrossControl\t  \"UseLocalSettings\"\n\t  ZeroCrossAlgorithm\t  \"Nonadaptive\"\n\t  AlgebraicLoopSolver\t  \"TrustRegion\"\n\t  SolverResetMethod\t  \"Fast\"\n\t  PositivePriorityOrder\t  off\n\t  AutoInsertRateTranBlk\t  off\n\t  SampleTimeConstraint\t  \"Unconstrained\"\n\t  InsertRTBMode\t\t  \"Whenever possible\"\n\t}\n\tSimulink.DataIOCC {\n\t  $ObjectID\t\t  9\n\t  Version\t\t  \"1.12.1\"\n\t  Decimation\t\t  \"1\"\n\t  ExternalInput\t\t  \"[t, u]\"\n\t  FinalStateName\t  \"xFinal\"\n\t  InitialState\t\t  \"xInitial\"\n\t  LimitDataPoints\t  on\n\t  MaxDataPoints\t\t  \"1000\"\n\t  LoadExternalInput\t  off\n\t  LoadInitialState\t  off\n\t  SaveFinalState\t  off\n\t  SaveCompleteFinalSimState off\n\t  SaveFormat\t\t  \"Array\"\n\t  SignalLoggingSaveFormat \"Dataset\"\n\t  SaveOutput\t\t  on\n\t  SaveState\t\t  off\n\t  SignalLogging\t\t  on\n\t  DSMLogging\t\t  on\n\t  InspectSignalLogs\t  off\n\t  SaveTime\t\t  on\n\t  ReturnWorkspaceOutputs  off\n\t  StateSaveName\t\t  \"xout\"\n\t  TimeSaveName\t\t  \"tout\"\n\t  OutputSaveName\t  \"yout\"\n\t  SignalLoggingName\t  \"logsout\"\n\t  DSMLoggingName\t  \"dsmout\"\n\t  OutputOption\t\t  \"RefineOutputTimes\"\n\t  OutputTimes\t\t  \"[]\"\n\t  ReturnWorkspaceOutputsName \"out\"\n\t  Refine\t\t  \"1\"\n\t}\n\tSimulink.OptimizationCC {\n\t  $ObjectID\t\t  10\n\t  Version\t\t  \"1.12.1\"\n\t  Array {\n\t    Type\t\t    \"Cell\"\n\t    Dimension\t\t    8\n\t    Cell\t\t    \"BooleansAsBitfields\"\n\t    Cell\t\t    \"PassReuseOutputArgsAs\"\n\t    Cell\t\t    \"PassReuseOutputArgsThreshold\"\n\t    Cell\t\t    \"ZeroExternalMemoryAtStartup\"\n\t    Cell\t\t    \"ZeroInternalMemoryAtStartup\"\n\t    Cell\t\t    \"OptimizeModelRefInitCode\"\n\t    Cell\t\t    \"NoFixptDivByZeroProtection\"\n\t    Cell\t\t    \"UseSpecifiedMinMax\"\n\t    PropName\t\t    \"DisabledProps\"\n\t  }\n\t  BlockReduction\t  on\n\t  BooleanDataType\t  on\n\t  ConditionallyExecuteInputs on\n\t  InlineParams\t\t  off\n\t  UseIntDivNetSlope\t  off\n\t  UseFloatMulNetSlope\t  off\n\t  UseSpecifiedMinMax\t  off\n\t  InlineInvariantSignals  off\n\t  OptimizeBlockIOStorage  on\n\t  BufferReuse\t\t  on\n\t  EnhancedBackFolding\t  off\n\t  StrengthReduction\t  off\n\t  ExpressionFolding\t  on\n\t  BooleansAsBitfields\t  off\n\t  BitfieldContainerType\t  \"uint_T\"\n\t  EnableMemcpy\t\t  on\n\t  MemcpyThreshold\t  64\n\t  PassReuseOutputArgsAs\t  \"Structure reference\"\n\t  ExpressionDepthLimit\t  2147483647\n\t  FoldNonRolledExpr\t  on\n\t  LocalBlockOutputs\t  on\n\t  RollThreshold\t\t  5\n\t  SystemCodeInlineAuto\t  off\n\t  StateBitsets\t\t  off\n\t  DataBitsets\t\t  off\n\t  UseTempVars\t\t  off\n\t  ZeroExternalMemoryAtStartup on\n\t  ZeroInternalMemoryAtStartup on\n\t  InitFltsAndDblsToZero\t  off\n\t  NoFixptDivByZeroProtection off\n\t  EfficientFloat2IntCast  off\n\t  EfficientMapNaN2IntZero on\n\t  OptimizeModelRefInitCode off\n\t  LifeSpan\t\t  \"inf\"\n\t  MaxStackSize\t\t  \"Inherit from target\"\n\t  BufferReusableBoundary  on\n\t  SimCompilerOptimization \"Off\"\n\t  AccelVerboseBuild\t  off\n\t  ParallelExecutionInRapidAccelerator on\n\t}\n\tSimulink.DebuggingCC {\n\t  $ObjectID\t\t  11\n\t  Version\t\t  \"1.12.1\"\n\t  RTPrefix\t\t  \"error\"\n\t  ConsistencyChecking\t  \"none\"\n\t  ArrayBoundsChecking\t  \"none\"\n\t  SignalInfNanChecking\t  \"none\"\n\t  SignalRangeChecking\t  \"none\"\n\t  ReadBeforeWriteMsg\t  \"UseLocalSettings\"\n\t  WriteAfterWriteMsg\t  \"UseLocalSettings\"\n\t  WriteAfterReadMsg\t  \"UseLocalSettings\"\n\t  AlgebraicLoopMsg\t  \"warning\"\n\t  ArtificialAlgebraicLoopMsg \"warning\"\n\t  SaveWithDisabledLinksMsg \"warning\"\n\t  SaveWithParameterizedLinksMsg\t\"warning\"\n\t  CheckSSInitialOutputMsg on\n\t  UnderspecifiedInitializationDetection\t\"Classic\"\n\t  MergeDetectMultiDrivingBlocksExec \"none\"\n\t  CheckExecutionContextPreStartOutputMsg off\n\t  CheckExecutionContextRuntimeOutputMsg\toff\n\t  SignalResolutionControl \"UseLocalSettings\"\n\t  BlockPriorityViolationMsg \"warning\"\n\t  MinStepSizeMsg\t  \"warning\"\n\t  TimeAdjustmentMsg\t  \"none\"\n\t  MaxConsecutiveZCsMsg\t  \"error\"\n\t  MaskedZcDiagnostic\t  \"warning\"\n\t  IgnoredZcDiagnostic\t  \"warning\"\n\t  SolverPrmCheckMsg\t  \"warning\"\n\t  InheritedTsInSrcMsg\t  \"warning\"\n\t  DiscreteInheritContinuousMsg \"warning\"\n\t  MultiTaskDSMMsg\t  \"error\"\n\t  MultiTaskCondExecSysMsg \"error\"\n\t  MultiTaskRateTransMsg\t  \"error\"\n\t  SingleTaskRateTransMsg  \"none\"\n\t  TasksWithSamePriorityMsg \"warning\"\n\t  SigSpecEnsureSampleTimeMsg \"warning\"\n\t  CheckMatrixSingularityMsg \"none\"\n\t  IntegerOverflowMsg\t  \"warning\"\n\t  Int32ToFloatConvMsg\t  \"warning\"\n\t  ParameterDowncastMsg\t  \"error\"\n\t  ParameterOverflowMsg\t  \"error\"\n\t  ParameterUnderflowMsg\t  \"none\"\n\t  ParameterPrecisionLossMsg \"warning\"\n\t  ParameterTunabilityLossMsg \"warning\"\n\t  FixptConstUnderflowMsg  \"none\"\n\t  FixptConstOverflowMsg\t  \"none\"\n\t  FixptConstPrecisionLossMsg \"none\"\n\t  UnderSpecifiedDataTypeMsg \"none\"\n\t  UnnecessaryDatatypeConvMsg \"none\"\n\t  VectorMatrixConversionMsg \"none\"\n\t  InvalidFcnCallConnMsg\t  \"error\"\n\t  FcnCallInpInsideContextMsg \"EnableAllAsError\"\n\t  SignalLabelMismatchMsg  \"none\"\n\t  UnconnectedInputMsg\t  \"warning\"\n\t  UnconnectedOutputMsg\t  \"warning\"\n\t  UnconnectedLineMsg\t  \"warning\"\n\t  SFcnCompatibilityMsg\t  \"none\"\n\t  FrameProcessingCompatibilityMsg \"warning\"\n\t  UniqueDataStoreMsg\t  \"none\"\n\t  BusObjectLabelMismatch  \"warning\"\n\t  RootOutportRequireBusObject \"warning\"\n\t  AssertControl\t\t  \"UseLocalSettings\"\n\t  EnableOverflowDetection off\n\t  ModelReferenceIOMsg\t  \"none\"\n\t  ModelReferenceMultiInstanceNormalModeStructChecksumCheck \"error\"\n\t  ModelReferenceVersionMismatchMessage \"none\"\n\t  ModelReferenceIOMismatchMessage \"none\"\n\t  ModelReferenceCSMismatchMessage \"none\"\n\t  UnknownTsInhSupMsg\t  \"warning\"\n\t  ModelReferenceDataLoggingMessage \"warning\"\n\t  ModelReferenceSymbolNameMessage \"warning\"\n\t  ModelReferenceExtraNoncontSigs \"error\"\n\t  StateNameClashWarn\t  \"warning\"\n\t  SimStateInterfaceChecksumMismatchMsg \"warning\"\n\t  SimStateOlderReleaseMsg \"error\"\n\t  InitInArrayFormatMsg\t  \"warning\"\n\t  StrictBusMsg\t\t  \"ErrorLevel1\"\n\t  BusNameAdapt\t\t  \"WarnAndRepair\"\n\t  NonBusSignalsTreatedAsBus \"none\"\n\t  LoggingUnavailableSignals \"error\"\n\t  BlockIODiagnostic\t  \"none\"\n\t  SFUnusedDataAndEventsDiag \"warning\"\n\t  SFUnexpectedBacktrackingDiag \"warning\"\n\t  SFInvalidInputDataAccessInChartInitDiag \"warning\"\n\t  SFNoUnconditionalDefaultTransitionDiag \"warning\"\n\t  SFTransitionOutsideNaturalParentDiag \"warning\"\n\t  SFUnconditionalTransitionShadowingDiag \"warning\"\n\t  SFUndirectedBroadcastEventsDiag \"warning\"\n\t  SFTransitionActionBeforeConditionDiag\t\"warning\"\n\t}\n\tSimulink.HardwareCC {\n\t  $ObjectID\t\t  12\n\t  Version\t\t  \"1.12.1\"\n\t  ProdBitPerChar\t  8\n\t  ProdBitPerShort\t  16\n\t  ProdBitPerInt\t\t  32\n\t  ProdBitPerLong\t  32\n\t  ProdBitPerFloat\t  32\n\t  ProdBitPerDouble\t  64\n\t  ProdBitPerPointer\t  32\n\t  ProdLargestAtomicInteger \"Char\"\n\t  ProdLargestAtomicFloat  \"None\"\n\t  ProdIntDivRoundTo\t  \"Undefined\"\n\t  ProdEndianess\t\t  \"Unspecified\"\n\t  ProdWordSize\t\t  32\n\t  ProdShiftRightIntArith  on\n\t  ProdHWDeviceType\t  \"32-bit Generic\"\n\t  TargetBitPerChar\t  8\n\t  TargetBitPerShort\t  16\n\t  TargetBitPerInt\t  32\n\t  TargetBitPerLong\t  32\n\t  TargetBitPerFloat\t  32\n\t  TargetBitPerDouble\t  64\n\t  TargetBitPerPointer\t  32\n\t  TargetLargestAtomicInteger \"Char\"\n\t  TargetLargestAtomicFloat \"None\"\n\t  TargetShiftRightIntArith on\n\t  TargetIntDivRoundTo\t  \"Undefined\"\n\t  TargetEndianess\t  \"Unspecified\"\n\t  TargetWordSize\t  32\n\t  TargetTypeEmulationWarnSuppressLevel 0\n\t  TargetPreprocMaxBitsSint 32\n\t  TargetPreprocMaxBitsUint 32\n\t  TargetHWDeviceType\t  \"Specified\"\n\t  TargetUnknown\t\t  off\n\t  ProdEqTarget\t\t  on\n\t}\n\tSimulink.ModelReferenceCC {\n\t  $ObjectID\t\t  13\n\t  Version\t\t  \"1.12.1\"\n\t  UpdateModelReferenceTargets \"IfOutOfDateOrStructuralChange\"\n\t  CheckModelReferenceTargetMessage \"error\"\n\t  EnableParallelModelReferenceBuilds off\n\t  ParallelModelReferenceErrorOnInvalidPool on\n\t  ParallelModelReferenceMATLABWorkerInit \"None\"\n\t  ModelReferenceNumInstancesAllowed \"Multi\"\n\t  PropagateVarSize\t  \"Infer from blocks in model\"\n\t  ModelReferencePassRootInputsByReference on\n\t  ModelReferenceMinAlgLoopOccurrences off\n\t  PropagateSignalLabelsOutOfModel off\n\t  SupportModelReferenceSimTargetCustomCode off\n\t}\n\tSimulink.SFSimCC {\n\t  $ObjectID\t\t  14\n\t  Version\t\t  \"1.12.1\"\n\t  SFSimEnableDebug\t  on\n\t  SFSimOverflowDetection  on\n\t  SFSimEcho\t\t  on\n\t  SimBlas\t\t  on\n\t  SimCtrlC\t\t  on\n\t  SimExtrinsic\t\t  on\n\t  SimIntegrity\t\t  on\n\t  SimUseLocalCustomCode\t  off\n\t  SimParseCustomCode\t  on\n\t  SimBuildMode\t\t  \"sf_incremental_build\"\n\t}\n\tSimulink.RTWCC {\n\t  $BackupClass\t\t  \"Simulink.RTWCC\"\n\t  $ObjectID\t\t  15\n\t  Version\t\t  \"1.12.1\"\n\t  Array {\n\t    Type\t\t    \"Cell\"\n\t    Dimension\t\t    15\n\t    Cell\t\t    \"IncludeHyperlinkInReport\"\n\t    Cell\t\t    \"GenerateTraceInfo\"\n\t    Cell\t\t    \"GenerateTraceReport\"\n\t    Cell\t\t    \"GenerateTraceReportSl\"\n\t    Cell\t\t    \"GenerateTraceReportSf\"\n\t    Cell\t\t    \"GenerateTraceReportEml\"\n\t    Cell\t\t    \"PortableWordSizes\"\n\t    Cell\t\t    \"GenerateWebview\"\n\t    Cell\t\t    \"GenerateCodeMetricsReport\"\n\t    Cell\t\t    \"GenerateCodeReplacementReport\"\n\t    Cell\t\t    \"GenerateErtSFunction\"\n\t    Cell\t\t    \"CreateSILPILBlock\"\n\t    Cell\t\t    \"CodeExecutionProfiling\"\n\t    Cell\t\t    \"CodeProfilingSaveOptions\"\n\t    Cell\t\t    \"CodeProfilingInstrumentation\"\n\t    PropName\t\t    \"DisabledProps\"\n\t  }\n\t  SystemTargetFile\t  \"grt.tlc\"\n\t  GenCodeOnly\t\t  off\n\t  MakeCommand\t\t  \"make_rtw\"\n\t  GenerateMakefile\t  on\n\t  PackageGeneratedCodeAndArtifacts off\n\t  TemplateMakefile\t  \"grt_default_tmf\"\n\t  GenerateReport\t  off\n\t  SaveLog\t\t  off\n\t  RTWVerbose\t\t  on\n\t  RetainRTWFile\t\t  off\n\t  ProfileTLC\t\t  off\n\t  TLCDebug\t\t  off\n\t  TLCCoverage\t\t  off\n\t  TLCAssert\t\t  off\n\t  ProcessScriptMode\t  \"Default\"\n\t  ConfigurationMode\t  \"Optimized\"\n\t  ConfigAtBuild\t\t  off\n\t  RTWUseLocalCustomCode\t  off\n\t  RTWUseSimCustomCode\t  off\n\t  IncludeHyperlinkInReport off\n\t  LaunchReport\t\t  off\n\t  PortableWordSizes\t  off\n\t  GenerateErtSFunction\t  off\n\t  CreateSILPILBlock\t  \"None\"\n\t  CodeExecutionProfiling  off\n\t  CodeExecutionProfileVariable \"executionProfile\"\n\t  CodeProfilingSaveOptions \"SummaryOnly\"\n\t  CodeProfilingInstrumentation off\n\t  TargetLang\t\t  \"C\"\n\t  IncludeBusHierarchyInRTWFileBlockHierarchyMap\toff\n\t  IncludeERTFirstTime\t  off\n\t  GenerateTraceInfo\t  off\n\t  GenerateTraceReport\t  off\n\t  GenerateTraceReportSl\t  off\n\t  GenerateTraceReportSf\t  off\n\t  GenerateTraceReportEml  off\n\t  GenerateCodeInfo\t  off\n\t  GenerateWebview\t  off\n\t  GenerateCodeMetricsReport off\n\t  GenerateCodeReplacementReport\toff\n\t  RTWCompilerOptimization \"Off\"\n\t  CheckMdlBeforeBuild\t  \"Off\"\n\t  CustomRebuildMode\t  \"OnUpdate\"\n\t  Array {\n\t    Type\t\t    \"Handle\"\n\t    Dimension\t\t    2\n\t    Simulink.CodeAppCC {\n\t      $ObjectID\t\t      16\n\t      Version\t\t      \"1.12.1\"\n\t      Array {\n\t\tType\t\t\t\"Cell\"\n\t\tDimension\t\t22\n\t\tCell\t\t\t\"IgnoreCustomStorageClasses\"\n\t\tCell\t\t\t\"IgnoreTestpoints\"\n\t\tCell\t\t\t\"InsertBlockDesc\"\n\t\tCell\t\t\t\"InsertPolySpaceComments\"\n\t\tCell\t\t\t\"SFDataObjDesc\"\n\t\tCell\t\t\t\"MATLABFcnDesc\"\n\t\tCell\t\t\t\"SimulinkDataObjDesc\"\n\t\tCell\t\t\t\"DefineNamingRule\"\n\t\tCell\t\t\t\"SignalNamingRule\"\n\t\tCell\t\t\t\"ParamNamingRule\"\n\t\tCell\t\t\t\"InternalIdentifier\"\n\t\tCell\t\t\t\"InlinedPrmAccess\"\n\t\tCell\t\t\t\"CustomSymbolStr\"\n\t\tCell\t\t\t\"CustomSymbolStrGlobalVar\"\n\t\tCell\t\t\t\"CustomSymbolStrType\"\n\t\tCell\t\t\t\"CustomSymbolStrField\"\n\t\tCell\t\t\t\"CustomSymbolStrFcn\"\n\t\tCell\t\t\t\"CustomSymbolStrFcnArg\"\n\t\tCell\t\t\t\"CustomSymbolStrBlkIO\"\n\t\tCell\t\t\t\"CustomSymbolStrTmpVar\"\n\t\tCell\t\t\t\"CustomSymbolStrMacro\"\n\t\tCell\t\t\t\"ReqsInCode\"\n\t\tPropName\t\t\"DisabledProps\"\n\t      }\n\t      ForceParamTrailComments off\n\t      GenerateComments\t      on\n\t      IgnoreCustomStorageClasses on\n\t      IgnoreTestpoints\t      off\n\t      IncHierarchyInIds\t      off\n\t      MaxIdLength\t      31\n\t      PreserveName\t      off\n\t      PreserveNameWithParent  off\n\t      ShowEliminatedStatement off\n\t      OperatorAnnotations     off\n\t      IncAutoGenComments      off\n\t      SimulinkDataObjDesc     off\n\t      SFDataObjDesc\t      off\n\t      MATLABFcnDesc\t      off\n\t      IncDataTypeInIds\t      off\n\t      MangleLength\t      1\n\t      CustomSymbolStrGlobalVar \"$R$N$M\"\n\t      CustomSymbolStrType     \"$N$R$M\"\n\t      CustomSymbolStrField    \"$N$M\"\n\t      CustomSymbolStrFcn      \"$R$N$M$F\"\n\t      CustomSymbolStrFcnArg   \"rt$I$N$M\"\n\t      CustomSymbolStrBlkIO    \"rtb_$N$M\"\n\t      CustomSymbolStrTmpVar   \"$N$M\"\n\t      CustomSymbolStrMacro    \"$R$N$M\"\n\t      DefineNamingRule\t      \"None\"\n\t      ParamNamingRule\t      \"None\"\n\t      SignalNamingRule\t      \"None\"\n\t      InsertBlockDesc\t      off\n\t      InsertPolySpaceComments off\n\t      SimulinkBlockComments   on\n\t      MATLABSourceComments    off\n\t      EnableCustomComments    off\n\t      InternalIdentifier      \"Classic\"\n\t      InlinedPrmAccess\t      \"Literals\"\n\t      ReqsInCode\t      off\n\t      UseSimReservedNames     off\n\t    }\n\t    Simulink.GRTTargetCC {\n\t      $BackupClass\t      \"Simulink.TargetCC\"\n\t      $ObjectID\t\t      17\n\t      Version\t\t      \"1.12.1\"\n\t      Array {\n\t\tType\t\t\t\"Cell\"\n\t\tDimension\t\t15\n\t\tCell\t\t\t\"GeneratePreprocessorConditionals\"\n\t\tCell\t\t\t\"IncludeMdlTerminateFcn\"\n\t\tCell\t\t\t\"CombineOutputUpdateFcns\"\n\t\tCell\t\t\t\"SuppressErrorStatus\"\n\t\tCell\t\t\t\"ERTCustomFileBanners\"\n\t\tCell\t\t\t\"GenerateSampleERTMain\"\n\t\tCell\t\t\t\"GenerateTestInterfaces\"\n\t\tCell\t\t\t\"ModelStepFunctionPrototypeControlCompliant\"\n\t\tCell\t\t\t\"CPPClassGenCompliant\"\n\t\tCell\t\t\t\"MultiInstanceERTCode\"\n\t\tCell\t\t\t\"PurelyIntegerCode\"\n\t\tCell\t\t\t\"SupportComplex\"\n\t\tCell\t\t\t\"SupportAbsoluteTime\"\n\t\tCell\t\t\t\"SupportContinuousTime\"\n\t\tCell\t\t\t\"SupportNonInlinedSFcns\"\n\t\tPropName\t\t\"DisabledProps\"\n\t      }\n\t      TargetFcnLib\t      \"ansi_tfl_table_tmw.mat\"\n\t      TargetLibSuffix\t      \"\"\n\t      TargetPreCompLibLocation \"\"\n\t      CodeReplacementLibrary  \"ANSI_C\"\n\t      UtilityFuncGeneration   \"Auto\"\n\t      ERTMultiwordTypeDef     \"System defined\"\n\t      ERTMultiwordLength      256\n\t      MultiwordLength\t      2048\n\t      GenerateFullHeader      on\n\t      GenerateSampleERTMain   off\n\t      GenerateTestInterfaces  off\n\t      IsPILTarget\t      off\n\t      ModelReferenceCompliant on\n\t      ParMdlRefBuildCompliant on\n\t      CompOptLevelCompliant   on\n\t      ConcurrentExecutionCompliant on\n\t      IncludeMdlTerminateFcn  on\n\t      GeneratePreprocessorConditionals \"Disable all\"\n\t      CombineOutputUpdateFcns on\n\t      CombineSignalStateStructs\toff\n\t      SuppressErrorStatus     off\n\t      ERTFirstTimeCompliant   off\n\t      IncludeFileDelimiter    \"Auto\"\n\t      ERTCustomFileBanners    off\n\t      SupportAbsoluteTime     on\n\t      LogVarNameModifier      \"rt_\"\n\t      MatFileLogging\t      on\n\t      MultiInstanceERTCode    off\n\t      SupportNonFinite\t      on\n\t      SupportComplex\t      on\n\t      PurelyIntegerCode\t      off\n\t      SupportContinuousTime   on\n\t      SupportNonInlinedSFcns  on\n\t      SupportVariableSizeSignals off\n\t      EnableShiftOperators    on\n\t      ParenthesesLevel\t      \"Nominal\"\n\t      ModelStepFunctionPrototypeControlCompliant off\n\t      CPPClassGenCompliant    off\n\t      AutosarCompliant\t      off\n\t      GRTInterface\t      off\n\t      UseMalloc\t\t      off\n\t      ExtMode\t\t      off\n\t      ExtModeStaticAlloc      off\n\t      ExtModeTesting\t      off\n\t      ExtModeStaticAllocSize  1000000\n\t      ExtModeTransport\t      0\n\t      ExtModeMexFile\t      \"ext_comm\"\n\t      ExtModeIntrfLevel\t      \"Level1\"\n\t      RTWCAPISignals\t      off\n\t      RTWCAPIParams\t      off\n\t      RTWCAPIStates\t      off\n\t      RTWCAPIRootIO\t      off\n\t      GenerateASAP2\t      off\n\t    }\n\t    PropName\t\t    \"Components\"\n\t  }\n\t}\n\tPropName\t\t\"Components\"\n      }\n      Name\t\t      \"Configuration\"\n      CurrentDlgPage\t      \"Solver\"\n      ConfigPrmDlgPosition     [ 520, 225, 1400, 855 ] \n    }\n    PropName\t\t    \"ConfigurationSets\"\n  }\n  Simulink.ConfigSet {\n    $PropName\t\t    \"ActiveConfigurationSet\"\n    $ObjectID\t\t    7\n  }\n  Object {\n    $PropName\t\t    \"DataTransfer\"\n    $ObjectID\t\t    18\n    $ClassName\t\t    \"Simulink.GlobalDataTransfer\"\n    DefaultTransitionBetweenSyncTasks \"Ensure deterministic transfer (maximum delay)\"\n    DefaultTransitionBetweenAsyncTasks \"Ensure data integrity only\"\n    DefaultTransitionBetweenContTasks \"Ensure deterministic transfer (minimum delay)\"\n    DefaultExtrapolationMethodBetweenContTasks \"None\"\n    AutoInsertRateTranBlk   [0]\n  }\n  ExplicitPartitioning\t  off\n  BlockDefaults {\n    ForegroundColor\t    \"black\"\n    BackgroundColor\t    \"white\"\n    DropShadow\t\t    off\n    NamePlacement\t    \"normal\"\n    FontName\t\t    \"Helvetica\"\n    FontSize\t\t    10\n    FontWeight\t\t    \"normal\"\n    FontAngle\t\t    \"normal\"\n    ShowName\t\t    on\n    BlockRotation\t    0\n    BlockMirror\t\t    off\n  }\n  AnnotationDefaults {\n    HorizontalAlignment\t    \"center\"\n    VerticalAlignment\t    \"middle\"\n    ForegroundColor\t    \"black\"\n    BackgroundColor\t    \"white\"\n    DropShadow\t\t    off\n    FontName\t\t    \"Helvetica\"\n    FontSize\t\t    10\n    FontWeight\t\t    \"normal\"\n    FontAngle\t\t    \"normal\"\n    UseDisplayTextAsClickCallback off\n  }\n  LineDefaults {\n    FontName\t\t    \"Helvetica\"\n    FontSize\t\t    9\n    FontWeight\t\t    \"normal\"\n    FontAngle\t\t    \"normal\"\n  }\n  MaskDefaults {\n    SelfModifiable\t    \"off\"\n    IconFrame\t\t    \"on\"\n    IconOpaque\t\t    \"on\"\n    RunInitForIconRedraw    \"off\"\n    IconRotate\t\t    \"none\"\n    PortRotate\t\t    \"default\"\n    IconUnits\t\t    \"autoscale\"\n  }\n  MaskParameterDefaults {\n    Evaluate\t\t    \"on\"\n    Tunable\t\t    \"on\"\n    NeverSave\t\t    \"off\"\n    Internal\t\t    \"off\"\n    ReadOnly\t\t    \"off\"\n    Enabled\t\t    \"on\"\n    Visible\t\t    \"on\"\n    ToolTip\t\t    \"on\"\n  }\n  BlockParameterDefaults {\n    Block {\n      BlockType\t\t      S-Function\n      FunctionName\t      \"system\"\n      SFunctionModules\t      \"''\"\n      PortCounts\t      \"[]\"\n      SFunctionDeploymentMode off\n    }\n  }\n  System {\n    Name\t\t    \"FORCENLPsolver\"\n    Location\t\t    [385, 84, 1201, 623]\n    Open\t\t    on\n    ModelBrowserVisibility  on\n    ModelBrowserWidth\t    200\n    ScreenColor\t\t    \"white\"\n    PaperOrientation\t    \"landscape\"\n    PaperPositionMode\t    \"auto\"\n    PaperType\t\t    \"A4\"\n    PaperUnits\t\t    \"centimeters\"\n    TiledPaperMargins\t    [1.270000, 1.270000, 1.270000, 1.270000]\n    TiledPageScale\t    1\n    ShowPageBoundaries\t    off\n    ZoomFactor\t\t    \"100\"\n    ReportName\t\t    \"simulink-default.rpt\"\n    SIDHighWatermark\t    \"1\"\n    Block {\n      BlockType\t\t      S-Function\n      Name\t\t      \"FORCENLPsolver\"\n      SID\t\t      \"1\"\n      Ports\t\t      [4, 1]\n      Position\t\t      [170, 99, 650, 180]\n      ZOrder\t\t      1\n      FunctionName\t      \"FORCENLPsolver_simulinkBlockcompact\"\n\t  SFunctionModules\t      \"FORCENLPsolver FORCENLPsolver_simulinkBlockcompact\"\n      EnableBusSupport\t      off\n      Object {\n\t$PropName\t\t\"MaskObject\"\n\t$ObjectID\t\t19\n\t$ClassName\t\t\"Simulink.Mask\"\n\tType\t\t\t\"FORCENLPsolver_simulinkBlockcompact\"\n\tDescription\t\t\" ---- Simulink block encapsulating your customized solver FORCENLPsolver ---- \\n\\n\"\n\t\t\t\t\"FORCENLPsolver : A fast customized optimization solver.\\n\"\n\"\\n\"\n\"Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\\n\"\n\"\\n\"\n\"\\n\"\n\"This software is intended for simulation and testing purposes only. \\n\"\n\"Use of this software for any commercial purpose is prohibited.\\n\"\n\"\\n\"\n\"This program is distributed in the hope that it will be useful.\\n\"\n\"EMBOTECH makes NO WARRANTIES with respect to the use of the software \\n\"\n\"without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \\n\"\n\"PARTICULAR PURPOSE. \\n\"\n\"\\n\"\n\"EMBOTECH shall not have any liability for any damage arising from the use\\n\"\n\"of the software.\\n\"\n\"\\n\"\n\"This Agreement shall exclusively be governed by and interpreted in \\n\"\n\"accordance with the laws of Switzerland, excluding its principles\\n\"\n\"of conflict of laws. The Courts of Zurich-City shall have exclusive \\n\"\n\"jurisdiction in case of any dispute.\\n\"\n\"\\n\"\n\n\tHelp\t\t\t\"FORCENLPsolver_simulinkBlockcompact provides an easy Simulink interface for simulating your customized solver.  \\n\"\n\t\"\\nOUTPUTS = FORCENLPsolver(INPUTS) solves an optimization problem where:\\n\\n\"\n\t\"INPUTS:\\n\"\n\t\" - reinitialize - column vector of length 0\\n \"\n\" - xinit - column vector of length 3\\n \"\n\" - x0 - column vector of length 100\\n \"\n\" - all_parameters - column vector of length 60\\n \"\n\n\t\"\\nOUTPUTS:\\n\"\n\t\" - outputs - column vector of length 100\\n \"\n\n\t\"\\n For more information, see https://forces.embotech.com/Documentation/graphical_interface/index.html \\n \"\n\n\tDisplay\t\t\t\"port_label('input', 1, 'reinitialize') \\n  \"\n\"port_label('input', 2, 'xinit') \\n  \"\n\"port_label('input', 3, 'x0') \\n  \"\n\"port_label('input', 4, 'all_parameters') \\n  \"\n\"port_label('output', 1, 'outputs') \\n \"\n\"if( exist('FORCES_PRO_Logo.jpg','file') ), image(imread('FORCES_PRO_Logo.jpg'),'center','on'); elseif( exist(['interface',filesep,'FORCES_PRO_Logo.jpg'],'file') ), image(imread(['interface',filesep,'FORCES_PRO_Logo.jpg']),'center','on'); elseif( exist(['FORCENLPsolver',filesep,'interface',filesep,'FORCES_PRO_Logo.jpg'],'file') ), image(imread(['FORCENLPsolver',filesep,'interface',filesep,'FORCES_PRO_Logo.jpg']),'center','on'); end \\n \"\n\n      }\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolvercompact_lib.mdl b/model/FORCENLPsolver/interface/FORCENLPsolvercompact_lib.mdl
--- a/model/FORCENLPsolver/interface/FORCENLPsolvercompact_lib.mdl	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolvercompact_lib.mdl	(date 1646039467396)
@@ -60,13 +60,13 @@
       }
     }
   }
-  Created		  "2/27/2022 3:20:15 PM"
+  Created		  "2/28/2022 9:11:02 AM"
   Creator		  "embotech AG"
   UpdateHistory		  "UpdateHistoryNever"
   ModifiedByFormat	  "%<Auto>"
   LastModifiedBy	  "embotech AG"
   ModifiedDateFormat	  "%<Auto>"
-  LastModifiedDate	  "2/27/2022 3:20:15 PM"
+  LastModifiedDate	  "2/28/2022 9:11:02 AM"
   RTWModifiedTimeStamp	  315310195
   ModelVersionFormat	  "1.%<AutoIncrement:2>"
   ConfigurationManager	  "None"
@@ -805,7 +805,7 @@
 	"\nOUTPUTS = FORCENLPsolver(INPUTS) solves an optimization problem where:\n\n"
 	"INPUTS:\n"
 	" - reinitialize - column vector of length 0\n "
-" - xinit - column vector of length 3\n "
+" - xinit - column vector of length 6\n "
 " - x0 - column vector of length 100\n "
 " - all_parameters - column vector of length 60\n "
 
Index: model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nFORCENLPsolver : A fast customized optimization solver.\n\nCopyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n\n\nThis software is intended for simulation and testing purposes only. \nUse of this software for any commercial purpose is prohibited.\n\nThis program is distributed in the hope that it will be useful.\nEMBOTECH makes NO WARRANTIES with respect to the use of the software \nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. \n\nEMBOTECH shall not have any liability for any damage arising from the use\nof the software.\n\nThis Agreement shall exclusively be governed by and interpreted in \naccordance with the laws of Switzerland, excluding its principles\nof conflict of laws. The Courts of Zurich-City shall have exclusive \njurisdiction in case of any dispute.\n\n*/\n\n\n#define S_FUNCTION_LEVEL 2\n#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlockcompact\n\n#include \"simstruc.h\"\n\n/* For compatibility with Microsoft Visual Studio 2015 */\n#if _MSC_VER >= 1900\nFILE _iob[3];\nFILE * __cdecl __iob_func(void)\n{\n\t_iob[0] = *stdin;\n\t_iob[1] = *stdout;\n\t_iob[2] = *stderr;\n\treturn _iob;\n}\n#endif\n\n/* include FORCESPRO functions and defs */\n#include \"../include/FORCENLPsolver.h\" \n\n/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */\n\n\n#if defined(MATLAB_MEX_FILE)\n#include \"tmwtypes.h\"\n#include \"simstruc_types.h\"\n#else\n#include \"rtwtypes.h\"\n#endif\n\ntypedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;\n\nextern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);\nFORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;\n\n\n\n\n/*====================*\n * S-function methods *\n *====================*/\n/* Function: mdlInitializeSizes =========================================\n * Abstract:\n *   Setup sizes of the various vectors.\n */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n\n    DECL_AND_INIT_DIMSINFO(inputDimsInfo);\n    DECL_AND_INIT_DIMSINFO(outputDimsInfo);\n    ssSetNumSFcnParams(S, 0);\n    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) \n\t{\n\t\treturn; /* Parameter mismatch will be reported by Simulink */\n    }\n\n\t/* initialize size of continuous and discrete states to zero */\n    ssSetNumContStates(S, 0);\n    ssSetNumDiscStates(S, 0);\n\n\t/* initialize input ports - there are 4 in total */\n    if (!ssSetNumInputPorts(S, 4)) return;\n    \t\n\t/* Input Port 0 */\n    ssSetInputPortMatrixDimensions(S,  0, 1, 1);\n    ssSetInputPortDataType(S, 0, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/\n\t\n\t/* Input Port 1 */\n    ssSetInputPortMatrixDimensions(S,  1, 3, 1);\n    ssSetInputPortDataType(S, 1, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/\n\t\n\t/* Input Port 2 */\n    ssSetInputPortMatrixDimensions(S,  2, 100, 1);\n    ssSetInputPortDataType(S, 2, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/\n\t\n\t/* Input Port 3 */\n    ssSetInputPortMatrixDimensions(S,  3, 60, 1);\n    ssSetInputPortDataType(S, 3, SS_DOUBLE);\n    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */\n    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */\n    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/\n \n\n\n\t/* initialize output ports - there are 1 in total */\n    if (!ssSetNumOutputPorts(S, 1)) return;    \n\t\t\n\t/* Output Port 0 */\n    ssSetOutputPortMatrixDimensions(S,  0, 100, 1);\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\n    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */\n\n\n\t/* set sampling time */\n    ssSetNumSampleTimes(S, 1);\n\n\t/* set internal memory of block */\n    ssSetNumRWork(S, 0);\n    ssSetNumIWork(S, 0);\n    ssSetNumPWork(S, 0);\n    ssSetNumModes(S, 0);\n    ssSetNumNonsampledZCs(S, 0);\n\n    /* Take care when specifying exception free code - see sfuntmpl_doc.c */\n\t/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ \n\t/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ \n    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |\n\t\t             SS_OPTION_WORKS_WITH_CODE_REUSE)); */\n\tssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );\n\n\t\n}\n\n#if defined(MATLAB_MEX_FILE)\n#define MDL_SET_INPUT_PORT_DIMENSION_INFO\nstatic void mdlSetInputPortDimensionInfo(SimStruct        *S, \n                                         int_T            port,\n                                         const DimsInfo_T *dimsInfo)\n{\n    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;\n}\n#endif\n\n#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO\n#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)\nstatic void mdlSetOutputPortDimensionInfo(SimStruct        *S, \n                                          int_T            port, \n                                          const DimsInfo_T *dimsInfo)\n{\n    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;\n}\n#endif\n# define MDL_SET_INPUT_PORT_FRAME_DATA\nstatic void mdlSetInputPortFrameData(SimStruct  *S, \n                                     int_T      port,\n                                     Frame_T    frameData)\n{\n    ssSetInputPortFrameData(S, port, frameData);\n}\n/* Function: mdlInitializeSampleTimes =========================================\n * Abstract:\n *    Specifiy  the sample time.\n */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);\n    ssSetOffsetTime(S, 0, 0.0);\n}\n\n#define MDL_SET_INPUT_PORT_DATA_TYPE\nstatic void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)\n{\n    ssSetInputPortDataType( S, 0, dType);\n}\n#define MDL_SET_OUTPUT_PORT_DATA_TYPE\nstatic void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)\n{\n    ssSetOutputPortDataType(S, 0, dType);\n}\n\n#define MDL_SET_DEFAULT_PORT_DATA_TYPES\nstatic void mdlSetDefaultPortDataTypes(SimStruct *S)\n{\n    ssSetInputPortDataType( S, 0, SS_DOUBLE);\n    ssSetOutputPortDataType(S, 0, SS_DOUBLE);\n}\n\n\n\n\n\n/* Function: mdlOutputs =======================================================\n *\n*/\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n\tsolver_int32_default i, j, k;\n\t\n\t/* file pointer for printing */\n\tFILE *fp = NULL;\n\n\t/* Simulink data */\n\tconst FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,0);\n\tconst real_T *xinit = (const real_T*) ssGetInputPortSignal(S,1);\n\tconst real_T *x0 = (const real_T*) ssGetInputPortSignal(S,2);\n\tconst real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,3);\n\t\n    real_T *outputs = (real_T*) ssGetOutputPortSignal(S,0);\n\t\n\t\n\n\t/* Solver data */\n\tstatic FORCENLPsolver_params params;\n\tstatic FORCENLPsolver_output output;\n\tstatic FORCENLPsolver_info info;\t\n\tsolver_int32_default exitflag;\n\n\t/* Extra NMPC data */\n\t\n\n\t/* Copy inputs */\n\tfor( i=0; i<3; i++)\n\t{ \n\t\tparams.xinit[i] = (double) xinit[i]; \n\t}\n\n\tfor( i=0; i<100; i++)\n\t{ \n\t\tparams.x0[i] = (double) x0[i]; \n\t}\n\n\tfor( i=0; i<60; i++)\n\t{ \n\t\tparams.all_parameters[i] = (double) all_parameters[i]; \n\t}\n\n\tparams.reinitialize = *reinitialize;\n\n\t\n\n\t\n\n    #if SET_PRINTLEVEL_FORCENLPsolver > 0\n\t\t/* Prepare file for printfs */\n        fp = fopen(\"stdout_temp\",\"w+\");\n\t\tif( fp == NULL ) \n\t\t{\n\t\t\tmexErrMsgTxt(\"freopen of stdout did not work.\");\n\t\t}\n\t\trewind(fp);\n\t#endif\n\n\t/* Call solver */\n\texitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);\n\n\t#if SET_PRINTLEVEL_FORCENLPsolver > 0\n\t\t/* Read contents of printfs printed to file */\n\t\trewind(fp);\n\t\twhile( (i = fgetc(fp)) != EOF ) \n\t\t{\n\t\t\tssPrintf(\"%c\",i);\n\t\t}\n\t\tfclose(fp);\n\t#endif\n\n\t\n\n\t/* Copy outputs */\n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[i] = (real_T) output.x01[i]; \n\t}\n\n\tk=5; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x02[i]; \n\t}\n\n\tk=10; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x03[i]; \n\t}\n\n\tk=15; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x04[i]; \n\t}\n\n\tk=20; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x05[i]; \n\t}\n\n\tk=25; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x06[i]; \n\t}\n\n\tk=30; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x07[i]; \n\t}\n\n\tk=35; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x08[i]; \n\t}\n\n\tk=40; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x09[i]; \n\t}\n\n\tk=45; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x10[i]; \n\t}\n\n\tk=50; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x11[i]; \n\t}\n\n\tk=55; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x12[i]; \n\t}\n\n\tk=60; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x13[i]; \n\t}\n\n\tk=65; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x14[i]; \n\t}\n\n\tk=70; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x15[i]; \n\t}\n\n\tk=75; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x16[i]; \n\t}\n\n\tk=80; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x17[i]; \n\t}\n\n\tk=85; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x18[i]; \n\t}\n\n\tk=90; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x19[i]; \n\t}\n\n\tk=95; \n\tfor( i=0; i<5; i++)\n\t{ \n\t\toutputs[k++] = (real_T) output.x20[i]; \n\t}\n\n\t\n}\n\n\n\n\n\n/* Function: mdlTerminate =====================================================\n * Abstract:\n *    In this function, you should perform any actions that are necessary\n *    at the termination of a simulation.  For example, if memory was\n *    allocated in mdlStart, this is the place to free it.\n */\nstatic void mdlTerminate(SimStruct *S)\n{\n}\n#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */\n#include \"simulink.c\"      /* MEX-file interface mechanism */\n#else\n#include \"cg_sfun.h\"       /* Code generation registration function */\n#endif\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c	(date 1646039467396)
@@ -28,17 +28,7 @@
 
 #include "simstruc.h"
 
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
+
 
 /* include FORCESPRO functions and defs */
 #include "../include/FORCENLPsolver.h" 
@@ -94,7 +84,7 @@
     ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
 	
 	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 3, 1);
+    ssSetInputPortMatrixDimensions(S,  1, 6, 1);
     ssSetInputPortDataType(S, 1, SS_DOUBLE);
     ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
     ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
@@ -233,7 +223,7 @@
 	
 
 	/* Copy inputs */
-	for( i=0; i<3; i++)
+	for( i=0; i<6; i++)
 	{ 
 		params.xinit[i] = (double) xinit[i]; 
 	}
@@ -280,125 +270,65 @@
 	
 
 	/* Copy outputs */
-	for( i=0; i<5; i++)
+	for( i=0; i<10; i++)
 	{ 
 		outputs[i] = (real_T) output.x01[i]; 
 	}
 
-	k=5; 
-	for( i=0; i<5; i++)
+	k=10; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x02[i]; 
 	}
 
-	k=10; 
-	for( i=0; i<5; i++)
+	k=20; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x03[i]; 
 	}
 
-	k=15; 
-	for( i=0; i<5; i++)
+	k=30; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x04[i]; 
 	}
 
-	k=20; 
-	for( i=0; i<5; i++)
+	k=40; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x05[i]; 
 	}
 
-	k=25; 
-	for( i=0; i<5; i++)
+	k=50; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x06[i]; 
 	}
 
-	k=30; 
-	for( i=0; i<5; i++)
+	k=60; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x07[i]; 
 	}
 
-	k=35; 
-	for( i=0; i<5; i++)
+	k=70; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x08[i]; 
 	}
 
-	k=40; 
-	for( i=0; i<5; i++)
+	k=80; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x09[i]; 
 	}
 
-	k=45; 
-	for( i=0; i<5; i++)
+	k=90; 
+	for( i=0; i<10; i++)
 	{ 
 		outputs[k++] = (real_T) output.x10[i]; 
 	}
 
-	k=50; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x11[i]; 
-	}
-
-	k=55; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x12[i]; 
-	}
-
-	k=60; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x13[i]; 
-	}
-
-	k=65; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x14[i]; 
-	}
-
-	k=70; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x15[i]; 
-	}
-
-	k=75; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x16[i]; 
-	}
-
-	k=80; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x17[i]; 
-	}
-
-	k=85; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x18[i]; 
-	}
-
-	k=90; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x19[i]; 
-	}
-
-	k=95; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x20[i]; 
-	}
-
 	
 }
 
Index: model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nFORCENLPsolver : A fast customized optimization solver.\n\nCopyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n\n\nThis software is intended for simulation and testing purposes only. \nUse of this software for any commercial purpose is prohibited.\n\nThis program is distributed in the hope that it will be useful.\nEMBOTECH makes NO WARRANTIES with respect to the use of the software \nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. \n\nEMBOTECH shall not have any liability for any damage arising from the use\nof the software.\n\nThis Agreement shall exclusively be governed by and interpreted in \naccordance with the laws of Switzerland, excluding its principles\nof conflict of laws. The Courts of Zurich-City shall have exclusive \njurisdiction in case of any dispute.\n\n*/\n\n#include \"mex.h\"\n#include \"math.h\"\n#include <string.h>\n#include \"../include/FORCENLPsolver.h\"\n#ifndef SOLVER_STDIO_H\n#define SOLVER_STDIO_H\n#include <stdio.h>\n#endif\n\ntypedef FORCENLPsolver_float solver_float;\ntypedef solver_int32_default solver_int;\n#define NSTAGES ( 20 )\n#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))\n\n/* For compatibility with Microsoft Visual Studio 2015 */\n#if _MSC_VER >= 1900\nFILE _iob[3];\nFILE * __cdecl __iob_func(void)\n{\n\t_iob[0] = *stdin;\n\t_iob[1] = *stdout;\n\t_iob[2] = *stderr;\n\treturn _iob;\n}\n#endif\n\n/* copy functions */\n\nvoid copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (double)*src++;\n    }\n}\n\nvoid copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)\n{\n    *dest = (double)*src;\n}\n\nvoid copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (FORCENLPsolver_float) (*src++) ;\n    }\n}\n\nvoid copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)\n{\n\t*dest = (FORCENLPsolver_float) *src;\n}\n\n\n\nextern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);\nFORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;\n\n\nstatic void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, \n             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)\n{\n    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; \n    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\n    *nvar = nvarArr[stage];\n    *neq = neqArr[stage];\n    *dimh = dimhArr[stage];\n    *dimp = dimpArr[stage];\n    *diml = dimlArr[stage];\n    *dimu = dimuArr[stage];\n    *dimhl = dimhlArr[stage];\n    *dimhu = dimhuArr[stage];\n}\n\n/* Checks all inputs and returns stage number (1-indexed) */\nstatic void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, \n                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)\n{\n    mxArray *arr;\n\n    if (nrhs > 3 || nrhs < 1)\n\t{\n\t\tmexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"This function takes at least one input: z. And at most 3 inputs: z, p, stage.\");\n\t}     \n\n    // get stage\n    *stage = (solver_int) 1;\n    if (nrhs == 3)\n    {\n        arr = prhs[2];\n        if ( !mxIsDouble(arr) )\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The third input (stage number) must be an integer.\");\n        }\n        *stage = (solver_int) *mxGetPr(arr);\n    }\n    if ( *stage < 1 || (NSTAGES-1) < *stage )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"Stage must be between %d and %d.\", 1, (NSTAGES-1));\n    }    \n\n    /* Get other dimensions */\n    *stage -= 1; /* 0-indexed stages */\n    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);\n\n    /* Check that passed z and p have correct dims */  \n    arr = prhs[0];\n    if ( !mxIsDouble(arr) )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The first input (z) must be a column vector.\");\n    }    \n    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The first input (z) must be a column vector of length %d.\", *nvar);\n    }\n    if (nrhs > 1)\n\t{\n        arr = prhs[1];\n        if ( *dimp > 0 && mxIsEmpty(arr))\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector of length %d.\", *dimp);\n        }   \n        if ( !mxIsEmpty(arr) )\n        {\n            if ( !mxIsDouble(arr) )\n            {\n                mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector.\");\n            }    \n            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )\n            {\n                mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector of length %d.\", *dimp);\n            }            \n        }\n\t}\n    else\n    {\n        if ( *dimp > 0 )\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"Run time parameters are required as a second input for evaluating this fcn.\");\n        }         \n    } \n}\n\n/* THE mex-function */\nvoid mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  \n{\n\tmxArray *arr;\n    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;\n\n    // Allocate memory \n    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;\n\n\tmxArray* c_mex;\n\tmxArray* jacc_mex;\n\n\n    // get data\n    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);\n    dimmul = diml+dimu+dimhl+dimhu;\n\n    // Allocate memory \n    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));\n    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));\n    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));\n    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));\n    obj = (solver_float *) malloc(sizeof(solver_float));\n    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));\n    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));\n    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));\n    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));\n    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));\n    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));\n\n    /* Initialize all inputs */\n    arr = prhs[0];\n    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);\n    if (nrhs > 1)\n\t{\n        arr = prhs[1];\n        if ( !mxIsEmpty(arr) )\n        {\n            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);\n        }\n\t}   \n    memset(y, 0, sizeof(solver_float)*neq);\n    memset(l, 0, sizeof(solver_float)*dimmul);\n    memset(obj, 0, sizeof(solver_float));\n    memset(jacobj, 0, sizeof(solver_float)*nvar);\n    memset(c, 0, sizeof(solver_float)*neq);\n    memset(jacc, 0, sizeof(solver_float)*neq*nvar);\n    memset(h, 0, sizeof(solver_float)*dimh);\n    memset(jach, 0, sizeof(solver_float)*dimh*nvar);\n    memset(hess, 0, sizeof(solver_float)*nvar*nvar);\n\n    // Evaluate fcns and read output into mex format\n\t(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);\n\tc_mex = mxCreateDoubleMatrix(neq, 1, mxREAL);\n\tjacc_mex = mxCreateDoubleMatrix(neq, nvar, mxREAL);\n\tcopyCArrayToM_FORCENLPsolver(c, mxGetPr(c_mex), neq);\n\tcopyCArrayToM_FORCENLPsolver(jacc, mxGetPr(jacc_mex), neq*nvar);\n\tplhs[0] = c_mex;\n\tplhs[1] = jacc_mex;\n\n\n    // Free memory\n    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c	(date 1646039467396)
@@ -33,7 +33,7 @@
 
 typedef FORCENLPsolver_float solver_float;
 typedef solver_int32_default solver_int;
-#define NSTAGES ( 20 )
+#define NSTAGES ( 10 )
 #define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
 
 /* For compatibility with Microsoft Visual Studio 2015 */
@@ -87,14 +87,14 @@
 static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
              solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
 {
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int nvarArr[NSTAGES] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10}; 
+    const solver_int neqArr[NSTAGES] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
+    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimpArr[NSTAGES] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
+    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
     *nvar = nvarArr[stage];
     *neq = neqArr[stage];
Index: model/FORCENLPsolver/include/FORCENLPsolver.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef FORCENLPsolver_H\n#define FORCENLPsolver_H\n/* Generated by FORCESPRO v5.1.0 on Sunday, February 27, 2022 at 3:20:14 PM */\n\n#ifndef SOLVER_STDIO_H\n#define SOLVER_STDIO_H\n#include <stdio.h>\n#include <stddef.h>\n#endif\n\n\n/* DATA TYPE ------------------------------------------------------------*/\ntypedef double FORCENLPsolver_float;\ntypedef double FORCENLPsolver_callback_float;\ntypedef double FORCENLPsolverinterface_float;\ntypedef int FORCENLPsolver_int;\n\n#ifndef SOLVER_STANDARD_TYPES\n#define SOLVER_STANDARD_TYPES\n\ntypedef signed char solver_int8_signed;\ntypedef unsigned char solver_int8_unsigned;\ntypedef char solver_int8_default;\ntypedef signed short int solver_int16_signed;\ntypedef unsigned short int solver_int16_unsigned;\ntypedef short int solver_int16_default;\ntypedef signed int solver_int32_signed;\ntypedef unsigned int solver_int32_unsigned;\ntypedef int solver_int32_default;\ntypedef signed long long int solver_int64_signed;\ntypedef unsigned long long int solver_int64_unsigned;\ntypedef long long int solver_int64_default;\n\n#endif\n\n/* SOLVER SETTINGS ------------------------------------------------------*/\n\n/* MISRA-C compliance */\n#ifndef MISRA_C_FORCENLPsolver\n#define MISRA_C_FORCENLPsolver (0)\n#endif\n\n/* restrict code */\n#ifndef RESTRICT_CODE_FORCENLPsolver\n#define RESTRICT_CODE_FORCENLPsolver (0)\n#endif\n\n/* print level */\n#ifndef SET_PRINTLEVEL_FORCENLPsolver\n#define SET_PRINTLEVEL_FORCENLPsolver    (0)\n#endif\n\n/* timing */\n#ifndef SET_TIMING_FORCENLPsolver\n#define SET_TIMING_FORCENLPsolver    (1)\n#endif\n\n/* Numeric Warnings */\n/* #define PRINTNUMERICALWARNINGS */\n\n/* maximum number of iterations  */\n#define SET_MAXIT_FORCENLPsolver\t\t\t(200)\t \n\n/* desired maximum residual on equality constraints */\n#define SET_ACC_RESEQ_FORCENLPsolver\t\t(FORCENLPsolver_float)(1E-06)\n\n\n/* RETURN CODES----------------------------------------------------------*/\n/* solver has converged within desired accuracy */\n#define OPTIMAL_FORCENLPsolver      (1)\n\n/* maximum number of iterations has been reached */\n#define MAXITREACHED_FORCENLPsolver (0)\n\n/* solver has stopped due to a timeout */\n#define TIMEOUT_FORCENLPsolver   (2)\n\n/* NaN encountered in function evaluations */\n#define BADFUNCEVAL_FORCENLPsolver  (-6)\n\n/* no progress in method possible */\n#define NOPROGRESS_FORCENLPsolver   (-7)\n\n/* regularization error */\n#define REGULARIZATION_ERROR_FORCENLPsolver   (-9)\n\n/* invalid values in parameters */\n#define PARAM_VALUE_ERROR_FORCENLPsolver   (-11)\n\n/* too small timeout given */\n#define INVALID_TIMEOUT_FORCENLPsolver   (-12)\n\n/* error in linesearch */\n#define LINESEARCH_ERROR_FORCENLPsolver   (-13)\n\n/* thread error */\n#define THREAD_FAILURE_FORCENLPsolver  (-98)\n\n/* locking mechanism error */\n#define LOCK_FAILURE_FORCENLPsolver  (-99)\n\n/* licensing error - solver not valid on this machine */\n#define LICENSE_ERROR_FORCENLPsolver  (-100)\n\n/* qp solver error */\n#define QP_SOLVER_FAILURE_FORCENLPsolver (-8)\n\n\n/* INTEGRATORS RETURN CODE ------------*/\n/* Integrator ran successfully */\n#define INTEGRATOR_SUCCESS (11)\n/* Number of steps set by user exceeds maximum number of steps allowed */\n#define INTEGRATOR_MAXSTEPS_EXCEEDED (12)\n\n/* PARAMETERS -----------------------------------------------------------*/\n/* fill this with data before calling the solver! */\ntypedef struct\n{\n\t    /* vector of size 3 */\n    FORCENLPsolver_float xinit[3];\n\n    /* vector of size 100 */\n    FORCENLPsolver_float x0[100];\n\n    /* vector of size 60 */\n    FORCENLPsolver_float all_parameters[60];\n\n    /* scalar */\n    FORCENLPsolver_int reinitialize;\n\n\n} FORCENLPsolver_params;\n\n\n/* OUTPUTS --------------------------------------------------------------*/\n/* the desired variables are put here by the solver */\ntypedef struct\n{\n\t    /* vector of size 5 */\n    FORCENLPsolver_float x01[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x02[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x03[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x04[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x05[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x06[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x07[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x08[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x09[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x10[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x11[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x12[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x13[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x14[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x15[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x16[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x17[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x18[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x19[5];\n\n    /* vector of size 5 */\n    FORCENLPsolver_float x20[5];\n\n\n} FORCENLPsolver_output;\n\n\n/* SOLVER INFO ----------------------------------------------------------*/\n/* diagnostic data from last interior point step */\ntypedef struct\n{\n\t/* iteration number */\n\tsolver_int32_default it;\n\n\t/* inf-norm of equality constraint residuals */\n\tFORCENLPsolver_float res_eq;\n\n\t/* norm of stationarity condition */\n\tFORCENLPsolver_float rsnorm;\n\n\t/* primal objective */\n\tFORCENLPsolver_float pobj;\n\n\t/* total solve time */\n\tFORCENLPsolver_float solvetime;\n\n\t/* time spent in function evaluations */\n\tFORCENLPsolver_float fevalstime;\n\n\t/* time spent solving QPs */\n\tFORCENLPsolver_float QPtime;\n} FORCENLPsolver_info;\n\n\n\n/* SOLVER FUNCTION DEFINITION -------------------------------------------*/\n/* Time of Solver Generation: (UTC) Sunday, February 27, 2022 3:20:15 PM */\n/* User License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) (at the time of code generation) */\n/* Solver Static License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) */\n/* Solver Generation Request Id: 01e671fa-06b0-47b4-9126-cea52adb939f */\n/* examine exitflag before using the result! */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\t\t\n\ntypedef void(*FORCENLPsolver_extfunc)(FORCENLPsolver_float* x, FORCENLPsolver_float* y, FORCENLPsolver_float* lambda, FORCENLPsolver_float* params, FORCENLPsolver_float* pobj, FORCENLPsolver_float* g, FORCENLPsolver_float* c, FORCENLPsolver_float* Jeq, FORCENLPsolver_float* h, FORCENLPsolver_float* Jineq, FORCENLPsolver_float* H, solver_int32_default stage, solver_int32_default iterations, solver_int32_default threadID);\n\nextern solver_int32_default FORCENLPsolver_solve(FORCENLPsolver_params *params, FORCENLPsolver_output *output, FORCENLPsolver_info *info, FILE *fs, FORCENLPsolver_extfunc evalextfunctions_FORCENLPsolver);\n\n\n\n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/include/FORCENLPsolver.h b/model/FORCENLPsolver/include/FORCENLPsolver.h
--- a/model/FORCENLPsolver/include/FORCENLPsolver.h	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/include/FORCENLPsolver.h	(date 1646039467400)
@@ -1,6 +1,6 @@
 #ifndef FORCENLPsolver_H
 #define FORCENLPsolver_H
-/* Generated by FORCESPRO v5.1.0 on Sunday, February 27, 2022 at 3:20:14 PM */
+/* Generated by FORCESPRO v5.1.0 on Monday, February 28, 2022 at 9:11:02 AM */
 
 #ifndef SOLVER_STDIO_H
 #define SOLVER_STDIO_H
@@ -116,8 +116,8 @@
 /* fill this with data before calling the solver! */
 typedef struct
 {
-	    /* vector of size 3 */
-    FORCENLPsolver_float xinit[3];
+	    /* vector of size 6 */
+    FORCENLPsolver_float xinit[6];
 
     /* vector of size 100 */
     FORCENLPsolver_float x0[100];
@@ -136,65 +136,35 @@
 /* the desired variables are put here by the solver */
 typedef struct
 {
-	    /* vector of size 5 */
-    FORCENLPsolver_float x01[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x02[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x03[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x04[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x05[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x06[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x07[5];
+	    /* vector of size 10 */
+    FORCENLPsolver_float x01[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x08[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x02[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x09[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x03[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x10[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x04[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x11[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x05[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x12[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x06[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x13[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x07[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x14[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x08[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x15[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x09[10];
 
-    /* vector of size 5 */
-    FORCENLPsolver_float x16[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x17[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x18[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x19[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x20[5];
+    /* vector of size 10 */
+    FORCENLPsolver_float x10[10];
 
 
 } FORCENLPsolver_output;
@@ -229,10 +199,10 @@
 
 
 /* SOLVER FUNCTION DEFINITION -------------------------------------------*/
-/* Time of Solver Generation: (UTC) Sunday, February 27, 2022 3:20:15 PM */
-/* User License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) (at the time of code generation) */
-/* Solver Static License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) */
-/* Solver Generation Request Id: 01e671fa-06b0-47b4-9126-cea52adb939f */
+/* Time of Solver Generation: (UTC) Monday, February 28, 2022 9:11:02 AM */
+/* User License expires on: (UTC) Wednesday, June 1, 2022 10:00:00 PM (approx.) (at the time of code generation) */
+/* Solver Static License expires on: (UTC) Wednesday, June 1, 2022 10:00:00 PM (approx.) */
+/* Solver Generation Request Id: 2fb2a8b3-3f4f-4020-b8cb-678d1ca0e45d */
 /* examine exitflag before using the result! */
 #ifdef __cplusplus
 extern "C" {
Index: model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nFORCENLPsolver : A fast customized optimization solver.\n\nCopyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.\n\n\nThis software is intended for simulation and testing purposes only. \nUse of this software for any commercial purpose is prohibited.\n\nThis program is distributed in the hope that it will be useful.\nEMBOTECH makes NO WARRANTIES with respect to the use of the software \nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. \n\nEMBOTECH shall not have any liability for any damage arising from the use\nof the software.\n\nThis Agreement shall exclusively be governed by and interpreted in \naccordance with the laws of Switzerland, excluding its principles\nof conflict of laws. The Courts of Zurich-City shall have exclusive \njurisdiction in case of any dispute.\n\n*/\n\n#include \"mex.h\"\n#include \"math.h\"\n#include <string.h>\n#include \"../include/FORCENLPsolver.h\"\n#ifndef SOLVER_STDIO_H\n#define SOLVER_STDIO_H\n#include <stdio.h>\n#endif\n\ntypedef FORCENLPsolver_float solver_float;\ntypedef solver_int32_default solver_int;\n#define NSTAGES ( 20 )\n#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))\n\n/* For compatibility with Microsoft Visual Studio 2015 */\n#if _MSC_VER >= 1900\nFILE _iob[3];\nFILE * __cdecl __iob_func(void)\n{\n\t_iob[0] = *stdin;\n\t_iob[1] = *stdout;\n\t_iob[2] = *stderr;\n\treturn _iob;\n}\n#endif\n\n/* copy functions */\n\nvoid copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (double)*src++;\n    }\n}\n\nvoid copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)\n{\n    *dest = (double)*src;\n}\n\nvoid copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) \n{\n    solver_int32_default i;\n    for( i = 0; i < dim; i++ ) \n    {\n        *dest++ = (FORCENLPsolver_float) (*src++) ;\n    }\n}\n\nvoid copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)\n{\n\t*dest = (FORCENLPsolver_float) *src;\n}\n\n\n\nextern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);\nFORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;\n\n\nstatic void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, \n             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)\n{\n    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; \n    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\n    *nvar = nvarArr[stage];\n    *neq = neqArr[stage];\n    *dimh = dimhArr[stage];\n    *dimp = dimpArr[stage];\n    *diml = dimlArr[stage];\n    *dimu = dimuArr[stage];\n    *dimhl = dimhlArr[stage];\n    *dimhu = dimhuArr[stage];\n}\n\n/* Checks all inputs and returns stage number (1-indexed) */\nstatic void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, \n                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)\n{\n    mxArray *arr;\n\n    if (nrhs > 3 || nrhs < 1)\n\t{\n\t\tmexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"This function takes at least one input: z. And at most 3 inputs: z, p, stage.\");\n\t}     \n\n    // get stage\n    *stage = (solver_int) 1;\n    if (nrhs == 3)\n    {\n        arr = prhs[2];\n        if ( !mxIsDouble(arr) )\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The third input (stage number) must be an integer.\");\n        }\n        *stage = (solver_int) *mxGetPr(arr);\n    }\n    if ( *stage < 1 || (NSTAGES) < *stage )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"Stage must be between %d and %d.\", 1, (NSTAGES));\n    }    \n\n    /* Get other dimensions */\n    *stage -= 1; /* 0-indexed stages */\n    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);\n\n    /* Check that passed z and p have correct dims */  \n    arr = prhs[0];\n    if ( !mxIsDouble(arr) )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The first input (z) must be a column vector.\");\n    }    \n    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )\n    {\n        mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The first input (z) must be a column vector of length %d.\", *nvar);\n    }\n    if (nrhs > 1)\n\t{\n        arr = prhs[1];\n        if ( *dimp > 0 && mxIsEmpty(arr))\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector of length %d.\", *dimp);\n        }   \n        if ( !mxIsEmpty(arr) )\n        {\n            if ( !mxIsDouble(arr) )\n            {\n                mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector.\");\n            }    \n            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )\n            {\n                mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"The second input (p) must be a column vector of length %d.\", *dimp);\n            }            \n        }\n\t}\n    else\n    {\n        if ( *dimp > 0 )\n        {\n            mexErrMsgIdAndTxt(\"FORCESPRO:IncorrectInputs\", \"Run time parameters are required as a second input for evaluating this fcn.\");\n        }         \n    } \n}\n\n/* THE mex-function */\nvoid mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  \n{\n\tmxArray *arr;\n    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;\n\n    // Allocate memory \n    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;\n\n\tmxArray* obj_mex;\n\tmxArray* gradobj_mex;\n\n\n    // get data\n    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);\n    dimmul = diml+dimu+dimhl+dimhu;\n\n    // Allocate memory \n    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));\n    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));\n    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));\n    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));\n    obj = (solver_float *) malloc(sizeof(solver_float));\n    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));\n    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));\n    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));\n    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));\n    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));\n    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));\n\n    /* Initialize all inputs */\n    arr = prhs[0];\n    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);\n    if (nrhs > 1)\n\t{\n        arr = prhs[1];\n        if ( !mxIsEmpty(arr) )\n        {\n            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);\n        }\n\t}   \n    memset(y, 0, sizeof(solver_float)*neq);\n    memset(l, 0, sizeof(solver_float)*dimmul);\n    memset(obj, 0, sizeof(solver_float));\n    memset(jacobj, 0, sizeof(solver_float)*nvar);\n    memset(c, 0, sizeof(solver_float)*neq);\n    memset(jacc, 0, sizeof(solver_float)*neq*nvar);\n    memset(h, 0, sizeof(solver_float)*dimh);\n    memset(jach, 0, sizeof(solver_float)*dimh*nvar);\n    memset(hess, 0, sizeof(solver_float)*nvar*nvar);\n\n    // Evaluate fcns and read output into mex format\n\t(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);\n\tobj_mex = mxCreateDoubleMatrix(1, 1, mxREAL);\n\tgradobj_mex = mxCreateDoubleMatrix(nvar, 1, mxREAL);\n\tcopyCArrayToM_FORCENLPsolver(obj, mxGetPr(obj_mex), 1);\n\tcopyCArrayToM_FORCENLPsolver(jacobj, mxGetPr(gradobj_mex), nvar);\n\tplhs[0] = obj_mex;\n\tplhs[1] = gradobj_mex;\n\n\n    // Free memory\n    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c	(revision 1a71c5f6903d0ca7b1b4f46431452250fa7b1bbb)
+++ b/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c	(date 1646039467396)
@@ -33,7 +33,7 @@
 
 typedef FORCENLPsolver_float solver_float;
 typedef solver_int32_default solver_int;
-#define NSTAGES ( 20 )
+#define NSTAGES ( 10 )
 #define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
 
 /* For compatibility with Microsoft Visual Studio 2015 */
@@ -87,14 +87,14 @@
 static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
              solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
 {
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int nvarArr[NSTAGES] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10}; 
+    const solver_int neqArr[NSTAGES] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
+    const solver_int dimhArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimpArr[NSTAGES] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
+    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimhlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
     *nvar = nvarArr[stage];
     *neq = neqArr[stage];
