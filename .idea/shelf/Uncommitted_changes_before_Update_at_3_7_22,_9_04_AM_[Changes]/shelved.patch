Index: model/FORCENLPsolver/interface/definitions.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/definitions.py b/model/FORCENLPsolver/interface/definitions.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/definitions.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,114 +0,0 @@
-import numpy
-import ctypes
-
-name = "FORCENLPsolver"
-requires_callback = True
-lib = "lib/FORCENLPsolver.dll"
-lib_static = "lib/FORCENLPsolver_static.lib"
-c_header = "include/FORCENLPsolver.h"
-nstages = 40
-
-# Parameter             | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
-params = \
-[("xinit"               , "dense" , ""               , ctypes.c_double, numpy.float64, (  3,   1),    3),
- ("x0"                  , "dense" , ""               , ctypes.c_double, numpy.float64, (200,   1),  200),
- ("all_parameters"      , "dense" , ""               , ctypes.c_double, numpy.float64, (120,   1),  120),
- ("reinitialize"        , ""      , "FORCENLPsolver_int", ctypes.c_int   , numpy.int32  , (  0,   1),    1)]
-
-# Output                | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
-outputs = \
-[("x01"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x02"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x03"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x04"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x05"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x06"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x07"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x08"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x09"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x10"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x11"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x12"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x13"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x14"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x15"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x16"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x17"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x18"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x19"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x20"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x21"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x22"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x23"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x24"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x25"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x26"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x27"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x28"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x29"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x30"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x31"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x32"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x33"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x34"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x35"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x36"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x37"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x38"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x39"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x40"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5)]
-
-# Info Struct Fields
-info = \
-[("it", ctypes.c_int),
- ("res_eq", ctypes.c_double),
- ("rsnorm", ctypes.c_double),
- ("pobj", ctypes.c_double),
- ("solvetime", ctypes.c_double),
- ("fevalstime", ctypes.c_double),
- ("QPtime", ctypes.c_double)]
-
-# Dynamics dimensions
-#   nvar    |   neq   |   dimh    |   dimp    |   diml    |   dimu    |   dimhl   |   dimhu    
-dynamics_dims = [
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0)
-]
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,739 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-
-#define S_FUNCTION_LEVEL 2
-#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlock
-
-#include "simstruc.h"
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* include FORCESPRO functions and defs */
-#include "../include/FORCENLPsolver.h" 
-
-/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */
-
-
-#if defined(MATLAB_MEX_FILE)
-#include "tmwtypes.h"
-#include "simstruc_types.h"
-#else
-#include "rtwtypes.h"
-#endif
-
-typedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;
-
-extern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-
-
-/*====================*
- * S-function methods *
- *====================*/
-/* Function: mdlInitializeSizes =========================================
- * Abstract:
- *   Setup sizes of the various vectors.
- */
-static void mdlInitializeSizes(SimStruct *S)
-{
-
-    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
-    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
-    ssSetNumSFcnParams(S, 0);
-    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
-	{
-		return; /* Parameter mismatch will be reported by Simulink */
-    }
-
-	/* initialize size of continuous and discrete states to zero */
-    ssSetNumContStates(S, 0);
-    ssSetNumDiscStates(S, 0);
-
-	/* initialize input ports - there are 4 in total */
-    if (!ssSetNumInputPorts(S, 4)) return;
-    	
-	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 3, 1);
-    ssSetInputPortDataType(S, 0, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
-	
-	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 200, 1);
-    ssSetInputPortDataType(S, 1, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/
-	
-	/* Input Port 2 */
-    ssSetInputPortMatrixDimensions(S,  2, 120, 1);
-    ssSetInputPortDataType(S, 2, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/
-	
-	/* Input Port 3 */
-    ssSetInputPortMatrixDimensions(S,  3, 1, 1);
-    ssSetInputPortDataType(S, 3, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/
- 
-
-
-	/* initialize output ports - there are 40 in total */
-    if (!ssSetNumOutputPorts(S, 40)) return;    
-		
-	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 5, 1);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 1 */
-    ssSetOutputPortMatrixDimensions(S,  1, 5, 1);
-    ssSetOutputPortDataType(S, 1, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 2 */
-    ssSetOutputPortMatrixDimensions(S,  2, 5, 1);
-    ssSetOutputPortDataType(S, 2, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 3 */
-    ssSetOutputPortMatrixDimensions(S,  3, 5, 1);
-    ssSetOutputPortDataType(S, 3, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 4 */
-    ssSetOutputPortMatrixDimensions(S,  4, 5, 1);
-    ssSetOutputPortDataType(S, 4, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 5 */
-    ssSetOutputPortMatrixDimensions(S,  5, 5, 1);
-    ssSetOutputPortDataType(S, 5, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 6 */
-    ssSetOutputPortMatrixDimensions(S,  6, 5, 1);
-    ssSetOutputPortDataType(S, 6, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 6, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 7 */
-    ssSetOutputPortMatrixDimensions(S,  7, 5, 1);
-    ssSetOutputPortDataType(S, 7, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 7, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 8 */
-    ssSetOutputPortMatrixDimensions(S,  8, 5, 1);
-    ssSetOutputPortDataType(S, 8, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 8, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 9 */
-    ssSetOutputPortMatrixDimensions(S,  9, 5, 1);
-    ssSetOutputPortDataType(S, 9, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 9, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 10 */
-    ssSetOutputPortMatrixDimensions(S,  10, 5, 1);
-    ssSetOutputPortDataType(S, 10, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 10, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 11 */
-    ssSetOutputPortMatrixDimensions(S,  11, 5, 1);
-    ssSetOutputPortDataType(S, 11, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 11, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 12 */
-    ssSetOutputPortMatrixDimensions(S,  12, 5, 1);
-    ssSetOutputPortDataType(S, 12, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 12, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 13 */
-    ssSetOutputPortMatrixDimensions(S,  13, 5, 1);
-    ssSetOutputPortDataType(S, 13, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 13, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 14 */
-    ssSetOutputPortMatrixDimensions(S,  14, 5, 1);
-    ssSetOutputPortDataType(S, 14, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 14, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 15 */
-    ssSetOutputPortMatrixDimensions(S,  15, 5, 1);
-    ssSetOutputPortDataType(S, 15, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 15, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 16 */
-    ssSetOutputPortMatrixDimensions(S,  16, 5, 1);
-    ssSetOutputPortDataType(S, 16, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 16, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 17 */
-    ssSetOutputPortMatrixDimensions(S,  17, 5, 1);
-    ssSetOutputPortDataType(S, 17, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 17, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 18 */
-    ssSetOutputPortMatrixDimensions(S,  18, 5, 1);
-    ssSetOutputPortDataType(S, 18, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 18, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 19 */
-    ssSetOutputPortMatrixDimensions(S,  19, 5, 1);
-    ssSetOutputPortDataType(S, 19, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 19, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 20 */
-    ssSetOutputPortMatrixDimensions(S,  20, 5, 1);
-    ssSetOutputPortDataType(S, 20, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 20, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 21 */
-    ssSetOutputPortMatrixDimensions(S,  21, 5, 1);
-    ssSetOutputPortDataType(S, 21, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 21, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 22 */
-    ssSetOutputPortMatrixDimensions(S,  22, 5, 1);
-    ssSetOutputPortDataType(S, 22, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 22, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 23 */
-    ssSetOutputPortMatrixDimensions(S,  23, 5, 1);
-    ssSetOutputPortDataType(S, 23, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 23, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 24 */
-    ssSetOutputPortMatrixDimensions(S,  24, 5, 1);
-    ssSetOutputPortDataType(S, 24, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 24, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 25 */
-    ssSetOutputPortMatrixDimensions(S,  25, 5, 1);
-    ssSetOutputPortDataType(S, 25, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 25, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 26 */
-    ssSetOutputPortMatrixDimensions(S,  26, 5, 1);
-    ssSetOutputPortDataType(S, 26, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 26, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 27 */
-    ssSetOutputPortMatrixDimensions(S,  27, 5, 1);
-    ssSetOutputPortDataType(S, 27, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 27, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 28 */
-    ssSetOutputPortMatrixDimensions(S,  28, 5, 1);
-    ssSetOutputPortDataType(S, 28, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 28, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 29 */
-    ssSetOutputPortMatrixDimensions(S,  29, 5, 1);
-    ssSetOutputPortDataType(S, 29, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 29, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 30 */
-    ssSetOutputPortMatrixDimensions(S,  30, 5, 1);
-    ssSetOutputPortDataType(S, 30, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 30, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 31 */
-    ssSetOutputPortMatrixDimensions(S,  31, 5, 1);
-    ssSetOutputPortDataType(S, 31, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 31, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 32 */
-    ssSetOutputPortMatrixDimensions(S,  32, 5, 1);
-    ssSetOutputPortDataType(S, 32, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 32, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 33 */
-    ssSetOutputPortMatrixDimensions(S,  33, 5, 1);
-    ssSetOutputPortDataType(S, 33, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 33, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 34 */
-    ssSetOutputPortMatrixDimensions(S,  34, 5, 1);
-    ssSetOutputPortDataType(S, 34, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 34, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 35 */
-    ssSetOutputPortMatrixDimensions(S,  35, 5, 1);
-    ssSetOutputPortDataType(S, 35, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 35, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 36 */
-    ssSetOutputPortMatrixDimensions(S,  36, 5, 1);
-    ssSetOutputPortDataType(S, 36, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 36, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 37 */
-    ssSetOutputPortMatrixDimensions(S,  37, 5, 1);
-    ssSetOutputPortDataType(S, 37, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 37, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 38 */
-    ssSetOutputPortMatrixDimensions(S,  38, 5, 1);
-    ssSetOutputPortDataType(S, 38, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 38, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 39 */
-    ssSetOutputPortMatrixDimensions(S,  39, 5, 1);
-    ssSetOutputPortDataType(S, 39, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 39, COMPLEX_NO); /* no complex signals suppported */
-
-
-	/* set sampling time */
-    ssSetNumSampleTimes(S, 1);
-
-	/* set internal memory of block */
-    ssSetNumRWork(S, 0);
-    ssSetNumIWork(S, 0);
-    ssSetNumPWork(S, 0);
-    ssSetNumModes(S, 0);
-    ssSetNumNonsampledZCs(S, 0);
-
-    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
-		             SS_OPTION_WORKS_WITH_CODE_REUSE)); */
-	ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );
-
-	
-}
-
-#if defined(MATLAB_MEX_FILE)
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-static void mdlSetInputPortDimensionInfo(SimStruct        *S, 
-                                         int_T            port,
-                                         const DimsInfo_T *dimsInfo)
-{
-    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)
-static void mdlSetOutputPortDimensionInfo(SimStruct        *S, 
-                                          int_T            port, 
-                                          const DimsInfo_T *dimsInfo)
-{
-    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-# define MDL_SET_INPUT_PORT_FRAME_DATA
-static void mdlSetInputPortFrameData(SimStruct  *S, 
-                                     int_T      port,
-                                     Frame_T    frameData)
-{
-    ssSetInputPortFrameData(S, port, frameData);
-}
-/* Function: mdlInitializeSampleTimes =========================================
- * Abstract:
- *    Specifiy  the sample time.
- */
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
-    ssSetOffsetTime(S, 0, 0.0);
-}
-
-#define MDL_SET_INPUT_PORT_DATA_TYPE
-static void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetInputPortDataType( S, 0, dType);
-}
-#define MDL_SET_OUTPUT_PORT_DATA_TYPE
-static void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetOutputPortDataType(S, 0, dType);
-}
-
-#define MDL_SET_DEFAULT_PORT_DATA_TYPES
-static void mdlSetDefaultPortDataTypes(SimStruct *S)
-{
-    ssSetInputPortDataType( S, 0, SS_DOUBLE);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-}
-
-
-
-
-
-/* Function: mdlOutputs =======================================================
- *
-*/
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	solver_int32_default i, j, k;
-	
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* Simulink data */
-	const real_T *xinit = (const real_T*) ssGetInputPortSignal(S,0);
-	const real_T *x0 = (const real_T*) ssGetInputPortSignal(S,1);
-	const real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,2);
-	const FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,3);
-	
-    real_T *x01 = (real_T*) ssGetOutputPortSignal(S,0);
-	real_T *x02 = (real_T*) ssGetOutputPortSignal(S,1);
-	real_T *x03 = (real_T*) ssGetOutputPortSignal(S,2);
-	real_T *x04 = (real_T*) ssGetOutputPortSignal(S,3);
-	real_T *x05 = (real_T*) ssGetOutputPortSignal(S,4);
-	real_T *x06 = (real_T*) ssGetOutputPortSignal(S,5);
-	real_T *x07 = (real_T*) ssGetOutputPortSignal(S,6);
-	real_T *x08 = (real_T*) ssGetOutputPortSignal(S,7);
-	real_T *x09 = (real_T*) ssGetOutputPortSignal(S,8);
-	real_T *x10 = (real_T*) ssGetOutputPortSignal(S,9);
-	real_T *x11 = (real_T*) ssGetOutputPortSignal(S,10);
-	real_T *x12 = (real_T*) ssGetOutputPortSignal(S,11);
-	real_T *x13 = (real_T*) ssGetOutputPortSignal(S,12);
-	real_T *x14 = (real_T*) ssGetOutputPortSignal(S,13);
-	real_T *x15 = (real_T*) ssGetOutputPortSignal(S,14);
-	real_T *x16 = (real_T*) ssGetOutputPortSignal(S,15);
-	real_T *x17 = (real_T*) ssGetOutputPortSignal(S,16);
-	real_T *x18 = (real_T*) ssGetOutputPortSignal(S,17);
-	real_T *x19 = (real_T*) ssGetOutputPortSignal(S,18);
-	real_T *x20 = (real_T*) ssGetOutputPortSignal(S,19);
-	real_T *x21 = (real_T*) ssGetOutputPortSignal(S,20);
-	real_T *x22 = (real_T*) ssGetOutputPortSignal(S,21);
-	real_T *x23 = (real_T*) ssGetOutputPortSignal(S,22);
-	real_T *x24 = (real_T*) ssGetOutputPortSignal(S,23);
-	real_T *x25 = (real_T*) ssGetOutputPortSignal(S,24);
-	real_T *x26 = (real_T*) ssGetOutputPortSignal(S,25);
-	real_T *x27 = (real_T*) ssGetOutputPortSignal(S,26);
-	real_T *x28 = (real_T*) ssGetOutputPortSignal(S,27);
-	real_T *x29 = (real_T*) ssGetOutputPortSignal(S,28);
-	real_T *x30 = (real_T*) ssGetOutputPortSignal(S,29);
-	real_T *x31 = (real_T*) ssGetOutputPortSignal(S,30);
-	real_T *x32 = (real_T*) ssGetOutputPortSignal(S,31);
-	real_T *x33 = (real_T*) ssGetOutputPortSignal(S,32);
-	real_T *x34 = (real_T*) ssGetOutputPortSignal(S,33);
-	real_T *x35 = (real_T*) ssGetOutputPortSignal(S,34);
-	real_T *x36 = (real_T*) ssGetOutputPortSignal(S,35);
-	real_T *x37 = (real_T*) ssGetOutputPortSignal(S,36);
-	real_T *x38 = (real_T*) ssGetOutputPortSignal(S,37);
-	real_T *x39 = (real_T*) ssGetOutputPortSignal(S,38);
-	real_T *x40 = (real_T*) ssGetOutputPortSignal(S,39);
-	
-	
-
-	/* Solver data */
-	static FORCENLPsolver_params params;
-	static FORCENLPsolver_output output;
-	static FORCENLPsolver_info info;	
-	solver_int32_default exitflag;
-
-	/* Extra NMPC data */
-	
-
-	/* Copy inputs */
-	for( i=0; i<3; i++)
-	{ 
-		params.xinit[i] = (double) xinit[i]; 
-	}
-
-	for( i=0; i<200; i++)
-	{ 
-		params.x0[i] = (double) x0[i]; 
-	}
-
-	for( i=0; i<120; i++)
-	{ 
-		params.all_parameters[i] = (double) all_parameters[i]; 
-	}
-
-	params.reinitialize = *reinitialize;
-
-	
-
-	
-
-    #if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* Call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			ssPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	
-
-	/* Copy outputs */
-	for( i=0; i<5; i++)
-	{ 
-		x01[i] = (real_T) output.x01[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x02[i] = (real_T) output.x02[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x03[i] = (real_T) output.x03[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x04[i] = (real_T) output.x04[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x05[i] = (real_T) output.x05[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x06[i] = (real_T) output.x06[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x07[i] = (real_T) output.x07[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x08[i] = (real_T) output.x08[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x09[i] = (real_T) output.x09[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x10[i] = (real_T) output.x10[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x11[i] = (real_T) output.x11[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x12[i] = (real_T) output.x12[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x13[i] = (real_T) output.x13[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x14[i] = (real_T) output.x14[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x15[i] = (real_T) output.x15[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x16[i] = (real_T) output.x16[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x17[i] = (real_T) output.x17[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x18[i] = (real_T) output.x18[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x19[i] = (real_T) output.x19[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x20[i] = (real_T) output.x20[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x21[i] = (real_T) output.x21[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x22[i] = (real_T) output.x22[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x23[i] = (real_T) output.x23[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x24[i] = (real_T) output.x24[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x25[i] = (real_T) output.x25[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x26[i] = (real_T) output.x26[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x27[i] = (real_T) output.x27[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x28[i] = (real_T) output.x28[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x29[i] = (real_T) output.x29[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x30[i] = (real_T) output.x30[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x31[i] = (real_T) output.x31[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x32[i] = (real_T) output.x32[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x33[i] = (real_T) output.x33[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x34[i] = (real_T) output.x34[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x35[i] = (real_T) output.x35[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x36[i] = (real_T) output.x36[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x37[i] = (real_T) output.x37[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x38[i] = (real_T) output.x38[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x39[i] = (real_T) output.x39[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x40[i] = (real_T) output.x40[i]; 
-	}
-
-	
-}
-
-
-
-
-
-/* Function: mdlTerminate =====================================================
- * Abstract:
- *    In this function, you should perform any actions that are necessary
- *    at the termination of a simulation.  For example, if memory was
- *    allocated in mdlStart, this is the place to free it.
- */
-static void mdlTerminate(SimStruct *S)
-{
-}
-#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
-#include "simulink.c"      /* MEX-file interface mechanism */
-#else
-#include "cg_sfun.h"       /* Code generation registration function */
-#endif
-
-
Index: model/FORCENLPsolver/FORCENLPsolver_model.c
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_model.c b/model/FORCENLPsolver/FORCENLPsolver_model.c
deleted file mode 100644
--- a/model/FORCENLPsolver/FORCENLPsolver_model.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,1195 +0,0 @@
-/* This file was automatically generated by CasADi.
-   The CasADi copyright holders make no ownership claim of its contents. */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* How to prefix internal symbols */
-#ifdef CASADI_CODEGEN_PREFIX
-  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
-  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
-  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
-#else
-  #define CASADI_PREFIX(ID) FORCENLPsolver_model_ ## ID
-#endif
-
-#include <math.h> 
-#include "FORCENLPsolver_model.h"
-
-#ifndef casadi_real
-#define casadi_real FORCENLPsolver_float
-#endif
-
-#ifndef casadi_int
-#define casadi_int solver_int32_default
-#endif
-
-/* Add prefix to internal symbols */
-#define casadi_f0 CASADI_PREFIX(f0)
-#define casadi_f1 CASADI_PREFIX(f1)
-#define casadi_f2 CASADI_PREFIX(f2)
-#define casadi_f3 CASADI_PREFIX(f3)
-#define casadi_f4 CASADI_PREFIX(f4)
-#define casadi_f5 CASADI_PREFIX(f5)
-#define casadi_f6 CASADI_PREFIX(f6)
-#define casadi_f7 CASADI_PREFIX(f7)
-#define casadi_f8 CASADI_PREFIX(f8)
-#define casadi_f9 CASADI_PREFIX(f9)
-#define casadi_s0 CASADI_PREFIX(s0)
-#define casadi_s1 CASADI_PREFIX(s1)
-#define casadi_s2 CASADI_PREFIX(s2)
-#define casadi_s3 CASADI_PREFIX(s3)
-#define casadi_s4 CASADI_PREFIX(s4)
-#define casadi_s5 CASADI_PREFIX(s5)
-#define casadi_s6 CASADI_PREFIX(s6)
-#define casadi_sq CASADI_PREFIX(sq)
-
-/* Symbol visibility in DLLs */
-#if 0
-  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-    #if defined(STATIC_LINKED)
-      #define CASADI_SYMBOL_EXPORT
-    #else
-      #define __declspec(dllexport)
-    #endif
-  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-    #define __attribute__ ((visibility ("default")))
-  #else
-    #define CASADI_SYMBOL_EXPORT
-  #endif
-#endif
-
-casadi_real casadi_sq(casadi_real x) { return x*x;}
-
-static const casadi_int casadi_s0[9] = {5, 1, 0, 5, 0, 1, 2, 3, 4};
-static const casadi_int casadi_s1[7] = {3, 1, 0, 3, 0, 1, 2};
-static const casadi_int casadi_s2[5] = {1, 1, 0, 1, 0};
-static const casadi_int casadi_s3[12] = {1, 5, 0, 1, 2, 3, 4, 4, 0, 0, 0, 0};
-static const casadi_int casadi_s4[18] = {3, 5, 0, 2, 5, 6, 7, 10, 0, 1, 0, 1, 2, 0, 1, 0, 1, 2};
-static const casadi_int casadi_s5[10] = {1, 5, 0, 0, 0, 1, 2, 2, 0, 0};
-static const casadi_int casadi_s6[13] = {1, 5, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0};
-
-/* FORCENLPsolver_objective_0:(i0[5],i1[3])->(o0) */
-static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
-  a0=100.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a3=(a3*a1);
-  a1=arg[0]? arg[0][3] : 0;
-  a2=arg[1]? arg[1][1] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=casadi_sq(a1);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][1] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][0]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f0(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_objective_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_objective_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_objective_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_0_release(int mem) {
-}
-
-void FORCENLPsolver_objective_0_incref(void) {
-}
-
-void FORCENLPsolver_objective_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_objective_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_objective_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_objective_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dobjective_0:(i0[5],i1[3])->(o0[1x5,4nz]) */
-static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][0]=a1;
-  a1=arg[0]? arg[0][1] : 0;
-  a1=(a1+a1);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=100.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  a3=arg[0]? arg[0][3] : 0;
-  a1=arg[1]? arg[1][1] : 0;
-  a2=(a3-a1);
-  a2=(a0*a2);
-  a3=(a3-a1);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][3]=a2;
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f1(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dobjective_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dobjective_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_0_release(int mem) {
-}
-
-void FORCENLPsolver_dobjective_0_incref(void) {
-}
-
-void FORCENLPsolver_dobjective_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dobjective_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dobjective_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dobjective_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s3;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dynamics_0:(i0[5],i1[3])->(o0[3]) */
-static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a2, a3, a4, a5, a6, a7, a8, a9;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=8.3333333333333339e-004;
-  a2=arg[0]? arg[0][0] : 0;
-  a3=arg[0]? arg[0][4] : 0;
-  a4=cos(a3);
-  a4=(a2*a4);
-  a5=2.;
-  a6=2.5000000000000001e-003;
-  a7=arg[0]? arg[0][1] : 0;
-  a8=(a6*a7);
-  a8=(a3+a8);
-  a9=cos(a8);
-  a9=(a2*a9);
-  a9=(a5*a9);
-  a4=(a4+a9);
-  a6=(a6*a7);
-  a6=(a3+a6);
-  a9=cos(a6);
-  a9=(a2*a9);
-  a9=(a5*a9);
-  a4=(a4+a9);
-  a9=5.0000000000000001e-003;
-  a9=(a9*a7);
-  a9=(a3+a9);
-  a10=cos(a9);
-  a10=(a2*a10);
-  a4=(a4+a10);
-  a4=(a1*a4);
-  a0=(a0+a4);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
-  a4=sin(a3);
-  a4=(a2*a4);
-  a8=sin(a8);
-  a8=(a2*a8);
-  a8=(a5*a8);
-  a4=(a4+a8);
-  a6=sin(a6);
-  a6=(a2*a6);
-  a6=(a5*a6);
-  a4=(a4+a6);
-  a9=sin(a9);
-  a2=(a2*a9);
-  a4=(a4+a2);
-  a4=(a1*a4);
-  a0=(a0+a4);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=(a5*a7);
-  a0=(a7+a0);
-  a5=(a5*a7);
-  a0=(a0+a5);
-  a0=(a0+a7);
-  a1=(a1*a0);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f2(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dynamics_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dynamics_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dynamics_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dynamics_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dynamics_0_release(int mem) {
-}
-
-void FORCENLPsolver_dynamics_0_incref(void) {
-}
-
-void FORCENLPsolver_dynamics_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dynamics_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dynamics_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dynamics_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dynamics_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dynamics_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s1;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_ddynamics_0:(i0[5],i1[3])->(o0[3x5,10nz]) */
-static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a11, a12, a13, a2, a3, a4, a5, a6, a7, a8, a9;
-  a0=8.3333333333333339e-004;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=cos(a1);
-  a3=2.;
-  a4=2.5000000000000001e-003;
-  a5=arg[0]? arg[0][1] : 0;
-  a6=(a4*a5);
-  a6=(a1+a6);
-  a7=cos(a6);
-  a7=(a3*a7);
-  a2=(a2+a7);
-  a7=(a4*a5);
-  a7=(a1+a7);
-  a8=cos(a7);
-  a8=(a3*a8);
-  a2=(a2+a8);
-  a8=5.0000000000000001e-003;
-  a5=(a8*a5);
-  a5=(a1+a5);
-  a9=cos(a5);
-  a2=(a2+a9);
-  a2=(a0*a2);
-  if (res[0]!=0) res[0][0]=a2;
-  a2=sin(a1);
-  a9=sin(a6);
-  a9=(a3*a9);
-  a2=(a2+a9);
-  a9=sin(a7);
-  a9=(a3*a9);
-  a2=(a2+a9);
-  a9=sin(a5);
-  a2=(a2+a9);
-  a2=(a0*a2);
-  if (res[0]!=0) res[0][1]=a2;
-  a2=arg[0]? arg[0][0] : 0;
-  a9=sin(a6);
-  a10=(a4*a9);
-  a10=(a2*a10);
-  a10=(a3*a10);
-  a11=sin(a7);
-  a12=(a4*a11);
-  a12=(a2*a12);
-  a12=(a3*a12);
-  a10=(a10+a12);
-  a12=sin(a5);
-  a13=(a8*a12);
-  a13=(a2*a13);
-  a10=(a10+a13);
-  a10=(a0*a10);
-  a10=(-a10);
-  if (res[0]!=0) res[0][2]=a10;
-  a6=cos(a6);
-  a10=(a4*a6);
-  a10=(a2*a10);
-  a10=(a3*a10);
-  a7=cos(a7);
-  a4=(a4*a7);
-  a4=(a2*a4);
-  a4=(a3*a4);
-  a10=(a10+a4);
-  a5=cos(a5);
-  a4=(a8*a5);
-  a4=(a2*a4);
-  a10=(a10+a4);
-  a10=(a0*a10);
-  if (res[0]!=0) res[0][3]=a10;
-  if (res[0]!=0) res[0][4]=a8;
-  a8=1.;
-  if (res[0]!=0) res[0][5]=a8;
-  if (res[0]!=0) res[0][6]=a8;
-  a10=sin(a1);
-  a10=(a2*a10);
-  a9=(a2*a9);
-  a9=(a3*a9);
-  a10=(a10+a9);
-  a11=(a2*a11);
-  a11=(a3*a11);
-  a10=(a10+a11);
-  a12=(a2*a12);
-  a10=(a10+a12);
-  a10=(a0*a10);
-  a10=(-a10);
-  if (res[0]!=0) res[0][7]=a10;
-  a1=cos(a1);
-  a1=(a2*a1);
-  a6=(a2*a6);
-  a6=(a3*a6);
-  a1=(a1+a6);
-  a7=(a2*a7);
-  a3=(a3*a7);
-  a1=(a1+a3);
-  a2=(a2*a5);
-  a1=(a1+a2);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][8]=a0;
-  if (res[0]!=0) res[0][9]=a8;
-  return 0;
-}
-
-int FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f3(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_ddynamics_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_ddynamics_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_ddynamics_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_ddynamics_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_ddynamics_0_release(int mem) {
-}
-
-void FORCENLPsolver_ddynamics_0_incref(void) {
-}
-
-void FORCENLPsolver_ddynamics_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_ddynamics_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_ddynamics_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_ddynamics_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_ddynamics_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_ddynamics_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s4;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_inequalities_0:(i0[5],i1[3])->(o0) */
-static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=casadi_sq(a0);
-  a1=arg[0]? arg[0][3] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][0]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f4(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_inequalities_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_inequalities_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_0_release(int mem) {
-}
-
-void FORCENLPsolver_inequalities_0_incref(void) {
-}
-
-void FORCENLPsolver_inequalities_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_inequalities_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_inequalities_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_inequalities_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_inequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dinequalities_0:(i0[5],i1[3])->(o0[1x5,2nz]) */
-static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][1]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f5(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dinequalities_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dinequalities_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_0_release(int mem) {
-}
-
-void FORCENLPsolver_dinequalities_0_incref(void) {
-}
-
-void FORCENLPsolver_dinequalities_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dinequalities_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dinequalities_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dinequalities_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s5;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dinequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_objective_1:(i0[5],i1[3])->(o0) */
-static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
-  a0=500.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a3=(a3*a1);
-  a1=arg[0]? arg[0][3] : 0;
-  a2=arg[1]? arg[1][1] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=arg[1]? arg[1][2] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=casadi_sq(a1);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][1] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][0]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f6(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_objective_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_objective_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_objective_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_1_release(int mem) {
-}
-
-void FORCENLPsolver_objective_1_incref(void) {
-}
-
-void FORCENLPsolver_objective_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_objective_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_objective_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_objective_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dobjective_1:(i0[5],i1[3])->(o0[1x5]) */
-static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][0]=a1;
-  a1=arg[0]? arg[0][1] : 0;
-  a1=(a1+a1);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=500.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  a3=arg[0]? arg[0][3] : 0;
-  a1=arg[1]? arg[1][1] : 0;
-  a2=(a3-a1);
-  a2=(a0*a2);
-  a3=(a3-a1);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][3]=a2;
-  a2=100.;
-  a0=arg[0]? arg[0][4] : 0;
-  a3=arg[1]? arg[1][2] : 0;
-  a1=(a0-a3);
-  a1=(a2*a1);
-  a0=(a0-a3);
-  a2=(a2*a0);
-  a1=(a1+a2);
-  if (res[0]!=0) res[0][4]=a1;
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f7(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dobjective_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dobjective_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_1_release(int mem) {
-}
-
-void FORCENLPsolver_dobjective_1_incref(void) {
-}
-
-void FORCENLPsolver_dobjective_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dobjective_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dobjective_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dobjective_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s6;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_inequalities_1:(i0[5],i1[3])->(o0) */
-static int casadi_f8(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=casadi_sq(a0);
-  a1=arg[0]? arg[0][3] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][0]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f8(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_inequalities_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_inequalities_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_1_release(int mem) {
-}
-
-void FORCENLPsolver_inequalities_1_incref(void) {
-}
-
-void FORCENLPsolver_inequalities_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_inequalities_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_inequalities_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_inequalities_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_inequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dinequalities_1:(i0[5],i1[3])->(o0[1x5,2nz]) */
-static int casadi_f9(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][1]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f9(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dinequalities_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dinequalities_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_1_release(int mem) {
-}
-
-void FORCENLPsolver_dinequalities_1_incref(void) {
-}
-
-void FORCENLPsolver_dinequalities_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dinequalities_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dinequalities_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dinequalities_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s5;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dinequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
Index: FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c b/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17}; 
-    const solver_int neqArr[NSTAGES] = {13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
-    const solver_int dimlArr[NSTAGES] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-    const solver_int dimuArr[NSTAGES] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* obj_mex;
-	mxArray* gradobj_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	obj_mex = mxCreateDoubleMatrix(1, 1, mxREAL);
-	gradobj_mex = mxCreateDoubleMatrix(nvar, 1, mxREAL);
-	copyCArrayToM_FORCENLPsolver(obj, mxGetPr(obj_mex), 1);
-	copyCArrayToM_FORCENLPsolver(jacobj, mxGetPr(gradobj_mex), nvar);
-	plhs[0] = obj_mex;
-	plhs[1] = gradobj_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: FORCENLPsolver/interface/FORCENLPsolver_py.py
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_py.py b/FORCENLPsolver/interface/FORCENLPsolver_py.py
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_py.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,424 +0,0 @@
-#FORCENLPsolver : A fast customized optimization solver.
-#
-#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-#
-#
-#This software is intended for simulation and testing purposes only. 
-#Use of this software for any commercial purpose is prohibited.
-#
-#This program is distributed in the hope that it will be useful.
-#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-#PARTICULAR PURPOSE. 
-#
-#EMBOTECH shall not have any liability for any damage arising from the use
-#of the software.
-#
-#This Agreement shall exclusively be governed by and interpreted in 
-#accordance with the laws of Switzerland, excluding its principles
-#of conflict of laws. The Courts of Zurich-City shall have exclusive 
-#jurisdiction in case of any dispute.
-#
-#def __init__():
-'''
-a Python wrapper for a fast solver generated by FORCESPRO v5.1.0
-
-   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
-   subject to the parameters supplied in the following dictionary:
-       PARAMS['lb'] - column vector of length 160
-       PARAMS['ub'] - column vector of length 160
-       PARAMS['xinit'] - column vector of length 13
-       PARAMS['x0'] - column vector of length 680
-       PARAMS['all_parameters'] - column vector of length 360
-       PARAMS['reinitialize'] - scalar
-
-   OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 17
-       OUTPUT['x02'] - column vector of size 17
-       OUTPUT['x03'] - column vector of size 17
-       OUTPUT['x04'] - column vector of size 17
-       OUTPUT['x05'] - column vector of size 17
-       OUTPUT['x06'] - column vector of size 17
-       OUTPUT['x07'] - column vector of size 17
-       OUTPUT['x08'] - column vector of size 17
-       OUTPUT['x09'] - column vector of size 17
-       OUTPUT['x10'] - column vector of size 17
-       OUTPUT['x11'] - column vector of size 17
-       OUTPUT['x12'] - column vector of size 17
-       OUTPUT['x13'] - column vector of size 17
-       OUTPUT['x14'] - column vector of size 17
-       OUTPUT['x15'] - column vector of size 17
-       OUTPUT['x16'] - column vector of size 17
-       OUTPUT['x17'] - column vector of size 17
-       OUTPUT['x18'] - column vector of size 17
-       OUTPUT['x19'] - column vector of size 17
-       OUTPUT['x20'] - column vector of size 17
-       OUTPUT['x21'] - column vector of size 17
-       OUTPUT['x22'] - column vector of size 17
-       OUTPUT['x23'] - column vector of size 17
-       OUTPUT['x24'] - column vector of size 17
-       OUTPUT['x25'] - column vector of size 17
-       OUTPUT['x26'] - column vector of size 17
-       OUTPUT['x27'] - column vector of size 17
-       OUTPUT['x28'] - column vector of size 17
-       OUTPUT['x29'] - column vector of size 17
-       OUTPUT['x30'] - column vector of size 17
-       OUTPUT['x31'] - column vector of size 17
-       OUTPUT['x32'] - column vector of size 17
-       OUTPUT['x33'] - column vector of size 17
-       OUTPUT['x34'] - column vector of size 17
-       OUTPUT['x35'] - column vector of size 17
-       OUTPUT['x36'] - column vector of size 17
-       OUTPUT['x37'] - column vector of size 17
-       OUTPUT['x38'] - column vector of size 17
-       OUTPUT['x39'] - column vector of size 17
-       OUTPUT['x40'] - column vector of size 17
-
-   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
-   the integer EXITFLAG indicating the state of the solution with 
-       1 - Optimal solution has been found (subject to desired accuracy)
-       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
-       0 - Timeout - maximum number of iterations reached
-      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
-      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
-      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
-      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
-     -10 - The convex solver could not proceed due to an internal error
-    -100 - License error
-
-   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns 
-   additional information about the last iterate:
-       INFO.it        - number of iterations that lead to this result
-       INFO.it2opt    - number of convex solves
-       INFO.res_eq    - max. equality constraint residual
-       INFO.res_ineq  - max. inequality constraint residual
-       INFO.pobj      - primal objective
-       INFO.dobj      - dual objective
-       INFO.dgap      - duality gap := pobj - dobj
-       INFO.rdgap     - relative duality gap := |dgap / pobj|
-       INFO.mu        - duality measure
-       INFO.sigma     - centering parameter
-       INFO.lsit_aff  - iterations of affine line search
-       INFO.lsit_cc   - iterations of line search (combined direction)
-       INFO.step_aff  - step size (affine direction)
-       INFO.step_cc   - step size (centering direction)
-       INFO.solvetime - Time needed for solve (wall clock time)
-
- See also COPYING
-
-'''
-
-import ctypes
-import os
-import numpy as np
-import numpy.ctypeslib as npct
-import sys
-
-#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'FORCENLPsolver/lib/FORCENLPsolver.so')) 
-try:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/FORCENLPsolver.so'))
-    csolver = getattr(_lib,'FORCENLPsolver_solve')
-except:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/libFORCENLPsolver.so'))
-    csolver = getattr(_lib,'FORCENLPsolver_solve')
-
-class FORCENLPsolver_params_ctypes(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [('lb', ctypes.c_double * 160),
-('ub', ctypes.c_double * 160),
-('xinit', ctypes.c_double * 13),
-('x0', ctypes.c_double * 680),
-('all_parameters', ctypes.c_double * 360),
-('reinitialize', ctypes.c_int),
-]
-
-FORCENLPsolver_params = {'lb' : np.array([]),
-'ub' : np.array([]),
-'xinit' : np.array([]),
-'x0' : np.array([]),
-'all_parameters' : np.array([]),
-'reinitialize' : np.array([]),
-}
-params = {'lb' : np.array([]),
-'ub' : np.array([]),
-'xinit' : np.array([]),
-'x0' : np.array([]),
-'all_parameters' : np.array([]),
-'reinitialize' : np.array([]),
-}
-FORCENLPsolver_params_types = {'lb' : np.float64,
-'ub' : np.float64,
-'xinit' : np.float64,
-'x0' : np.float64,
-'all_parameters' : np.float64,
-'reinitialize' : np.int32,
-}
-
-class FORCENLPsolver_outputs_ctypes(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [('x01', ctypes.c_double * 17),
-('x02', ctypes.c_double * 17),
-('x03', ctypes.c_double * 17),
-('x04', ctypes.c_double * 17),
-('x05', ctypes.c_double * 17),
-('x06', ctypes.c_double * 17),
-('x07', ctypes.c_double * 17),
-('x08', ctypes.c_double * 17),
-('x09', ctypes.c_double * 17),
-('x10', ctypes.c_double * 17),
-('x11', ctypes.c_double * 17),
-('x12', ctypes.c_double * 17),
-('x13', ctypes.c_double * 17),
-('x14', ctypes.c_double * 17),
-('x15', ctypes.c_double * 17),
-('x16', ctypes.c_double * 17),
-('x17', ctypes.c_double * 17),
-('x18', ctypes.c_double * 17),
-('x19', ctypes.c_double * 17),
-('x20', ctypes.c_double * 17),
-('x21', ctypes.c_double * 17),
-('x22', ctypes.c_double * 17),
-('x23', ctypes.c_double * 17),
-('x24', ctypes.c_double * 17),
-('x25', ctypes.c_double * 17),
-('x26', ctypes.c_double * 17),
-('x27', ctypes.c_double * 17),
-('x28', ctypes.c_double * 17),
-('x29', ctypes.c_double * 17),
-('x30', ctypes.c_double * 17),
-('x31', ctypes.c_double * 17),
-('x32', ctypes.c_double * 17),
-('x33', ctypes.c_double * 17),
-('x34', ctypes.c_double * 17),
-('x35', ctypes.c_double * 17),
-('x36', ctypes.c_double * 17),
-('x37', ctypes.c_double * 17),
-('x38', ctypes.c_double * 17),
-('x39', ctypes.c_double * 17),
-('x40', ctypes.c_double * 17),
-]
-
-FORCENLPsolver_outputs = {'x01' : np.array([]),
-'x02' : np.array([]),
-'x03' : np.array([]),
-'x04' : np.array([]),
-'x05' : np.array([]),
-'x06' : np.array([]),
-'x07' : np.array([]),
-'x08' : np.array([]),
-'x09' : np.array([]),
-'x10' : np.array([]),
-'x11' : np.array([]),
-'x12' : np.array([]),
-'x13' : np.array([]),
-'x14' : np.array([]),
-'x15' : np.array([]),
-'x16' : np.array([]),
-'x17' : np.array([]),
-'x18' : np.array([]),
-'x19' : np.array([]),
-'x20' : np.array([]),
-'x21' : np.array([]),
-'x22' : np.array([]),
-'x23' : np.array([]),
-'x24' : np.array([]),
-'x25' : np.array([]),
-'x26' : np.array([]),
-'x27' : np.array([]),
-'x28' : np.array([]),
-'x29' : np.array([]),
-'x30' : np.array([]),
-'x31' : np.array([]),
-'x32' : np.array([]),
-'x33' : np.array([]),
-'x34' : np.array([]),
-'x35' : np.array([]),
-'x36' : np.array([]),
-'x37' : np.array([]),
-'x38' : np.array([]),
-'x39' : np.array([]),
-'x40' : np.array([]),
-}
-
-
-class FORCENLPsolver_info(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [("it", ctypes.c_int),
- ("res_eq", ctypes.c_double),
- ("rsnorm", ctypes.c_double),
- ("pobj", ctypes.c_double),
- ("solvetime", ctypes.c_double),
- ("fevalstime", ctypes.c_double),
- ("QPtime", ctypes.c_double)]
-
-class FILE(ctypes.Structure):
-        pass
-if sys.version_info.major == 2:
-    PyFile_AsFile = ctypes.pythonapi.PyFile_AsFile # problem here with python 3 http://stackoverflow.com/questions/16130268/python-3-replacement-for-pyfile-asfile
-    PyFile_AsFile.argtypes = [ctypes.py_object]
-    PyFile_AsFile.restype = ctypes.POINTER(FILE)
-
-# determine data types for solver function prototype 
-csolver.argtypes = ( ctypes.POINTER(FORCENLPsolver_params_ctypes), ctypes.POINTER(FORCENLPsolver_outputs_ctypes), ctypes.POINTER(FORCENLPsolver_info), ctypes.POINTER(FILE))
-csolver.restype = ctypes.c_int
-
-def FORCENLPsolver_solve(params_arg):
-    '''
-a Python wrapper for a fast solver generated by FORCESPRO v5.1.0
-
-   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
-   subject to the parameters supplied in the following dictionary:
-       PARAMS['lb'] - column vector of length 160
-       PARAMS['ub'] - column vector of length 160
-       PARAMS['xinit'] - column vector of length 13
-       PARAMS['x0'] - column vector of length 680
-       PARAMS['all_parameters'] - column vector of length 360
-       PARAMS['reinitialize'] - scalar
-
-   OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 17
-       OUTPUT['x02'] - column vector of size 17
-       OUTPUT['x03'] - column vector of size 17
-       OUTPUT['x04'] - column vector of size 17
-       OUTPUT['x05'] - column vector of size 17
-       OUTPUT['x06'] - column vector of size 17
-       OUTPUT['x07'] - column vector of size 17
-       OUTPUT['x08'] - column vector of size 17
-       OUTPUT['x09'] - column vector of size 17
-       OUTPUT['x10'] - column vector of size 17
-       OUTPUT['x11'] - column vector of size 17
-       OUTPUT['x12'] - column vector of size 17
-       OUTPUT['x13'] - column vector of size 17
-       OUTPUT['x14'] - column vector of size 17
-       OUTPUT['x15'] - column vector of size 17
-       OUTPUT['x16'] - column vector of size 17
-       OUTPUT['x17'] - column vector of size 17
-       OUTPUT['x18'] - column vector of size 17
-       OUTPUT['x19'] - column vector of size 17
-       OUTPUT['x20'] - column vector of size 17
-       OUTPUT['x21'] - column vector of size 17
-       OUTPUT['x22'] - column vector of size 17
-       OUTPUT['x23'] - column vector of size 17
-       OUTPUT['x24'] - column vector of size 17
-       OUTPUT['x25'] - column vector of size 17
-       OUTPUT['x26'] - column vector of size 17
-       OUTPUT['x27'] - column vector of size 17
-       OUTPUT['x28'] - column vector of size 17
-       OUTPUT['x29'] - column vector of size 17
-       OUTPUT['x30'] - column vector of size 17
-       OUTPUT['x31'] - column vector of size 17
-       OUTPUT['x32'] - column vector of size 17
-       OUTPUT['x33'] - column vector of size 17
-       OUTPUT['x34'] - column vector of size 17
-       OUTPUT['x35'] - column vector of size 17
-       OUTPUT['x36'] - column vector of size 17
-       OUTPUT['x37'] - column vector of size 17
-       OUTPUT['x38'] - column vector of size 17
-       OUTPUT['x39'] - column vector of size 17
-       OUTPUT['x40'] - column vector of size 17
-
-   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
-   the integer EXITFLAG indicating the state of the solution with 
-       1 - Optimal solution has been found (subject to desired accuracy)
-       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
-       0 - Timeout - maximum number of iterations reached
-      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
-      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
-      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
-      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
-     -10 - The convex solver could not proceed due to an internal error
-    -100 - License error
-
-   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns 
-   additional information about the last iterate:
-       INFO.it        - number of iterations that lead to this result
-       INFO.it2opt    - number of convex solves
-       INFO.res_eq    - max. equality constraint residual
-       INFO.res_ineq  - max. inequality constraint residual
-       INFO.pobj      - primal objective
-       INFO.dobj      - dual objective
-       INFO.dgap      - duality gap := pobj - dobj
-       INFO.rdgap     - relative duality gap := |dgap / pobj|
-       INFO.mu        - duality measure
-       INFO.sigma     - centering parameter
-       INFO.lsit_aff  - iterations of affine line search
-       INFO.lsit_cc   - iterations of line search (combined direction)
-       INFO.step_aff  - step size (affine direction)
-       INFO.step_cc   - step size (centering direction)
-       INFO.solvetime - Time needed for solve (wall clock time)
-
- See also COPYING
-
-    '''
-    global _lib
-
-    # convert parameters
-    params_py = FORCENLPsolver_params_ctypes()
-    for par in params_arg:
-        try:
-            #setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='A')))
-            if isinstance(getattr(params_py, par), ctypes.Array):
-                params_arg[par] = np.require(params_arg[par], dtype=FORCENLPsolver_params_types[par], requirements='F')
-                setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='F')))
-            else:
-                setattr(params_py, par, params_arg[par])
-        except:
-            raise ValueError('Parameter ' + par + ' does not have the appropriate dimensions or data type. Please use numpy arrays for parameters.')
-    
-    outputs_py = FORCENLPsolver_outputs_ctypes()
-    info_py = FORCENLPsolver_info()
-    if sys.version_info.major == 2:
-        if sys.platform.startswith('win'):
-            fp = None # if set to none, the solver prints to stdout by default - necessary because we have an access violation otherwise under windows
-        else:
-            #fp = open('stdout_temp.txt','w')
-            fp = sys.stdout
-        try:
-            PyFile_AsFile.restype = ctypes.POINTER(FILE)
-            exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), PyFile_AsFile(fp)  )
-            #fp = open('stdout_temp.txt','r')
-            #print (fp.read())
-            #fp.close()
-        except:
-            #print 'Problem with solver'
-            raise
-    elif sys.version_info.major == 3:
-        if sys.platform.startswith('win'):
-            libc = ctypes.cdll.msvcrt
-        elif sys.platform.startswith('darwin'):
-            libc = ctypes.CDLL('libc.dylib')
-        else:
-            libc = ctypes.CDLL('libc.so.6')       # Open libc
-        cfopen = getattr(libc,'fopen')        # Get its fopen
-        cfopen.restype = ctypes.POINTER(FILE) # Yes, fopen gives a file pointer
-        cfopen.argtypes = [ctypes.c_char_p, ctypes.c_char_p] # Yes, fopen gives a file pointer 
-        fp = cfopen('stdout_temp.txt'.encode('utf-8'),'w'.encode('utf-8'))    # Use that fopen 
-
-        try:
-            if sys.platform.startswith('win'):
-                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), None )
-            else:
-                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), fp )
-            libc.fclose(fp)
-            fptemp = open('stdout_temp.txt','r')
-            print (fptemp.read())
-            fptemp.close()            
-        except:
-            #print 'Problem with solver'
-            raise
-
-    # convert outputs
-    for out in FORCENLPsolver_outputs:
-        FORCENLPsolver_outputs[out] = npct.as_array(getattr(outputs_py,out))
-
-    return FORCENLPsolver_outputs,int(exitflag),info_py
-
-solve = FORCENLPsolver_solve
-
-
Index: model/FORCENLPsolver/FORCENLPsolver_interface.c
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_interface.c b/model/FORCENLPsolver/FORCENLPsolver_interface.c
deleted file mode 100644
--- a/model/FORCENLPsolver/FORCENLPsolver_interface.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,202 +0,0 @@
-/*
- * CasADi to FORCESPRO Template - missing information to be filled in by createCasadi.m 
- * (C) embotech AG, Zurich, Switzerland, 2013-2021. All rights reserved.
- *
- * This file is part of the FORCESPRO client, and carries the same license.
- */ 
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-    
-#include "include/FORCENLPsolver.h"
-
-#ifndef NULL
-#define NULL ((void *) 0)
-#endif
-
-#include "FORCENLPsolver_model.h"
-
-
-
-/* copies data from sparse matrix into a dense one */
-static void sparse2fullcopy(solver_int32_default nrow, solver_int32_default ncol, const solver_int32_default *colidx, const solver_int32_default *row, FORCENLPsolver_callback_float *data, FORCENLPsolver_float *out)
-{
-    solver_int32_default i, j;
-    
-    /* copy data into dense matrix */
-    for(i=0; i<ncol; i++)
-    {
-        for(j=colidx[i]; j<colidx[i+1]; j++)
-        {
-            out[i*nrow + row[j]] = ((FORCENLPsolver_float) data[j]);
-        }
-    }
-}
-
-
-
-
-/* CasADi to FORCESPRO interface */
-extern void FORCENLPsolver_casadi2forces(FORCENLPsolver_float *x,        /* primal vars                                         */
-                                 FORCENLPsolver_float *y,        /* eq. constraint multiplers                           */
-                                 FORCENLPsolver_float *l,        /* ineq. constraint multipliers                        */
-                                 FORCENLPsolver_float *p,        /* parameters                                          */
-                                 FORCENLPsolver_float *f,        /* objective function (scalar)                         */
-                                 FORCENLPsolver_float *nabla_f,  /* gradient of objective function                      */
-                                 FORCENLPsolver_float *c,        /* dynamics                                            */
-                                 FORCENLPsolver_float *nabla_c,  /* Jacobian of the dynamics (column major)             */
-                                 FORCENLPsolver_float *h,        /* inequality constraints                              */
-                                 FORCENLPsolver_float *nabla_h,  /* Jacobian of inequality constraints (column major)   */
-                                 FORCENLPsolver_float *hess,     /* Hessian (column major)                              */
-                                 solver_int32_default stage,     /* stage number (0 indexed)                           */
-								 solver_int32_default iteration, /* iteration number of solver                         */
-								 solver_int32_default threadID   /* Id of caller thread                                */)
-{
-    /* CasADi input and output arrays */
-    const FORCENLPsolver_callback_float *in[4];
-    FORCENLPsolver_callback_float *out[7];
-	
-
-	/* Allocate working arrays for CasADi */
-	FORCENLPsolver_float w[14];
-	
-    /* temporary storage for CasADi sparse output */
-    FORCENLPsolver_callback_float this_f;
-    FORCENLPsolver_float nabla_f_sparse[5];
-    FORCENLPsolver_float h_sparse[1];
-    FORCENLPsolver_float nabla_h_sparse[2];
-    FORCENLPsolver_float c_sparse[3];
-    FORCENLPsolver_float nabla_c_sparse[10];
-            
-    
-    /* pointers to row and column info for 
-     * column compressed format used by CasADi */
-    solver_int32_default nrow, ncol;
-    const solver_int32_default *colind, *row;
-    
-    /* set inputs for CasADi */
-    in[0] = x;
-    in[1] = p;
-    in[2] = l;
-    in[3] = y;
-
-	if ((0 <= stage && stage <= 38))
-	{
-		
-		
-		if( &this_f )
-		{
-			out[0] = &this_f;
-			FORCENLPsolver_objective_0(in, out, NULL, w, 0);
-		}
-		
-		if( nabla_f )
-		{
-			out[0] = nabla_f_sparse;
-			FORCENLPsolver_dobjective_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dobjective_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dobjective_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);
-		}
-		
-		if( c )
-		{
-			out[0] = c_sparse;
-			FORCENLPsolver_dynamics_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dynamics_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dynamics_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, c_sparse, c);
-		}
-		
-		if( nabla_c )
-		{
-			out[0] = nabla_c_sparse;
-			FORCENLPsolver_ddynamics_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_ddynamics_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_ddynamics_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_c_sparse, nabla_c);
-		}
-		
-		if( h )
-		{
-			out[0] = h_sparse;
-			FORCENLPsolver_inequalities_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_inequalities_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_inequalities_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_inequalities_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_inequalities_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, h_sparse, h);
-		}
-		
-		if( nabla_h )
-		{
-			out[0] = nabla_h_sparse;
-			FORCENLPsolver_dinequalities_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dinequalities_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dinequalities_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dinequalities_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dinequalities_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_h_sparse, nabla_h);
-		}
-	}
-	if ((39 == stage))
-	{
-		
-		
-		if( &this_f )
-		{
-			out[0] = &this_f;
-			FORCENLPsolver_objective_1(in, out, NULL, w, 0);
-		}
-		
-		if( nabla_f )
-		{
-			out[0] = nabla_f_sparse;
-			FORCENLPsolver_dobjective_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dobjective_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dobjective_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);
-		}
-		
-		if( h )
-		{
-			out[0] = h_sparse;
-			FORCENLPsolver_inequalities_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_inequalities_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_inequalities_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_inequalities_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_inequalities_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, h_sparse, h);
-		}
-		
-		if( nabla_h )
-		{
-			out[0] = nabla_h_sparse;
-			FORCENLPsolver_dinequalities_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dinequalities_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dinequalities_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dinequalities_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dinequalities_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_h_sparse, nabla_h);
-		}
-	}
-    
-    /* add to objective */
-    if (f != NULL)
-    {
-        *f += ((FORCENLPsolver_float) this_f);
-    }
-}
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
Index: FORCENLPsolver/FORCENLPsolver_model.h
===================================================================
diff --git a/FORCENLPsolver/FORCENLPsolver_model.h b/FORCENLPsolver/FORCENLPsolver_model.h
deleted file mode 100644
--- a/FORCENLPsolver/FORCENLPsolver_model.h	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,53 +0,0 @@
-
-
-#ifndef FORCENLPSOLVER_MODEL_H
-#include "include/FORCENLPsolver.h"
-#define FORCENLPSOLVER_MODEL_H
-/* This file was automatically generated by CasADi.
-   The CasADi copyright holders make no ownership claim of its contents. */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef casadi_real
-#define casadi_real FORCENLPsolver_float
-#endif
-
-#ifndef casadi_int
-#define casadi_int solver_int32_default
-#endif
-
-int FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_inequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_inequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dinequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dinequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_inequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_inequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dinequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_dinequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-#endif
\ No newline at end of file
Index: model/FORCENLPsolver/include/FORCENLPsolver.h
===================================================================
diff --git a/model/FORCENLPsolver/include/FORCENLPsolver.h b/model/FORCENLPsolver/include/FORCENLPsolver.h
deleted file mode 100644
--- a/model/FORCENLPsolver/include/FORCENLPsolver.h	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,315 +0,0 @@
-#ifndef FORCENLPsolver_H
-#define FORCENLPsolver_H
-/* Generated by FORCESPRO v5.1.0 on Wednesday, March 2, 2022 at 2:15:46 PM */
-
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#include <stddef.h>
-#endif
-
-
-/* DATA TYPE ------------------------------------------------------------*/
-typedef double FORCENLPsolver_float;
-typedef double FORCENLPsolver_callback_float;
-typedef double FORCENLPsolverinterface_float;
-typedef int FORCENLPsolver_int;
-
-#ifndef SOLVER_STANDARD_TYPES
-#define SOLVER_STANDARD_TYPES
-
-typedef signed char solver_int8_signed;
-typedef unsigned char solver_int8_unsigned;
-typedef char solver_int8_default;
-typedef signed short int solver_int16_signed;
-typedef unsigned short int solver_int16_unsigned;
-typedef short int solver_int16_default;
-typedef signed int solver_int32_signed;
-typedef unsigned int solver_int32_unsigned;
-typedef int solver_int32_default;
-typedef signed long long int solver_int64_signed;
-typedef unsigned long long int solver_int64_unsigned;
-typedef long long int solver_int64_default;
-
-#endif
-
-/* SOLVER SETTINGS ------------------------------------------------------*/
-
-/* MISRA-C compliance */
-#ifndef MISRA_C_FORCENLPsolver
-#define MISRA_C_FORCENLPsolver (0)
-#endif
-
-/* restrict code */
-#ifndef RESTRICT_CODE_FORCENLPsolver
-#define RESTRICT_CODE_FORCENLPsolver (0)
-#endif
-
-/* print level */
-#ifndef SET_PRINTLEVEL_FORCENLPsolver
-#define SET_PRINTLEVEL_FORCENLPsolver    (0)
-#endif
-
-/* timing */
-#ifndef SET_TIMING_FORCENLPsolver
-#define SET_TIMING_FORCENLPsolver    (1)
-#endif
-
-/* Numeric Warnings */
-/* #define PRINTNUMERICALWARNINGS */
-
-/* maximum number of iterations  */
-#define SET_MAXIT_FORCENLPsolver			(200)	 
-
-/* desired maximum residual on equality constraints */
-#define SET_ACC_RESEQ_FORCENLPsolver		(FORCENLPsolver_float)(1E-06)
-
-
-/* RETURN CODES----------------------------------------------------------*/
-/* solver has converged within desired accuracy */
-#define OPTIMAL_FORCENLPsolver      (1)
-
-/* maximum number of iterations has been reached */
-#define MAXITREACHED_FORCENLPsolver (0)
-
-/* solver has stopped due to a timeout */
-#define TIMEOUT_FORCENLPsolver   (2)
-
-/* NaN encountered in function evaluations */
-#define BADFUNCEVAL_FORCENLPsolver  (-6)
-
-/* no progress in method possible */
-#define NOPROGRESS_FORCENLPsolver   (-7)
-
-/* regularization error */
-#define REGULARIZATION_ERROR_FORCENLPsolver   (-9)
-
-/* invalid values in parameters */
-#define PARAM_VALUE_ERROR_FORCENLPsolver   (-11)
-
-/* too small timeout given */
-#define INVALID_TIMEOUT_FORCENLPsolver   (-12)
-
-/* error in linesearch */
-#define LINESEARCH_ERROR_FORCENLPsolver   (-13)
-
-/* thread error */
-#define THREAD_FAILURE_FORCENLPsolver  (-98)
-
-/* locking mechanism error */
-#define LOCK_FAILURE_FORCENLPsolver  (-99)
-
-/* licensing error - solver not valid on this machine */
-#define LICENSE_ERROR_FORCENLPsolver  (-100)
-
-/* qp solver error */
-#define QP_SOLVER_FAILURE_FORCENLPsolver (-8)
-
-
-/* INTEGRATORS RETURN CODE ------------*/
-/* Integrator ran successfully */
-#define INTEGRATOR_SUCCESS (11)
-/* Number of steps set by user exceeds maximum number of steps allowed */
-#define INTEGRATOR_MAXSTEPS_EXCEEDED (12)
-
-/* PARAMETERS -----------------------------------------------------------*/
-/* fill this with data before calling the solver! */
-typedef struct
-{
-	    /* vector of size 3 */
-    FORCENLPsolver_float xinit[3];
-
-    /* vector of size 200 */
-    FORCENLPsolver_float x0[200];
-
-    /* vector of size 120 */
-    FORCENLPsolver_float all_parameters[120];
-
-    /* scalar */
-    FORCENLPsolver_int reinitialize;
-
-
-} FORCENLPsolver_params;
-
-
-/* OUTPUTS --------------------------------------------------------------*/
-/* the desired variables are put here by the solver */
-typedef struct
-{
-	    /* vector of size 5 */
-    FORCENLPsolver_float x01[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x02[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x03[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x04[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x05[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x06[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x07[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x08[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x09[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x10[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x11[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x12[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x13[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x14[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x15[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x16[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x17[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x18[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x19[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x20[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x21[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x22[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x23[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x24[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x25[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x26[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x27[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x28[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x29[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x30[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x31[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x32[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x33[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x34[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x35[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x36[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x37[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x38[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x39[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x40[5];
-
-
-} FORCENLPsolver_output;
-
-
-/* SOLVER INFO ----------------------------------------------------------*/
-/* diagnostic data from last interior point step */
-typedef struct
-{
-	/* iteration number */
-	solver_int32_default it;
-
-	/* inf-norm of equality constraint residuals */
-	FORCENLPsolver_float res_eq;
-
-	/* norm of stationarity condition */
-	FORCENLPsolver_float rsnorm;
-
-	/* primal objective */
-	FORCENLPsolver_float pobj;
-
-	/* total solve time */
-	FORCENLPsolver_float solvetime;
-
-	/* time spent in function evaluations */
-	FORCENLPsolver_float fevalstime;
-
-	/* time spent solving QPs */
-	FORCENLPsolver_float QPtime;
-} FORCENLPsolver_info;
-
-
-
-/* SOLVER FUNCTION DEFINITION -------------------------------------------*/
-/* Time of Solver Generation: (UTC) Wednesday, March 2, 2022 2:15:48 PM */
-/* User License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) (at the time of code generation) */
-/* Solver Static License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) */
-/* Solver Generation Request Id: 76f14dbb-068e-4b16-8c5e-840c976298ab */
-/* examine exitflag before using the result! */
-#ifdef __cplusplus
-extern "C" {
-#endif		
-
-typedef void(*FORCENLPsolver_extfunc)(FORCENLPsolver_float* x, FORCENLPsolver_float* y, FORCENLPsolver_float* lambda, FORCENLPsolver_float* params, FORCENLPsolver_float* pobj, FORCENLPsolver_float* g, FORCENLPsolver_float* c, FORCENLPsolver_float* Jeq, FORCENLPsolver_float* h, FORCENLPsolver_float* Jineq, FORCENLPsolver_float* H, solver_int32_default stage, solver_int32_default iterations, solver_int32_default threadID);
-
-extern solver_int32_default FORCENLPsolver_solve(FORCENLPsolver_params *params, FORCENLPsolver_output *output, FORCENLPsolver_info *info, FILE *fs, FORCENLPsolver_extfunc evalextfunctions_FORCENLPsolver);
-
-
-
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
Index: model/FORCENLPsolver/interface/FORCENLPsolver_build.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_build.py b/model/FORCENLPsolver/interface/FORCENLPsolver_build.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_build.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,62 +0,0 @@
-#FORCENLPsolver : A fast customized optimization solver.
-#
-#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-#
-#
-#This software is intended for simulation and testing purposes only. 
-#Use of this software for any commercial purpose is prohibited.
-#
-#This program is distributed in the hope that it will be useful.
-#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-#PARTICULAR PURPOSE. 
-#
-#EMBOTECH shall not have any liability for any damage arising from the use
-#of the software.
-#
-#This Agreement shall exclusively be governed by and interpreted in 
-#accordance with the laws of Switzerland, excluding its principles
-#of conflict of laws. The Courts of Zurich-City shall have exclusive 
-#jurisdiction in case of any dispute.
-#
-from distutils.ccompiler import new_compiler
-c = new_compiler()
-#from numpy.distutils.intelccompiler import IntelCCompiler
-#c = IntelCCompiler()
-
-
-import os
-import sys
-import distutils
-
-# determine source file
-sourcefile = os.path.join(os.getcwd(),"FORCENLPsolver","src","FORCENLPsolver"+".c")
-
-# determine lib file
-if sys.platform.startswith('win'):
-	libfile = os.path.join(os.getcwd(),"FORCENLPsolver","lib","FORCENLPsolver"+".lib")
-else:
-	libfile = os.path.join(os.getcwd(),"FORCENLPsolver","lib","FORCENLPsolver"+".so")	
-
-# create lib dir if it does not exist yet
-if not os.path.exists(os.path.join(os.getcwd(),"FORCENLPsolver","lib")):
-	os.makedirs(os.path.join(os.getcwd(),"FORCENLPsolver","lib"))
-								
-
-				
-# compile into object file
-objdir = os.path.join(os.getcwd(),"FORCENLPsolver","obj")
-if isinstance(c,distutils.unixccompiler.UnixCCompiler):
-	#objects = c.compile([sourcefile], output_dir=objdir, extra_preargs=['-O3','-fPIC','-fopenmp','-mavx'])
-	objects = c.compile([sourcefile], output_dir=objdir, extra_preargs=['-O3','-fPIC','-mavx'])
-	if sys.platform.startswith('linux'):
-		c.set_libraries(['rt','gomp'])
-else:
-	objects = c.compile([sourcefile], output_dir=objdir)
-
-				
-# create libraries
-libdir = os.path.join(os.getcwd(),"FORCENLPsolver","lib")
-exportsymbols = ["%s_solve" % "FORCENLPsolver"]
-c.create_static_lib(objects, "FORCENLPsolver", output_dir=libdir)
-c.link_shared_lib(objects, "FORCENLPsolver", output_dir=libdir, export_symbols=exportsymbols)
\ No newline at end of file
Index: FORCENLPsolver/interface/definitions_eval.py
===================================================================
diff --git a/FORCENLPsolver/interface/definitions_eval.py b/FORCENLPsolver/interface/definitions_eval.py
deleted file mode 100644
--- a/FORCENLPsolver/interface/definitions_eval.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,4 +0,0 @@
-is_static = True
-lib = "libsolver_with_model.so"
-f = "FORCENLPsolver_interface"
-intel_libs_dir = "/home/richard/Applications/Forces_Pro/forces_pro_client/libs_Intel/win64"
Index: FORCENLPsolver/interface/FORCENLPsolver_build.py
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_build.py b/FORCENLPsolver/interface/FORCENLPsolver_build.py
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_build.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,62 +0,0 @@
-#FORCENLPsolver : A fast customized optimization solver.
-#
-#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-#
-#
-#This software is intended for simulation and testing purposes only. 
-#Use of this software for any commercial purpose is prohibited.
-#
-#This program is distributed in the hope that it will be useful.
-#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-#PARTICULAR PURPOSE. 
-#
-#EMBOTECH shall not have any liability for any damage arising from the use
-#of the software.
-#
-#This Agreement shall exclusively be governed by and interpreted in 
-#accordance with the laws of Switzerland, excluding its principles
-#of conflict of laws. The Courts of Zurich-City shall have exclusive 
-#jurisdiction in case of any dispute.
-#
-from distutils.ccompiler import new_compiler
-c = new_compiler()
-#from numpy.distutils.intelccompiler import IntelCCompiler
-#c = IntelCCompiler()
-
-
-import os
-import sys
-import distutils
-
-# determine source file
-sourcefile = os.path.join(os.getcwd(),"FORCENLPsolver","src","FORCENLPsolver"+".c")
-
-# determine lib file
-if sys.platform.startswith('win'):
-	libfile = os.path.join(os.getcwd(),"FORCENLPsolver","lib","FORCENLPsolver"+".lib")
-else:
-	libfile = os.path.join(os.getcwd(),"FORCENLPsolver","lib","FORCENLPsolver"+".so")	
-
-# create lib dir if it does not exist yet
-if not os.path.exists(os.path.join(os.getcwd(),"FORCENLPsolver","lib")):
-	os.makedirs(os.path.join(os.getcwd(),"FORCENLPsolver","lib"))
-								
-
-				
-# compile into object file
-objdir = os.path.join(os.getcwd(),"FORCENLPsolver","obj")
-if isinstance(c,distutils.unixccompiler.UnixCCompiler):
-	#objects = c.compile([sourcefile], output_dir=objdir, extra_preargs=['-O3','-fPIC','-fopenmp','-mavx'])
-	objects = c.compile([sourcefile], output_dir=objdir, extra_preargs=['-O3','-fPIC','-mavx'])
-	if sys.platform.startswith('linux'):
-		c.set_libraries(['rt','gomp'])
-else:
-	objects = c.compile([sourcefile], output_dir=objdir)
-
-				
-# create libraries
-libdir = os.path.join(os.getcwd(),"FORCENLPsolver","lib")
-exportsymbols = ["%s_solve" % "FORCENLPsolver"]
-c.create_static_lib(objects, "FORCENLPsolver", output_dir=libdir)
-c.link_shared_lib(objects, "FORCENLPsolver", output_dir=libdir, export_symbols=exportsymbols)
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* h_mex;
-	mxArray* jach_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	h_mex = mxCreateDoubleMatrix(dimh, 1, mxREAL);
-	jach_mex = mxCreateDoubleMatrix(dimh, nvar, mxREAL);
-	copyCArrayToM_FORCENLPsolver(h, mxGetPr(h_mex), dimh);
-	copyCArrayToM_FORCENLPsolver(jach, mxGetPr(jach_mex), dimh*nvar);
-	plhs[0] = h_mex;
-	plhs[1] = jach_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,544 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-
-#define S_FUNCTION_LEVEL 2
-#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlockcompact
-
-#include "simstruc.h"
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* include FORCESPRO functions and defs */
-#include "../include/FORCENLPsolver.h" 
-
-/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */
-
-
-#if defined(MATLAB_MEX_FILE)
-#include "tmwtypes.h"
-#include "simstruc_types.h"
-#else
-#include "rtwtypes.h"
-#endif
-
-typedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;
-
-extern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-
-
-/*====================*
- * S-function methods *
- *====================*/
-/* Function: mdlInitializeSizes =========================================
- * Abstract:
- *   Setup sizes of the various vectors.
- */
-static void mdlInitializeSizes(SimStruct *S)
-{
-
-    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
-    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
-    ssSetNumSFcnParams(S, 0);
-    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
-	{
-		return; /* Parameter mismatch will be reported by Simulink */
-    }
-
-	/* initialize size of continuous and discrete states to zero */
-    ssSetNumContStates(S, 0);
-    ssSetNumDiscStates(S, 0);
-
-	/* initialize input ports - there are 4 in total */
-    if (!ssSetNumInputPorts(S, 4)) return;
-    	
-	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 1, 1);
-    ssSetInputPortDataType(S, 0, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
-	
-	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 3, 1);
-    ssSetInputPortDataType(S, 1, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/
-	
-	/* Input Port 2 */
-    ssSetInputPortMatrixDimensions(S,  2, 200, 1);
-    ssSetInputPortDataType(S, 2, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/
-	
-	/* Input Port 3 */
-    ssSetInputPortMatrixDimensions(S,  3, 120, 1);
-    ssSetInputPortDataType(S, 3, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/
- 
-
-
-	/* initialize output ports - there are 1 in total */
-    if (!ssSetNumOutputPorts(S, 1)) return;    
-		
-	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 200, 1);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-
-
-	/* set sampling time */
-    ssSetNumSampleTimes(S, 1);
-
-	/* set internal memory of block */
-    ssSetNumRWork(S, 0);
-    ssSetNumIWork(S, 0);
-    ssSetNumPWork(S, 0);
-    ssSetNumModes(S, 0);
-    ssSetNumNonsampledZCs(S, 0);
-
-    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
-		             SS_OPTION_WORKS_WITH_CODE_REUSE)); */
-	ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );
-
-	
-}
-
-#if defined(MATLAB_MEX_FILE)
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-static void mdlSetInputPortDimensionInfo(SimStruct        *S, 
-                                         int_T            port,
-                                         const DimsInfo_T *dimsInfo)
-{
-    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)
-static void mdlSetOutputPortDimensionInfo(SimStruct        *S, 
-                                          int_T            port, 
-                                          const DimsInfo_T *dimsInfo)
-{
-    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-# define MDL_SET_INPUT_PORT_FRAME_DATA
-static void mdlSetInputPortFrameData(SimStruct  *S, 
-                                     int_T      port,
-                                     Frame_T    frameData)
-{
-    ssSetInputPortFrameData(S, port, frameData);
-}
-/* Function: mdlInitializeSampleTimes =========================================
- * Abstract:
- *    Specifiy  the sample time.
- */
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
-    ssSetOffsetTime(S, 0, 0.0);
-}
-
-#define MDL_SET_INPUT_PORT_DATA_TYPE
-static void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetInputPortDataType( S, 0, dType);
-}
-#define MDL_SET_OUTPUT_PORT_DATA_TYPE
-static void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetOutputPortDataType(S, 0, dType);
-}
-
-#define MDL_SET_DEFAULT_PORT_DATA_TYPES
-static void mdlSetDefaultPortDataTypes(SimStruct *S)
-{
-    ssSetInputPortDataType( S, 0, SS_DOUBLE);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-}
-
-
-
-
-
-/* Function: mdlOutputs =======================================================
- *
-*/
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	solver_int32_default i, j, k;
-	
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* Simulink data */
-	const FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,0);
-	const real_T *xinit = (const real_T*) ssGetInputPortSignal(S,1);
-	const real_T *x0 = (const real_T*) ssGetInputPortSignal(S,2);
-	const real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,3);
-	
-    real_T *outputs = (real_T*) ssGetOutputPortSignal(S,0);
-	
-	
-
-	/* Solver data */
-	static FORCENLPsolver_params params;
-	static FORCENLPsolver_output output;
-	static FORCENLPsolver_info info;	
-	solver_int32_default exitflag;
-
-	/* Extra NMPC data */
-	
-
-	/* Copy inputs */
-	for( i=0; i<3; i++)
-	{ 
-		params.xinit[i] = (double) xinit[i]; 
-	}
-
-	for( i=0; i<200; i++)
-	{ 
-		params.x0[i] = (double) x0[i]; 
-	}
-
-	for( i=0; i<120; i++)
-	{ 
-		params.all_parameters[i] = (double) all_parameters[i]; 
-	}
-
-	params.reinitialize = *reinitialize;
-
-	
-
-	
-
-    #if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* Call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			ssPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	
-
-	/* Copy outputs */
-	for( i=0; i<5; i++)
-	{ 
-		outputs[i] = (real_T) output.x01[i]; 
-	}
-
-	k=5; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x02[i]; 
-	}
-
-	k=10; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x03[i]; 
-	}
-
-	k=15; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x04[i]; 
-	}
-
-	k=20; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x05[i]; 
-	}
-
-	k=25; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x06[i]; 
-	}
-
-	k=30; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x07[i]; 
-	}
-
-	k=35; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x08[i]; 
-	}
-
-	k=40; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x09[i]; 
-	}
-
-	k=45; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x10[i]; 
-	}
-
-	k=50; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x11[i]; 
-	}
-
-	k=55; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x12[i]; 
-	}
-
-	k=60; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x13[i]; 
-	}
-
-	k=65; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x14[i]; 
-	}
-
-	k=70; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x15[i]; 
-	}
-
-	k=75; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x16[i]; 
-	}
-
-	k=80; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x17[i]; 
-	}
-
-	k=85; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x18[i]; 
-	}
-
-	k=90; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x19[i]; 
-	}
-
-	k=95; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x20[i]; 
-	}
-
-	k=100; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x21[i]; 
-	}
-
-	k=105; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x22[i]; 
-	}
-
-	k=110; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x23[i]; 
-	}
-
-	k=115; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x24[i]; 
-	}
-
-	k=120; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x25[i]; 
-	}
-
-	k=125; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x26[i]; 
-	}
-
-	k=130; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x27[i]; 
-	}
-
-	k=135; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x28[i]; 
-	}
-
-	k=140; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x29[i]; 
-	}
-
-	k=145; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x30[i]; 
-	}
-
-	k=150; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x31[i]; 
-	}
-
-	k=155; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x32[i]; 
-	}
-
-	k=160; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x33[i]; 
-	}
-
-	k=165; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x34[i]; 
-	}
-
-	k=170; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x35[i]; 
-	}
-
-	k=175; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x36[i]; 
-	}
-
-	k=180; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x37[i]; 
-	}
-
-	k=185; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x38[i]; 
-	}
-
-	k=190; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x39[i]; 
-	}
-
-	k=195; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x40[i]; 
-	}
-
-	
-}
-
-
-
-
-
-/* Function: mdlTerminate =====================================================
- * Abstract:
- *    In this function, you should perform any actions that are necessary
- *    at the termination of a simulation.  For example, if memory was
- *    allocated in mdlStart, this is the place to free it.
- */
-static void mdlTerminate(SimStruct *S)
-{
-}
-#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
-#include "simulink.c"      /* MEX-file interface mechanism */
-#else
-#include "cg_sfun.h"       /* Code generation registration function */
-#endif
-
-
Index: model/FORCENLPsolver/interface/FORCENLPsolver_py.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_py.py b/model/FORCENLPsolver/interface/FORCENLPsolver_py.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_py.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,412 +0,0 @@
-#FORCENLPsolver : A fast customized optimization solver.
-#
-#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-#
-#
-#This software is intended for simulation and testing purposes only. 
-#Use of this software for any commercial purpose is prohibited.
-#
-#This program is distributed in the hope that it will be useful.
-#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-#PARTICULAR PURPOSE. 
-#
-#EMBOTECH shall not have any liability for any damage arising from the use
-#of the software.
-#
-#This Agreement shall exclusively be governed by and interpreted in 
-#accordance with the laws of Switzerland, excluding its principles
-#of conflict of laws. The Courts of Zurich-City shall have exclusive 
-#jurisdiction in case of any dispute.
-#
-#def __init__():
-'''
-a Python wrapper for a fast solver generated by FORCESPRO v5.1.0
-
-   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
-   subject to the parameters supplied in the following dictionary:
-       PARAMS['xinit'] - column vector of length 3
-       PARAMS['x0'] - column vector of length 200
-       PARAMS['all_parameters'] - column vector of length 120
-       PARAMS['reinitialize'] - scalar
-
-   OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 5
-       OUTPUT['x02'] - column vector of size 5
-       OUTPUT['x03'] - column vector of size 5
-       OUTPUT['x04'] - column vector of size 5
-       OUTPUT['x05'] - column vector of size 5
-       OUTPUT['x06'] - column vector of size 5
-       OUTPUT['x07'] - column vector of size 5
-       OUTPUT['x08'] - column vector of size 5
-       OUTPUT['x09'] - column vector of size 5
-       OUTPUT['x10'] - column vector of size 5
-       OUTPUT['x11'] - column vector of size 5
-       OUTPUT['x12'] - column vector of size 5
-       OUTPUT['x13'] - column vector of size 5
-       OUTPUT['x14'] - column vector of size 5
-       OUTPUT['x15'] - column vector of size 5
-       OUTPUT['x16'] - column vector of size 5
-       OUTPUT['x17'] - column vector of size 5
-       OUTPUT['x18'] - column vector of size 5
-       OUTPUT['x19'] - column vector of size 5
-       OUTPUT['x20'] - column vector of size 5
-       OUTPUT['x21'] - column vector of size 5
-       OUTPUT['x22'] - column vector of size 5
-       OUTPUT['x23'] - column vector of size 5
-       OUTPUT['x24'] - column vector of size 5
-       OUTPUT['x25'] - column vector of size 5
-       OUTPUT['x26'] - column vector of size 5
-       OUTPUT['x27'] - column vector of size 5
-       OUTPUT['x28'] - column vector of size 5
-       OUTPUT['x29'] - column vector of size 5
-       OUTPUT['x30'] - column vector of size 5
-       OUTPUT['x31'] - column vector of size 5
-       OUTPUT['x32'] - column vector of size 5
-       OUTPUT['x33'] - column vector of size 5
-       OUTPUT['x34'] - column vector of size 5
-       OUTPUT['x35'] - column vector of size 5
-       OUTPUT['x36'] - column vector of size 5
-       OUTPUT['x37'] - column vector of size 5
-       OUTPUT['x38'] - column vector of size 5
-       OUTPUT['x39'] - column vector of size 5
-       OUTPUT['x40'] - column vector of size 5
-
-   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
-   the integer EXITFLAG indicating the state of the solution with 
-       1 - Optimal solution has been found (subject to desired accuracy)
-       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
-       0 - Timeout - maximum number of iterations reached
-      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
-      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
-      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
-      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
-     -10 - The convex solver could not proceed due to an internal error
-    -100 - License error
-
-   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns 
-   additional information about the last iterate:
-       INFO.it        - number of iterations that lead to this result
-       INFO.it2opt    - number of convex solves
-       INFO.res_eq    - max. equality constraint residual
-       INFO.res_ineq  - max. inequality constraint residual
-       INFO.pobj      - primal objective
-       INFO.dobj      - dual objective
-       INFO.dgap      - duality gap := pobj - dobj
-       INFO.rdgap     - relative duality gap := |dgap / pobj|
-       INFO.mu        - duality measure
-       INFO.sigma     - centering parameter
-       INFO.lsit_aff  - iterations of affine line search
-       INFO.lsit_cc   - iterations of line search (combined direction)
-       INFO.step_aff  - step size (affine direction)
-       INFO.step_cc   - step size (centering direction)
-       INFO.solvetime - Time needed for solve (wall clock time)
-
- See also COPYING
-
-'''
-
-import ctypes
-import os
-import numpy as np
-import numpy.ctypeslib as npct
-import sys
-
-#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'FORCENLPsolver/lib/FORCENLPsolver.dll')) 
-try:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/FORCENLPsolver.dll'))
-    csolver = getattr(_lib,'FORCENLPsolver_solve')
-except:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/libFORCENLPsolver.dll'))
-    csolver = getattr(_lib,'FORCENLPsolver_solve')
-
-class FORCENLPsolver_params_ctypes(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [('xinit', ctypes.c_double * 3),
-('x0', ctypes.c_double * 200),
-('all_parameters', ctypes.c_double * 120),
-('reinitialize', ctypes.c_int),
-]
-
-FORCENLPsolver_params = {'xinit' : np.array([]),
-'x0' : np.array([]),
-'all_parameters' : np.array([]),
-'reinitialize' : np.array([]),
-}
-params = {'xinit' : np.array([]),
-'x0' : np.array([]),
-'all_parameters' : np.array([]),
-'reinitialize' : np.array([]),
-}
-FORCENLPsolver_params_types = {'xinit' : np.float64,
-'x0' : np.float64,
-'all_parameters' : np.float64,
-'reinitialize' : np.int32,
-}
-
-class FORCENLPsolver_outputs_ctypes(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [('x01', ctypes.c_double * 5),
-('x02', ctypes.c_double * 5),
-('x03', ctypes.c_double * 5),
-('x04', ctypes.c_double * 5),
-('x05', ctypes.c_double * 5),
-('x06', ctypes.c_double * 5),
-('x07', ctypes.c_double * 5),
-('x08', ctypes.c_double * 5),
-('x09', ctypes.c_double * 5),
-('x10', ctypes.c_double * 5),
-('x11', ctypes.c_double * 5),
-('x12', ctypes.c_double * 5),
-('x13', ctypes.c_double * 5),
-('x14', ctypes.c_double * 5),
-('x15', ctypes.c_double * 5),
-('x16', ctypes.c_double * 5),
-('x17', ctypes.c_double * 5),
-('x18', ctypes.c_double * 5),
-('x19', ctypes.c_double * 5),
-('x20', ctypes.c_double * 5),
-('x21', ctypes.c_double * 5),
-('x22', ctypes.c_double * 5),
-('x23', ctypes.c_double * 5),
-('x24', ctypes.c_double * 5),
-('x25', ctypes.c_double * 5),
-('x26', ctypes.c_double * 5),
-('x27', ctypes.c_double * 5),
-('x28', ctypes.c_double * 5),
-('x29', ctypes.c_double * 5),
-('x30', ctypes.c_double * 5),
-('x31', ctypes.c_double * 5),
-('x32', ctypes.c_double * 5),
-('x33', ctypes.c_double * 5),
-('x34', ctypes.c_double * 5),
-('x35', ctypes.c_double * 5),
-('x36', ctypes.c_double * 5),
-('x37', ctypes.c_double * 5),
-('x38', ctypes.c_double * 5),
-('x39', ctypes.c_double * 5),
-('x40', ctypes.c_double * 5),
-]
-
-FORCENLPsolver_outputs = {'x01' : np.array([]),
-'x02' : np.array([]),
-'x03' : np.array([]),
-'x04' : np.array([]),
-'x05' : np.array([]),
-'x06' : np.array([]),
-'x07' : np.array([]),
-'x08' : np.array([]),
-'x09' : np.array([]),
-'x10' : np.array([]),
-'x11' : np.array([]),
-'x12' : np.array([]),
-'x13' : np.array([]),
-'x14' : np.array([]),
-'x15' : np.array([]),
-'x16' : np.array([]),
-'x17' : np.array([]),
-'x18' : np.array([]),
-'x19' : np.array([]),
-'x20' : np.array([]),
-'x21' : np.array([]),
-'x22' : np.array([]),
-'x23' : np.array([]),
-'x24' : np.array([]),
-'x25' : np.array([]),
-'x26' : np.array([]),
-'x27' : np.array([]),
-'x28' : np.array([]),
-'x29' : np.array([]),
-'x30' : np.array([]),
-'x31' : np.array([]),
-'x32' : np.array([]),
-'x33' : np.array([]),
-'x34' : np.array([]),
-'x35' : np.array([]),
-'x36' : np.array([]),
-'x37' : np.array([]),
-'x38' : np.array([]),
-'x39' : np.array([]),
-'x40' : np.array([]),
-}
-
-
-class FORCENLPsolver_info(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [("it", ctypes.c_int),
- ("res_eq", ctypes.c_double),
- ("rsnorm", ctypes.c_double),
- ("pobj", ctypes.c_double),
- ("solvetime", ctypes.c_double),
- ("fevalstime", ctypes.c_double),
- ("QPtime", ctypes.c_double)]
-
-class FILE(ctypes.Structure):
-        pass
-if sys.version_info.major == 2:
-    PyFile_AsFile = ctypes.pythonapi.PyFile_AsFile # problem here with python 3 http://stackoverflow.com/questions/16130268/python-3-replacement-for-pyfile-asfile
-    PyFile_AsFile.argtypes = [ctypes.py_object]
-    PyFile_AsFile.restype = ctypes.POINTER(FILE)
-
-# determine data types for solver function prototype 
-csolver.argtypes = ( ctypes.POINTER(FORCENLPsolver_params_ctypes), ctypes.POINTER(FORCENLPsolver_outputs_ctypes), ctypes.POINTER(FORCENLPsolver_info), ctypes.POINTER(FILE))
-csolver.restype = ctypes.c_int
-
-def FORCENLPsolver_solve(params_arg):
-    '''
-a Python wrapper for a fast solver generated by FORCESPRO v5.1.0
-
-   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
-   subject to the parameters supplied in the following dictionary:
-       PARAMS['xinit'] - column vector of length 3
-       PARAMS['x0'] - column vector of length 200
-       PARAMS['all_parameters'] - column vector of length 120
-       PARAMS['reinitialize'] - scalar
-
-   OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 5
-       OUTPUT['x02'] - column vector of size 5
-       OUTPUT['x03'] - column vector of size 5
-       OUTPUT['x04'] - column vector of size 5
-       OUTPUT['x05'] - column vector of size 5
-       OUTPUT['x06'] - column vector of size 5
-       OUTPUT['x07'] - column vector of size 5
-       OUTPUT['x08'] - column vector of size 5
-       OUTPUT['x09'] - column vector of size 5
-       OUTPUT['x10'] - column vector of size 5
-       OUTPUT['x11'] - column vector of size 5
-       OUTPUT['x12'] - column vector of size 5
-       OUTPUT['x13'] - column vector of size 5
-       OUTPUT['x14'] - column vector of size 5
-       OUTPUT['x15'] - column vector of size 5
-       OUTPUT['x16'] - column vector of size 5
-       OUTPUT['x17'] - column vector of size 5
-       OUTPUT['x18'] - column vector of size 5
-       OUTPUT['x19'] - column vector of size 5
-       OUTPUT['x20'] - column vector of size 5
-       OUTPUT['x21'] - column vector of size 5
-       OUTPUT['x22'] - column vector of size 5
-       OUTPUT['x23'] - column vector of size 5
-       OUTPUT['x24'] - column vector of size 5
-       OUTPUT['x25'] - column vector of size 5
-       OUTPUT['x26'] - column vector of size 5
-       OUTPUT['x27'] - column vector of size 5
-       OUTPUT['x28'] - column vector of size 5
-       OUTPUT['x29'] - column vector of size 5
-       OUTPUT['x30'] - column vector of size 5
-       OUTPUT['x31'] - column vector of size 5
-       OUTPUT['x32'] - column vector of size 5
-       OUTPUT['x33'] - column vector of size 5
-       OUTPUT['x34'] - column vector of size 5
-       OUTPUT['x35'] - column vector of size 5
-       OUTPUT['x36'] - column vector of size 5
-       OUTPUT['x37'] - column vector of size 5
-       OUTPUT['x38'] - column vector of size 5
-       OUTPUT['x39'] - column vector of size 5
-       OUTPUT['x40'] - column vector of size 5
-
-   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
-   the integer EXITFLAG indicating the state of the solution with 
-       1 - Optimal solution has been found (subject to desired accuracy)
-       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
-       0 - Timeout - maximum number of iterations reached
-      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
-      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
-      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
-      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
-     -10 - The convex solver could not proceed due to an internal error
-    -100 - License error
-
-   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns 
-   additional information about the last iterate:
-       INFO.it        - number of iterations that lead to this result
-       INFO.it2opt    - number of convex solves
-       INFO.res_eq    - max. equality constraint residual
-       INFO.res_ineq  - max. inequality constraint residual
-       INFO.pobj      - primal objective
-       INFO.dobj      - dual objective
-       INFO.dgap      - duality gap := pobj - dobj
-       INFO.rdgap     - relative duality gap := |dgap / pobj|
-       INFO.mu        - duality measure
-       INFO.sigma     - centering parameter
-       INFO.lsit_aff  - iterations of affine line search
-       INFO.lsit_cc   - iterations of line search (combined direction)
-       INFO.step_aff  - step size (affine direction)
-       INFO.step_cc   - step size (centering direction)
-       INFO.solvetime - Time needed for solve (wall clock time)
-
- See also COPYING
-
-    '''
-    global _lib
-
-    # convert parameters
-    params_py = FORCENLPsolver_params_ctypes()
-    for par in params_arg:
-        try:
-            #setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='A')))
-            if isinstance(getattr(params_py, par), ctypes.Array):
-                params_arg[par] = np.require(params_arg[par], dtype=FORCENLPsolver_params_types[par], requirements='F')
-                setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='F')))
-            else:
-                setattr(params_py, par, params_arg[par])
-        except:
-            raise ValueError('Parameter ' + par + ' does not have the appropriate dimensions or data type. Please use numpy arrays for parameters.')
-    
-    outputs_py = FORCENLPsolver_outputs_ctypes()
-    info_py = FORCENLPsolver_info()
-    if sys.version_info.major == 2:
-        if sys.platform.startswith('win'):
-            fp = None # if set to none, the solver prints to stdout by default - necessary because we have an access violation otherwise under windows
-        else:
-            #fp = open('stdout_temp.txt','w')
-            fp = sys.stdout
-        try:
-            PyFile_AsFile.restype = ctypes.POINTER(FILE)
-            exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), PyFile_AsFile(fp)  )
-            #fp = open('stdout_temp.txt','r')
-            #print (fp.read())
-            #fp.close()
-        except:
-            #print 'Problem with solver'
-            raise
-    elif sys.version_info.major == 3:
-        if sys.platform.startswith('win'):
-            libc = ctypes.cdll.msvcrt
-        elif sys.platform.startswith('darwin'):
-            libc = ctypes.CDLL('libc.dylib')
-        else:
-            libc = ctypes.CDLL('libc.so.6')       # Open libc
-        cfopen = getattr(libc,'fopen')        # Get its fopen
-        cfopen.restype = ctypes.POINTER(FILE) # Yes, fopen gives a file pointer
-        cfopen.argtypes = [ctypes.c_char_p, ctypes.c_char_p] # Yes, fopen gives a file pointer 
-        fp = cfopen('stdout_temp.txt'.encode('utf-8'),'w'.encode('utf-8'))    # Use that fopen 
-
-        try:
-            if sys.platform.startswith('win'):
-                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), None )
-            else:
-                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), fp )
-            libc.fclose(fp)
-            fptemp = open('stdout_temp.txt','r')
-            print (fptemp.read())
-            fptemp.close()            
-        except:
-            #print 'Problem with solver'
-            raise
-
-    # convert outputs
-    for out in FORCENLPsolver_outputs:
-        FORCENLPsolver_outputs[out] = npct.as_array(getattr(outputs_py,out))
-
-    return FORCENLPsolver_outputs,int(exitflag),info_py
-
-solve = FORCENLPsolver_solve
-
-
Index: FORCENLPsolver/interface/FORCENLPsolver_mex.c
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_mex.c b/FORCENLPsolver/interface/FORCENLPsolver_mex.c
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,476 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-
-
-/* copy functions */
-
-void copyCArrayToM_double(double *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyMArrayToC_double(double *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double) (*src++) ;
-    }
-}
-
-void copyMValueToC_double(double * src, double * dest)
-{
-	*dest = (double) *src;
-}
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver_int(FORCENLPsolver_int *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyMArrayToC_FORCENLPsolver_int(double *src, FORCENLPsolver_int *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_int) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver_int(double * src, FORCENLPsolver_int * dest)
-{
-	*dest = (FORCENLPsolver_int) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-/* Some memory for mex-function */
-static FORCENLPsolver_params params;
-static FORCENLPsolver_output output;
-static FORCENLPsolver_info info;
-
-/* THE mex-function */
-void mexFunction( solver_int32_default nlhs, mxArray *plhs[], solver_int32_default nrhs, const mxArray *prhs[] )  
-{
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* define variables */	
-	mxArray *par;
-	mxArray *outvar;
-	const mxArray *PARAMS = prhs[0]; 
-	double *pvalue;
-	solver_int32_default i;
-	solver_int32_default exitflag;
-	const solver_int8_default *fname;
-	const solver_int8_default *outputnames[40] = {"x01","x02","x03","x04","x05","x06","x07","x08","x09","x10","x11","x12","x13","x14","x15","x16","x17","x18","x19","x20","x21","x22","x23","x24","x25","x26","x27","x28","x29","x30","x31","x32","x33","x34","x35","x36","x37","x38","x39","x40"};
-	const solver_int8_default *infofields[7] = { "it", "res_eq", "rsnorm", "pobj", "solvetime",  "fevalstime", "QPtime"};
-	
-	/* Check for proper number of arguments */
-    if (nrhs != 1)
-	{
-		mexErrMsgTxt("This function requires exactly 1 input: PARAMS struct.\nType 'help FORCENLPsolver_mex' for details.");
-	}    
-	if (nlhs > 3) 
-	{
-        mexErrMsgTxt("This function returns at most 3 outputs.\nType 'help FORCENLPsolver_mex' for details.");
-    }
-
-	/* Check whether params is actually a structure */
-	if( !mxIsStruct(PARAMS) ) 
-	{
-		mexErrMsgTxt("PARAMS must be a structure.");
-	}
-	 
-
-	/* copy parameters into the right location */
-	par = mxGetField(PARAMS, 0, "lb");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.lb not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.lb must be a double.");
-    }
-    if( mxGetM(par) != 160 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.lb must be of size [160 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.lb,160);
-
-	}
-	par = mxGetField(PARAMS, 0, "ub");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.ub not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.ub must be a double.");
-    }
-    if( mxGetM(par) != 160 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.ub must be of size [160 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.ub,160);
-
-	}
-	par = mxGetField(PARAMS, 0, "xinit");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.xinit not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.xinit must be a double.");
-    }
-    if( mxGetM(par) != 13 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.xinit must be of size [13 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.xinit,13);
-
-	}
-	par = mxGetField(PARAMS, 0, "x0");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.x0 not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.x0 must be a double.");
-    }
-    if( mxGetM(par) != 680 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.x0 must be of size [680 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.x0,680);
-
-	}
-	par = mxGetField(PARAMS, 0, "all_parameters");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.all_parameters not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.all_parameters must be a double.");
-    }
-    if( mxGetM(par) != 360 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.all_parameters must be of size [360 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.all_parameters,360);
-
-	}
-	par = mxGetField(PARAMS, 0, "reinitialize");
-	if ( (par != NULL) && (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMValueToC_FORCENLPsolver_int(mxGetPr(par), &params.reinitialize);
-
-	}
-
-
-
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp, pt2function_FORCENLPsolver);
-	
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			mexPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	/* copy output to matlab arrays */
-	plhs[0] = mxCreateStructMatrix(1, 1, 40, outputnames);
-		outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x01, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x01", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x02, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x02", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x03, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x03", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x04, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x04", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x05, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x05", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x06, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x06", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x07, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x07", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x08, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x08", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x09, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x09", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x10, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x10", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x11, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x11", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x12, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x12", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x13, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x13", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x14, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x14", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x15, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x15", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x16, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x16", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x17, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x17", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x18, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x18", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x19, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x19", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x20, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x20", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x21, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x21", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x22, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x22", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x23, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x23", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x24, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x24", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x25, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x25", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x26, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x26", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x27, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x27", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x28, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x28", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x29, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x29", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x30, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x30", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x31, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x31", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x32, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x32", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x33, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x33", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x34, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x34", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x35, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x35", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x36, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x36", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x37, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x37", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x38, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x38", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x39, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x39", outvar);
-
-	outvar = mxCreateDoubleMatrix(17, 1, mxREAL);
-	copyCArrayToM_double( output.x40, mxGetPr(outvar), 17);
-	mxSetField(plhs[0], 0, "x40", outvar);
-
-
-
-	/* copy exitflag */
-	if( nlhs > 1 )
-	{
-	plhs[1] = mxCreateDoubleMatrix(1, 1, mxREAL);
-	*mxGetPr(plhs[1]) = (double)exitflag;
-	}
-
-	/* copy info struct */
-	if( nlhs > 2 )
-	{
-	        plhs[2] = mxCreateStructMatrix(1, 1, 7, infofields);
-        
-		/* iterations */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = (double)info.it;
-		mxSetField(plhs[2], 0, "it", outvar);
-
-		/* res_eq */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.res_eq;
-		mxSetField(plhs[2], 0, "res_eq", outvar);
-
-		/* rsnorm */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.rsnorm;
-		mxSetField(plhs[2], 0, "rsnorm", outvar);
-
-		/* pobj */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.pobj;
-		mxSetField(plhs[2], 0, "pobj", outvar);
-
-		/* solver time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.solvetime;
-		mxSetField(plhs[2], 0, "solvetime", outvar);
-
-		/* fevals time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.fevalstime;
-		mxSetField(plhs[2], 0, "fevalstime", outvar);
-		
-		/* QP time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.QPtime;
-		mxSetField(plhs[2], 0, "QPtime", outvar);		
-
-	}
-}
Index: FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c b/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17}; 
-    const solver_int neqArr[NSTAGES] = {13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
-    const solver_int dimlArr[NSTAGES] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-    const solver_int dimuArr[NSTAGES] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES-1) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES-1));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* c_mex;
-	mxArray* jacc_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	c_mex = mxCreateDoubleMatrix(neq, 1, mxREAL);
-	jacc_mex = mxCreateDoubleMatrix(neq, nvar, mxREAL);
-	copyCArrayToM_FORCENLPsolver(c, mxGetPr(c_mex), neq);
-	copyCArrayToM_FORCENLPsolver(jacc, mxGetPr(jacc_mex), neq*nvar);
-	plhs[0] = c_mex;
-	plhs[1] = jacc_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: model/FORCENLPsolver/FORCENLPsolver_model.h
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_model.h b/model/FORCENLPsolver/FORCENLPsolver_model.h
deleted file mode 100644
--- a/model/FORCENLPsolver/FORCENLPsolver_model.h	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,53 +0,0 @@
-
-
-#ifndef FORCENLPSOLVER_MODEL_H
-#include "include/FORCENLPsolver.h"
-#define FORCENLPSOLVER_MODEL_H
-/* This file was automatically generated by CasADi.
-   The CasADi copyright holders make no ownership claim of its contents. */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef casadi_real
-#define casadi_real FORCENLPsolver_float
-#endif
-
-#ifndef casadi_int
-#define casadi_int solver_int32_default
-#endif
-
-int FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_inequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_inequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dinequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dinequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_inequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_inequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dinequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_dinequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-#endif
\ No newline at end of file
Index: FORCENLPsolver/python_static_interface.template.c
===================================================================
diff --git a/FORCENLPsolver/python_static_interface.template.c b/FORCENLPsolver/python_static_interface.template.c
deleted file mode 100644
--- a/FORCENLPsolver/python_static_interface.template.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,31 +0,0 @@
-/* This template is used when statically linking a solver and its external
- * evaluation functions (for nonlinearties). It simply exports a function that
- * is essentially a closure around the solver function, with the last argument
- * (the pointer to the external evaluation function) fixed.
- *
- * The template is used by setting the following preprocessor macros:
- *  - FORCENLPsolver
- *  - "include/FORCENLPsolver.h"
- *  - FORCENLPsolver_casadi2forces
- *  - FORCENLPsolver_interface
- *
- * Compare also the MEX interface, which exists for a similar purpose in the
- * MATLAB client. */
-
-#define CONCAT(x, y) x ## y
-#define CONCATENATE(x, y) CONCAT(x, y)
-#define SOLVER_FLOAT CONCATENATE(FORCENLPsolver, _float)
-#define SOLVER_FUN_NAME CONCATENATE(FORCENLPsolver, _solve)
-
-#include "include/FORCENLPsolver.h"
-
-/* Header of external evaluation function */
-void FORCENLPsolver_casadi2forces(SOLVER_FLOAT *x, SOLVER_FLOAT *y, SOLVER_FLOAT *l,
-                   SOLVER_FLOAT *p, SOLVER_FLOAT *f, SOLVER_FLOAT *nabla_f,
-                   SOLVER_FLOAT *c, SOLVER_FLOAT *nabla_c, SOLVER_FLOAT *h,
-                   SOLVER_FLOAT *nabla_h, SOLVER_FLOAT *hess,
-                   solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-
-int FORCENLPsolver_interface(void *params, void *outputs, void *info, FILE *fp) {
-    return SOLVER_FUN_NAME(params, outputs, info, fp, &FORCENLPsolver_casadi2forces);
-}
Index: FORCENLPsolver/include/FORCENLPsolver.h
===================================================================
diff --git a/FORCENLPsolver/include/FORCENLPsolver.h b/FORCENLPsolver/include/FORCENLPsolver.h
deleted file mode 100644
--- a/FORCENLPsolver/include/FORCENLPsolver.h	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,321 +0,0 @@
-#ifndef FORCENLPsolver_H
-#define FORCENLPsolver_H
-/* Generated by FORCESPRO v5.1.0 on Monday, February 21, 2022 at 8:39:22 PM */
-
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#include <stddef.h>
-#endif
-
-
-/* DATA TYPE ------------------------------------------------------------*/
-typedef double FORCENLPsolver_float;
-typedef double FORCENLPsolver_callback_float;
-typedef double FORCENLPsolverinterface_float;
-typedef int FORCENLPsolver_int;
-
-#ifndef SOLVER_STANDARD_TYPES
-#define SOLVER_STANDARD_TYPES
-
-typedef signed char solver_int8_signed;
-typedef unsigned char solver_int8_unsigned;
-typedef char solver_int8_default;
-typedef signed short int solver_int16_signed;
-typedef unsigned short int solver_int16_unsigned;
-typedef short int solver_int16_default;
-typedef signed int solver_int32_signed;
-typedef unsigned int solver_int32_unsigned;
-typedef int solver_int32_default;
-typedef signed long long int solver_int64_signed;
-typedef unsigned long long int solver_int64_unsigned;
-typedef long long int solver_int64_default;
-
-#endif
-
-/* SOLVER SETTINGS ------------------------------------------------------*/
-
-/* MISRA-C compliance */
-#ifndef MISRA_C_FORCENLPsolver
-#define MISRA_C_FORCENLPsolver (0)
-#endif
-
-/* restrict code */
-#ifndef RESTRICT_CODE_FORCENLPsolver
-#define RESTRICT_CODE_FORCENLPsolver (0)
-#endif
-
-/* print level */
-#ifndef SET_PRINTLEVEL_FORCENLPsolver
-#define SET_PRINTLEVEL_FORCENLPsolver    (0)
-#endif
-
-/* timing */
-#ifndef SET_TIMING_FORCENLPsolver
-#define SET_TIMING_FORCENLPsolver    (1)
-#endif
-
-/* Numeric Warnings */
-/* #define PRINTNUMERICALWARNINGS */
-
-/* maximum number of iterations  */
-#define SET_MAXIT_FORCENLPsolver			(200)	 
-
-/* desired maximum residual on equality constraints */
-#define SET_ACC_RESEQ_FORCENLPsolver		(FORCENLPsolver_float)(1E-06)
-
-
-/* RETURN CODES----------------------------------------------------------*/
-/* solver has converged within desired accuracy */
-#define OPTIMAL_FORCENLPsolver      (1)
-
-/* maximum number of iterations has been reached */
-#define MAXITREACHED_FORCENLPsolver (0)
-
-/* solver has stopped due to a timeout */
-#define TIMEOUT_FORCENLPsolver   (2)
-
-/* NaN encountered in function evaluations */
-#define BADFUNCEVAL_FORCENLPsolver  (-6)
-
-/* no progress in method possible */
-#define NOPROGRESS_FORCENLPsolver   (-7)
-
-/* regularization error */
-#define REGULARIZATION_ERROR_FORCENLPsolver   (-9)
-
-/* invalid values in parameters */
-#define PARAM_VALUE_ERROR_FORCENLPsolver   (-11)
-
-/* too small timeout given */
-#define INVALID_TIMEOUT_FORCENLPsolver   (-12)
-
-/* error in linesearch */
-#define LINESEARCH_ERROR_FORCENLPsolver   (-13)
-
-/* thread error */
-#define THREAD_FAILURE_FORCENLPsolver  (-98)
-
-/* locking mechanism error */
-#define LOCK_FAILURE_FORCENLPsolver  (-99)
-
-/* licensing error - solver not valid on this machine */
-#define LICENSE_ERROR_FORCENLPsolver  (-100)
-
-/* qp solver error */
-#define QP_SOLVER_FAILURE_FORCENLPsolver (-8)
-
-
-/* INTEGRATORS RETURN CODE ------------*/
-/* Integrator ran successfully */
-#define INTEGRATOR_SUCCESS (11)
-/* Number of steps set by user exceeds maximum number of steps allowed */
-#define INTEGRATOR_MAXSTEPS_EXCEEDED (12)
-
-/* PARAMETERS -----------------------------------------------------------*/
-/* fill this with data before calling the solver! */
-typedef struct
-{
-	    /* vector of size 160 */
-    FORCENLPsolver_float lb[160];
-
-    /* vector of size 160 */
-    FORCENLPsolver_float ub[160];
-
-    /* vector of size 13 */
-    FORCENLPsolver_float xinit[13];
-
-    /* vector of size 680 */
-    FORCENLPsolver_float x0[680];
-
-    /* vector of size 360 */
-    FORCENLPsolver_float all_parameters[360];
-
-    /* scalar */
-    FORCENLPsolver_int reinitialize;
-
-
-} FORCENLPsolver_params;
-
-
-/* OUTPUTS --------------------------------------------------------------*/
-/* the desired variables are put here by the solver */
-typedef struct
-{
-	    /* vector of size 17 */
-    FORCENLPsolver_float x01[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x02[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x03[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x04[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x05[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x06[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x07[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x08[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x09[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x10[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x11[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x12[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x13[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x14[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x15[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x16[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x17[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x18[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x19[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x20[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x21[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x22[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x23[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x24[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x25[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x26[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x27[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x28[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x29[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x30[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x31[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x32[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x33[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x34[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x35[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x36[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x37[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x38[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x39[17];
-
-    /* vector of size 17 */
-    FORCENLPsolver_float x40[17];
-
-
-} FORCENLPsolver_output;
-
-
-/* SOLVER INFO ----------------------------------------------------------*/
-/* diagnostic data from last interior point step */
-typedef struct
-{
-	/* iteration number */
-	solver_int32_default it;
-
-	/* inf-norm of equality constraint residuals */
-	FORCENLPsolver_float res_eq;
-
-	/* norm of stationarity condition */
-	FORCENLPsolver_float rsnorm;
-
-	/* primal objective */
-	FORCENLPsolver_float pobj;
-
-	/* total solve time */
-	FORCENLPsolver_float solvetime;
-
-	/* time spent in function evaluations */
-	FORCENLPsolver_float fevalstime;
-
-	/* time spent solving QPs */
-	FORCENLPsolver_float QPtime;
-} FORCENLPsolver_info;
-
-
-
-/* SOLVER FUNCTION DEFINITION -------------------------------------------*/
-/* Time of Solver Generation: (UTC) Monday, February 21, 2022 8:39:24 PM */
-/* User License expires on: (UTC) Wednesday, June 1, 2022 10:00:00 PM (approx.) (at the time of code generation) */
-/* Solver Static License expires on: (UTC) Wednesday, June 1, 2022 10:00:00 PM (approx.) */
-/* Solver Generation Request Id: 6dea281c-d472-4786-8b1d-ed254c4782d6 */
-/* examine exitflag before using the result! */
-#ifdef __cplusplus
-extern "C" {
-#endif		
-
-typedef void(*FORCENLPsolver_extfunc)(FORCENLPsolver_float* x, FORCENLPsolver_float* y, FORCENLPsolver_float* lambda, FORCENLPsolver_float* params, FORCENLPsolver_float* pobj, FORCENLPsolver_float* g, FORCENLPsolver_float* c, FORCENLPsolver_float* Jeq, FORCENLPsolver_float* h, FORCENLPsolver_float* Jineq, FORCENLPsolver_float* H, solver_int32_default stage, solver_int32_default iterations, solver_int32_default threadID);
-
-extern solver_int32_default FORCENLPsolver_solve(FORCENLPsolver_params *params, FORCENLPsolver_output *output, FORCENLPsolver_info *info, FILE *fs, FORCENLPsolver_extfunc evalextfunctions_FORCENLPsolver);
-
-
-
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
Index: FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c b/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,755 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-
-#define S_FUNCTION_LEVEL 2
-#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlock
-
-#include "simstruc.h"
-
-
-
-/* include FORCESPRO functions and defs */
-#include "../include/FORCENLPsolver.h" 
-
-/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */
-
-
-#if defined(MATLAB_MEX_FILE)
-#include "tmwtypes.h"
-#include "simstruc_types.h"
-#else
-#include "rtwtypes.h"
-#endif
-
-typedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;
-
-extern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-
-
-/*====================*
- * S-function methods *
- *====================*/
-/* Function: mdlInitializeSizes =========================================
- * Abstract:
- *   Setup sizes of the various vectors.
- */
-static void mdlInitializeSizes(SimStruct *S)
-{
-
-    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
-    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
-    ssSetNumSFcnParams(S, 0);
-    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
-	{
-		return; /* Parameter mismatch will be reported by Simulink */
-    }
-
-	/* initialize size of continuous and discrete states to zero */
-    ssSetNumContStates(S, 0);
-    ssSetNumDiscStates(S, 0);
-
-	/* initialize input ports - there are 6 in total */
-    if (!ssSetNumInputPorts(S, 6)) return;
-    	
-	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 160, 1);
-    ssSetInputPortDataType(S, 0, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
-	
-	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 160, 1);
-    ssSetInputPortDataType(S, 1, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/
-	
-	/* Input Port 2 */
-    ssSetInputPortMatrixDimensions(S,  2, 13, 1);
-    ssSetInputPortDataType(S, 2, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/
-	
-	/* Input Port 3 */
-    ssSetInputPortMatrixDimensions(S,  3, 680, 1);
-    ssSetInputPortDataType(S, 3, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/
-	
-	/* Input Port 4 */
-    ssSetInputPortMatrixDimensions(S,  4, 360, 1);
-    ssSetInputPortDataType(S, 4, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 4, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 4, 1); /*direct input signal access*/
-	
-	/* Input Port 5 */
-    ssSetInputPortMatrixDimensions(S,  5, 1, 1);
-    ssSetInputPortDataType(S, 5, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 5, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 5, 1); /*direct input signal access*/
- 
-
-
-	/* initialize output ports - there are 40 in total */
-    if (!ssSetNumOutputPorts(S, 40)) return;    
-		
-	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 17, 1);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 1 */
-    ssSetOutputPortMatrixDimensions(S,  1, 17, 1);
-    ssSetOutputPortDataType(S, 1, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 2 */
-    ssSetOutputPortMatrixDimensions(S,  2, 17, 1);
-    ssSetOutputPortDataType(S, 2, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 3 */
-    ssSetOutputPortMatrixDimensions(S,  3, 17, 1);
-    ssSetOutputPortDataType(S, 3, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 4 */
-    ssSetOutputPortMatrixDimensions(S,  4, 17, 1);
-    ssSetOutputPortDataType(S, 4, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 5 */
-    ssSetOutputPortMatrixDimensions(S,  5, 17, 1);
-    ssSetOutputPortDataType(S, 5, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 6 */
-    ssSetOutputPortMatrixDimensions(S,  6, 17, 1);
-    ssSetOutputPortDataType(S, 6, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 6, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 7 */
-    ssSetOutputPortMatrixDimensions(S,  7, 17, 1);
-    ssSetOutputPortDataType(S, 7, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 7, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 8 */
-    ssSetOutputPortMatrixDimensions(S,  8, 17, 1);
-    ssSetOutputPortDataType(S, 8, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 8, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 9 */
-    ssSetOutputPortMatrixDimensions(S,  9, 17, 1);
-    ssSetOutputPortDataType(S, 9, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 9, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 10 */
-    ssSetOutputPortMatrixDimensions(S,  10, 17, 1);
-    ssSetOutputPortDataType(S, 10, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 10, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 11 */
-    ssSetOutputPortMatrixDimensions(S,  11, 17, 1);
-    ssSetOutputPortDataType(S, 11, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 11, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 12 */
-    ssSetOutputPortMatrixDimensions(S,  12, 17, 1);
-    ssSetOutputPortDataType(S, 12, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 12, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 13 */
-    ssSetOutputPortMatrixDimensions(S,  13, 17, 1);
-    ssSetOutputPortDataType(S, 13, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 13, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 14 */
-    ssSetOutputPortMatrixDimensions(S,  14, 17, 1);
-    ssSetOutputPortDataType(S, 14, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 14, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 15 */
-    ssSetOutputPortMatrixDimensions(S,  15, 17, 1);
-    ssSetOutputPortDataType(S, 15, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 15, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 16 */
-    ssSetOutputPortMatrixDimensions(S,  16, 17, 1);
-    ssSetOutputPortDataType(S, 16, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 16, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 17 */
-    ssSetOutputPortMatrixDimensions(S,  17, 17, 1);
-    ssSetOutputPortDataType(S, 17, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 17, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 18 */
-    ssSetOutputPortMatrixDimensions(S,  18, 17, 1);
-    ssSetOutputPortDataType(S, 18, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 18, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 19 */
-    ssSetOutputPortMatrixDimensions(S,  19, 17, 1);
-    ssSetOutputPortDataType(S, 19, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 19, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 20 */
-    ssSetOutputPortMatrixDimensions(S,  20, 17, 1);
-    ssSetOutputPortDataType(S, 20, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 20, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 21 */
-    ssSetOutputPortMatrixDimensions(S,  21, 17, 1);
-    ssSetOutputPortDataType(S, 21, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 21, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 22 */
-    ssSetOutputPortMatrixDimensions(S,  22, 17, 1);
-    ssSetOutputPortDataType(S, 22, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 22, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 23 */
-    ssSetOutputPortMatrixDimensions(S,  23, 17, 1);
-    ssSetOutputPortDataType(S, 23, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 23, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 24 */
-    ssSetOutputPortMatrixDimensions(S,  24, 17, 1);
-    ssSetOutputPortDataType(S, 24, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 24, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 25 */
-    ssSetOutputPortMatrixDimensions(S,  25, 17, 1);
-    ssSetOutputPortDataType(S, 25, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 25, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 26 */
-    ssSetOutputPortMatrixDimensions(S,  26, 17, 1);
-    ssSetOutputPortDataType(S, 26, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 26, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 27 */
-    ssSetOutputPortMatrixDimensions(S,  27, 17, 1);
-    ssSetOutputPortDataType(S, 27, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 27, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 28 */
-    ssSetOutputPortMatrixDimensions(S,  28, 17, 1);
-    ssSetOutputPortDataType(S, 28, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 28, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 29 */
-    ssSetOutputPortMatrixDimensions(S,  29, 17, 1);
-    ssSetOutputPortDataType(S, 29, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 29, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 30 */
-    ssSetOutputPortMatrixDimensions(S,  30, 17, 1);
-    ssSetOutputPortDataType(S, 30, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 30, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 31 */
-    ssSetOutputPortMatrixDimensions(S,  31, 17, 1);
-    ssSetOutputPortDataType(S, 31, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 31, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 32 */
-    ssSetOutputPortMatrixDimensions(S,  32, 17, 1);
-    ssSetOutputPortDataType(S, 32, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 32, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 33 */
-    ssSetOutputPortMatrixDimensions(S,  33, 17, 1);
-    ssSetOutputPortDataType(S, 33, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 33, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 34 */
-    ssSetOutputPortMatrixDimensions(S,  34, 17, 1);
-    ssSetOutputPortDataType(S, 34, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 34, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 35 */
-    ssSetOutputPortMatrixDimensions(S,  35, 17, 1);
-    ssSetOutputPortDataType(S, 35, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 35, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 36 */
-    ssSetOutputPortMatrixDimensions(S,  36, 17, 1);
-    ssSetOutputPortDataType(S, 36, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 36, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 37 */
-    ssSetOutputPortMatrixDimensions(S,  37, 17, 1);
-    ssSetOutputPortDataType(S, 37, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 37, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 38 */
-    ssSetOutputPortMatrixDimensions(S,  38, 17, 1);
-    ssSetOutputPortDataType(S, 38, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 38, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 39 */
-    ssSetOutputPortMatrixDimensions(S,  39, 17, 1);
-    ssSetOutputPortDataType(S, 39, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 39, COMPLEX_NO); /* no complex signals suppported */
-
-
-	/* set sampling time */
-    ssSetNumSampleTimes(S, 1);
-
-	/* set internal memory of block */
-    ssSetNumRWork(S, 0);
-    ssSetNumIWork(S, 0);
-    ssSetNumPWork(S, 0);
-    ssSetNumModes(S, 0);
-    ssSetNumNonsampledZCs(S, 0);
-
-    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
-		             SS_OPTION_WORKS_WITH_CODE_REUSE)); */
-	ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );
-
-	
-}
-
-#if defined(MATLAB_MEX_FILE)
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-static void mdlSetInputPortDimensionInfo(SimStruct        *S, 
-                                         int_T            port,
-                                         const DimsInfo_T *dimsInfo)
-{
-    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)
-static void mdlSetOutputPortDimensionInfo(SimStruct        *S, 
-                                          int_T            port, 
-                                          const DimsInfo_T *dimsInfo)
-{
-    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-# define MDL_SET_INPUT_PORT_FRAME_DATA
-static void mdlSetInputPortFrameData(SimStruct  *S, 
-                                     int_T      port,
-                                     Frame_T    frameData)
-{
-    ssSetInputPortFrameData(S, port, frameData);
-}
-/* Function: mdlInitializeSampleTimes =========================================
- * Abstract:
- *    Specifiy  the sample time.
- */
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
-    ssSetOffsetTime(S, 0, 0.0);
-}
-
-#define MDL_SET_INPUT_PORT_DATA_TYPE
-static void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetInputPortDataType( S, 0, dType);
-}
-#define MDL_SET_OUTPUT_PORT_DATA_TYPE
-static void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetOutputPortDataType(S, 0, dType);
-}
-
-#define MDL_SET_DEFAULT_PORT_DATA_TYPES
-static void mdlSetDefaultPortDataTypes(SimStruct *S)
-{
-    ssSetInputPortDataType( S, 0, SS_DOUBLE);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-}
-
-
-
-
-
-/* Function: mdlOutputs =======================================================
- *
-*/
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	solver_int32_default i, j, k;
-	
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* Simulink data */
-	const real_T *lb = (const real_T*) ssGetInputPortSignal(S,0);
-	const real_T *ub = (const real_T*) ssGetInputPortSignal(S,1);
-	const real_T *xinit = (const real_T*) ssGetInputPortSignal(S,2);
-	const real_T *x0 = (const real_T*) ssGetInputPortSignal(S,3);
-	const real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,4);
-	const FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,5);
-	
-    real_T *x01 = (real_T*) ssGetOutputPortSignal(S,0);
-	real_T *x02 = (real_T*) ssGetOutputPortSignal(S,1);
-	real_T *x03 = (real_T*) ssGetOutputPortSignal(S,2);
-	real_T *x04 = (real_T*) ssGetOutputPortSignal(S,3);
-	real_T *x05 = (real_T*) ssGetOutputPortSignal(S,4);
-	real_T *x06 = (real_T*) ssGetOutputPortSignal(S,5);
-	real_T *x07 = (real_T*) ssGetOutputPortSignal(S,6);
-	real_T *x08 = (real_T*) ssGetOutputPortSignal(S,7);
-	real_T *x09 = (real_T*) ssGetOutputPortSignal(S,8);
-	real_T *x10 = (real_T*) ssGetOutputPortSignal(S,9);
-	real_T *x11 = (real_T*) ssGetOutputPortSignal(S,10);
-	real_T *x12 = (real_T*) ssGetOutputPortSignal(S,11);
-	real_T *x13 = (real_T*) ssGetOutputPortSignal(S,12);
-	real_T *x14 = (real_T*) ssGetOutputPortSignal(S,13);
-	real_T *x15 = (real_T*) ssGetOutputPortSignal(S,14);
-	real_T *x16 = (real_T*) ssGetOutputPortSignal(S,15);
-	real_T *x17 = (real_T*) ssGetOutputPortSignal(S,16);
-	real_T *x18 = (real_T*) ssGetOutputPortSignal(S,17);
-	real_T *x19 = (real_T*) ssGetOutputPortSignal(S,18);
-	real_T *x20 = (real_T*) ssGetOutputPortSignal(S,19);
-	real_T *x21 = (real_T*) ssGetOutputPortSignal(S,20);
-	real_T *x22 = (real_T*) ssGetOutputPortSignal(S,21);
-	real_T *x23 = (real_T*) ssGetOutputPortSignal(S,22);
-	real_T *x24 = (real_T*) ssGetOutputPortSignal(S,23);
-	real_T *x25 = (real_T*) ssGetOutputPortSignal(S,24);
-	real_T *x26 = (real_T*) ssGetOutputPortSignal(S,25);
-	real_T *x27 = (real_T*) ssGetOutputPortSignal(S,26);
-	real_T *x28 = (real_T*) ssGetOutputPortSignal(S,27);
-	real_T *x29 = (real_T*) ssGetOutputPortSignal(S,28);
-	real_T *x30 = (real_T*) ssGetOutputPortSignal(S,29);
-	real_T *x31 = (real_T*) ssGetOutputPortSignal(S,30);
-	real_T *x32 = (real_T*) ssGetOutputPortSignal(S,31);
-	real_T *x33 = (real_T*) ssGetOutputPortSignal(S,32);
-	real_T *x34 = (real_T*) ssGetOutputPortSignal(S,33);
-	real_T *x35 = (real_T*) ssGetOutputPortSignal(S,34);
-	real_T *x36 = (real_T*) ssGetOutputPortSignal(S,35);
-	real_T *x37 = (real_T*) ssGetOutputPortSignal(S,36);
-	real_T *x38 = (real_T*) ssGetOutputPortSignal(S,37);
-	real_T *x39 = (real_T*) ssGetOutputPortSignal(S,38);
-	real_T *x40 = (real_T*) ssGetOutputPortSignal(S,39);
-	
-	
-
-	/* Solver data */
-	static FORCENLPsolver_params params;
-	static FORCENLPsolver_output output;
-	static FORCENLPsolver_info info;	
-	solver_int32_default exitflag;
-
-	/* Extra NMPC data */
-	
-
-	/* Copy inputs */
-	for( i=0; i<160; i++)
-	{ 
-		params.lb[i] = (double) lb[i]; 
-	}
-
-	for( i=0; i<160; i++)
-	{ 
-		params.ub[i] = (double) ub[i]; 
-	}
-
-	for( i=0; i<13; i++)
-	{ 
-		params.xinit[i] = (double) xinit[i]; 
-	}
-
-	for( i=0; i<680; i++)
-	{ 
-		params.x0[i] = (double) x0[i]; 
-	}
-
-	for( i=0; i<360; i++)
-	{ 
-		params.all_parameters[i] = (double) all_parameters[i]; 
-	}
-
-	params.reinitialize = *reinitialize;
-
-	
-
-	
-
-    #if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* Call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			ssPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	
-
-	/* Copy outputs */
-	for( i=0; i<17; i++)
-	{ 
-		x01[i] = (real_T) output.x01[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x02[i] = (real_T) output.x02[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x03[i] = (real_T) output.x03[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x04[i] = (real_T) output.x04[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x05[i] = (real_T) output.x05[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x06[i] = (real_T) output.x06[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x07[i] = (real_T) output.x07[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x08[i] = (real_T) output.x08[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x09[i] = (real_T) output.x09[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x10[i] = (real_T) output.x10[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x11[i] = (real_T) output.x11[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x12[i] = (real_T) output.x12[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x13[i] = (real_T) output.x13[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x14[i] = (real_T) output.x14[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x15[i] = (real_T) output.x15[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x16[i] = (real_T) output.x16[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x17[i] = (real_T) output.x17[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x18[i] = (real_T) output.x18[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x19[i] = (real_T) output.x19[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x20[i] = (real_T) output.x20[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x21[i] = (real_T) output.x21[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x22[i] = (real_T) output.x22[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x23[i] = (real_T) output.x23[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x24[i] = (real_T) output.x24[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x25[i] = (real_T) output.x25[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x26[i] = (real_T) output.x26[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x27[i] = (real_T) output.x27[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x28[i] = (real_T) output.x28[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x29[i] = (real_T) output.x29[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x30[i] = (real_T) output.x30[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x31[i] = (real_T) output.x31[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x32[i] = (real_T) output.x32[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x33[i] = (real_T) output.x33[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x34[i] = (real_T) output.x34[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x35[i] = (real_T) output.x35[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x36[i] = (real_T) output.x36[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x37[i] = (real_T) output.x37[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x38[i] = (real_T) output.x38[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x39[i] = (real_T) output.x39[i]; 
-	}
-
-	for( i=0; i<17; i++)
-	{ 
-		x40[i] = (real_T) output.x40[i]; 
-	}
-
-	
-}
-
-
-
-
-
-/* Function: mdlTerminate =====================================================
- * Abstract:
- *    In this function, you should perform any actions that are necessary
- *    at the termination of a simulation.  For example, if memory was
- *    allocated in mdlStart, this is the place to free it.
- */
-static void mdlTerminate(SimStruct *S)
-{
-}
-#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
-#include "simulink.c"      /* MEX-file interface mechanism */
-#else
-#include "cg_sfun.h"       /* Code generation registration function */
-#endif
-
-
Index: model/FORCENLPsolver/interface/FORCENLPsolver_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,446 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_double(double *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyMArrayToC_double(double *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double) (*src++) ;
-    }
-}
-
-void copyMValueToC_double(double * src, double * dest)
-{
-	*dest = (double) *src;
-}
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver_int(FORCENLPsolver_int *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyMArrayToC_FORCENLPsolver_int(double *src, FORCENLPsolver_int *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_int) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver_int(double * src, FORCENLPsolver_int * dest)
-{
-	*dest = (FORCENLPsolver_int) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-/* Some memory for mex-function */
-static FORCENLPsolver_params params;
-static FORCENLPsolver_output output;
-static FORCENLPsolver_info info;
-
-/* THE mex-function */
-void mexFunction( solver_int32_default nlhs, mxArray *plhs[], solver_int32_default nrhs, const mxArray *prhs[] )  
-{
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* define variables */	
-	mxArray *par;
-	mxArray *outvar;
-	const mxArray *PARAMS = prhs[0]; 
-	double *pvalue;
-	solver_int32_default i;
-	solver_int32_default exitflag;
-	const solver_int8_default *fname;
-	const solver_int8_default *outputnames[40] = {"x01","x02","x03","x04","x05","x06","x07","x08","x09","x10","x11","x12","x13","x14","x15","x16","x17","x18","x19","x20","x21","x22","x23","x24","x25","x26","x27","x28","x29","x30","x31","x32","x33","x34","x35","x36","x37","x38","x39","x40"};
-	const solver_int8_default *infofields[7] = { "it", "res_eq", "rsnorm", "pobj", "solvetime",  "fevalstime", "QPtime"};
-	
-	/* Check for proper number of arguments */
-    if (nrhs != 1)
-	{
-		mexErrMsgTxt("This function requires exactly 1 input: PARAMS struct.\nType 'help FORCENLPsolver_mex' for details.");
-	}    
-	if (nlhs > 3) 
-	{
-        mexErrMsgTxt("This function returns at most 3 outputs.\nType 'help FORCENLPsolver_mex' for details.");
-    }
-
-	/* Check whether params is actually a structure */
-	if( !mxIsStruct(PARAMS) ) 
-	{
-		mexErrMsgTxt("PARAMS must be a structure.");
-	}
-	 
-
-	/* copy parameters into the right location */
-	par = mxGetField(PARAMS, 0, "xinit");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.xinit not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.xinit must be a double.");
-    }
-    if( mxGetM(par) != 3 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.xinit must be of size [3 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.xinit,3);
-
-	}
-	par = mxGetField(PARAMS, 0, "x0");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.x0 not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.x0 must be a double.");
-    }
-    if( mxGetM(par) != 200 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.x0 must be of size [200 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.x0,200);
-
-	}
-	par = mxGetField(PARAMS, 0, "all_parameters");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.all_parameters not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.all_parameters must be a double.");
-    }
-    if( mxGetM(par) != 120 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.all_parameters must be of size [120 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.all_parameters,120);
-
-	}
-	par = mxGetField(PARAMS, 0, "reinitialize");
-	if ( (par != NULL) && (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMValueToC_FORCENLPsolver_int(mxGetPr(par), &params.reinitialize);
-
-	}
-
-
-
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp, pt2function_FORCENLPsolver);
-	
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			mexPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	/* copy output to matlab arrays */
-	plhs[0] = mxCreateStructMatrix(1, 1, 40, outputnames);
-		outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x01, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x01", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x02, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x02", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x03, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x03", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x04, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x04", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x05, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x05", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x06, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x06", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x07, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x07", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x08, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x08", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x09, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x09", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x10, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x10", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x11, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x11", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x12, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x12", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x13, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x13", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x14, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x14", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x15, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x15", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x16, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x16", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x17, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x17", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x18, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x18", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x19, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x19", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x20, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x20", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x21, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x21", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x22, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x22", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x23, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x23", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x24, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x24", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x25, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x25", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x26, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x26", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x27, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x27", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x28, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x28", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x29, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x29", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x30, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x30", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x31, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x31", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x32, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x32", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x33, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x33", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x34, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x34", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x35, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x35", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x36, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x36", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x37, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x37", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x38, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x38", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x39, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x39", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x40, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x40", outvar);
-
-
-
-	/* copy exitflag */
-	if( nlhs > 1 )
-	{
-	plhs[1] = mxCreateDoubleMatrix(1, 1, mxREAL);
-	*mxGetPr(plhs[1]) = (double)exitflag;
-	}
-
-	/* copy info struct */
-	if( nlhs > 2 )
-	{
-	        plhs[2] = mxCreateStructMatrix(1, 1, 7, infofields);
-        
-		/* iterations */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = (double)info.it;
-		mxSetField(plhs[2], 0, "it", outvar);
-
-		/* res_eq */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.res_eq;
-		mxSetField(plhs[2], 0, "res_eq", outvar);
-
-		/* rsnorm */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.rsnorm;
-		mxSetField(plhs[2], 0, "rsnorm", outvar);
-
-		/* pobj */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.pobj;
-		mxSetField(plhs[2], 0, "pobj", outvar);
-
-		/* solver time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.solvetime;
-		mxSetField(plhs[2], 0, "solvetime", outvar);
-
-		/* fevals time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.fevalstime;
-		mxSetField(plhs[2], 0, "fevalstime", outvar);
-		
-		/* QP time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.QPtime;
-		mxSetField(plhs[2], 0, "QPtime", outvar);		
-
-	}
-}
Index: model/FORCENLPsolver/python_static_interface.template.c
===================================================================
diff --git a/model/FORCENLPsolver/python_static_interface.template.c b/model/FORCENLPsolver/python_static_interface.template.c
deleted file mode 100644
--- a/model/FORCENLPsolver/python_static_interface.template.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,31 +0,0 @@
-/* This template is used when statically linking a solver and its external
- * evaluation functions (for nonlinearties). It simply exports a function that
- * is essentially a closure around the solver function, with the last argument
- * (the pointer to the external evaluation function) fixed.
- *
- * The template is used by setting the following preprocessor macros:
- *  - FORCENLPsolver
- *  - "include/FORCENLPsolver.h"
- *  - FORCENLPsolver_casadi2forces
- *  - FORCENLPsolver_interface
- *
- * Compare also the MEX interface, which exists for a similar purpose in the
- * MATLAB client. */
-
-#define CONCAT(x, y) x ## y
-#define CONCATENATE(x, y) CONCAT(x, y)
-#define SOLVER_FLOAT CONCATENATE(FORCENLPsolver, _float)
-#define SOLVER_FUN_NAME CONCATENATE(FORCENLPsolver, _solve)
-
-#include "include/FORCENLPsolver.h"
-
-/* Header of external evaluation function */
-void FORCENLPsolver_casadi2forces(SOLVER_FLOAT *x, SOLVER_FLOAT *y, SOLVER_FLOAT *l,
-                   SOLVER_FLOAT *p, SOLVER_FLOAT *f, SOLVER_FLOAT *nabla_f,
-                   SOLVER_FLOAT *c, SOLVER_FLOAT *nabla_c, SOLVER_FLOAT *h,
-                   SOLVER_FLOAT *nabla_h, SOLVER_FLOAT *hess,
-                   solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-
-int FORCENLPsolver_interface(void *params, void *outputs, void *info, FILE *fp) {
-    return SOLVER_FUN_NAME(params, outputs, info, fp, &FORCENLPsolver_casadi2forces);
-}
Index: FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c b/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17}; 
-    const solver_int neqArr[NSTAGES] = {13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
-    const solver_int dimlArr[NSTAGES] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-    const solver_int dimuArr[NSTAGES] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* h_mex;
-	mxArray* jach_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	h_mex = mxCreateDoubleMatrix(dimh, 1, mxREAL);
-	jach_mex = mxCreateDoubleMatrix(dimh, nvar, mxREAL);
-	copyCArrayToM_FORCENLPsolver(h, mxGetPr(h_mex), dimh);
-	copyCArrayToM_FORCENLPsolver(jach, mxGetPr(jach_mex), dimh*nvar);
-	plhs[0] = h_mex;
-	plhs[1] = jach_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES-1) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES-1));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* c_mex;
-	mxArray* jacc_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	c_mex = mxCreateDoubleMatrix(neq, 1, mxREAL);
-	jacc_mex = mxCreateDoubleMatrix(neq, nvar, mxREAL);
-	copyCArrayToM_FORCENLPsolver(c, mxGetPr(c_mex), neq);
-	copyCArrayToM_FORCENLPsolver(jacc, mxGetPr(jacc_mex), neq*nvar);
-	plhs[0] = c_mex;
-	plhs[1] = jacc_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: FORCENLPsolver/FORCENLPsolver_interface.c
===================================================================
diff --git a/FORCENLPsolver/FORCENLPsolver_interface.c b/FORCENLPsolver/FORCENLPsolver_interface.c
deleted file mode 100644
--- a/FORCENLPsolver/FORCENLPsolver_interface.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,202 +0,0 @@
-/*
- * CasADi to FORCESPRO Template - missing information to be filled in by createCasadi.m 
- * (C) embotech AG, Zurich, Switzerland, 2013-2021. All rights reserved.
- *
- * This file is part of the FORCESPRO client, and carries the same license.
- */ 
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-    
-#include "include/FORCENLPsolver.h"
-
-#ifndef NULL
-#define NULL ((void *) 0)
-#endif
-
-#include "FORCENLPsolver_model.h"
-
-
-
-/* copies data from sparse matrix into a dense one */
-static void sparse2fullcopy(solver_int32_default nrow, solver_int32_default ncol, const solver_int32_default *colidx, const solver_int32_default *row, FORCENLPsolver_callback_float *data, FORCENLPsolver_float *out)
-{
-    solver_int32_default i, j;
-    
-    /* copy data into dense matrix */
-    for(i=0; i<ncol; i++)
-    {
-        for(j=colidx[i]; j<colidx[i+1]; j++)
-        {
-            out[i*nrow + row[j]] = ((FORCENLPsolver_float) data[j]);
-        }
-    }
-}
-
-
-
-
-/* CasADi to FORCESPRO interface */
-extern void FORCENLPsolver_casadi2forces(FORCENLPsolver_float *x,        /* primal vars                                         */
-                                 FORCENLPsolver_float *y,        /* eq. constraint multiplers                           */
-                                 FORCENLPsolver_float *l,        /* ineq. constraint multipliers                        */
-                                 FORCENLPsolver_float *p,        /* parameters                                          */
-                                 FORCENLPsolver_float *f,        /* objective function (scalar)                         */
-                                 FORCENLPsolver_float *nabla_f,  /* gradient of objective function                      */
-                                 FORCENLPsolver_float *c,        /* dynamics                                            */
-                                 FORCENLPsolver_float *nabla_c,  /* Jacobian of the dynamics (column major)             */
-                                 FORCENLPsolver_float *h,        /* inequality constraints                              */
-                                 FORCENLPsolver_float *nabla_h,  /* Jacobian of inequality constraints (column major)   */
-                                 FORCENLPsolver_float *hess,     /* Hessian (column major)                              */
-                                 solver_int32_default stage,     /* stage number (0 indexed)                           */
-								 solver_int32_default iteration, /* iteration number of solver                         */
-								 solver_int32_default threadID   /* Id of caller thread                                */)
-{
-    /* CasADi input and output arrays */
-    const FORCENLPsolver_callback_float *in[4];
-    FORCENLPsolver_callback_float *out[7];
-	
-
-	/* Allocate working arrays for CasADi */
-	FORCENLPsolver_float w[166];
-	
-    /* temporary storage for CasADi sparse output */
-    FORCENLPsolver_callback_float this_f;
-    FORCENLPsolver_float nabla_f_sparse[17];
-    FORCENLPsolver_float h_sparse[1];
-    FORCENLPsolver_float nabla_h_sparse[3];
-    FORCENLPsolver_float c_sparse[13];
-    FORCENLPsolver_float nabla_c_sparse[133];
-            
-    
-    /* pointers to row and column info for 
-     * column compressed format used by CasADi */
-    solver_int32_default nrow, ncol;
-    const solver_int32_default *colind, *row;
-    
-    /* set inputs for CasADi */
-    in[0] = x;
-    in[1] = p;
-    in[2] = l;
-    in[3] = y;
-
-	if ((0 <= stage && stage <= 38))
-	{
-		
-		
-		if( &this_f )
-		{
-			out[0] = &this_f;
-			FORCENLPsolver_objective_0(in, out, NULL, w, 0);
-		}
-		
-		if( nabla_f )
-		{
-			out[0] = nabla_f_sparse;
-			FORCENLPsolver_dobjective_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dobjective_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dobjective_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);
-		}
-		
-		if( c )
-		{
-			out[0] = c_sparse;
-			FORCENLPsolver_dynamics_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dynamics_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dynamics_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, c_sparse, c);
-		}
-		
-		if( nabla_c )
-		{
-			out[0] = nabla_c_sparse;
-			FORCENLPsolver_ddynamics_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_ddynamics_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_ddynamics_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_c_sparse, nabla_c);
-		}
-		
-		if( h )
-		{
-			out[0] = h_sparse;
-			FORCENLPsolver_inequalities_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_inequalities_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_inequalities_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_inequalities_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_inequalities_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, h_sparse, h);
-		}
-		
-		if( nabla_h )
-		{
-			out[0] = nabla_h_sparse;
-			FORCENLPsolver_dinequalities_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dinequalities_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dinequalities_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dinequalities_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dinequalities_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_h_sparse, nabla_h);
-		}
-	}
-	if ((39 == stage))
-	{
-		
-		
-		if( &this_f )
-		{
-			out[0] = &this_f;
-			FORCENLPsolver_objective_1(in, out, NULL, w, 0);
-		}
-		
-		if( nabla_f )
-		{
-			out[0] = nabla_f_sparse;
-			FORCENLPsolver_dobjective_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dobjective_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dobjective_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);
-		}
-		
-		if( h )
-		{
-			out[0] = h_sparse;
-			FORCENLPsolver_inequalities_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_inequalities_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_inequalities_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_inequalities_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_inequalities_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, h_sparse, h);
-		}
-		
-		if( nabla_h )
-		{
-			out[0] = nabla_h_sparse;
-			FORCENLPsolver_dinequalities_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dinequalities_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dinequalities_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dinequalities_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dinequalities_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_h_sparse, nabla_h);
-		}
-	}
-    
-    /* add to objective */
-    if (f != NULL)
-    {
-        *f += ((FORCENLPsolver_float) this_f);
-    }
-}
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
Index: FORCENLPsolver/interface/definitions.py
===================================================================
diff --git a/FORCENLPsolver/interface/definitions.py b/FORCENLPsolver/interface/definitions.py
deleted file mode 100644
--- a/FORCENLPsolver/interface/definitions.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,116 +0,0 @@
-import numpy
-import ctypes
-
-name = "FORCENLPsolver"
-requires_callback = True
-lib = "lib/libFORCENLPsolver.so"
-lib_static = "lib/libFORCENLPsolver.a"
-c_header = "include/FORCENLPsolver.h"
-nstages = 40
-
-# Parameter             | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
-params = \
-[("lb"                  , "dense" , ""               , ctypes.c_double, numpy.float64, (160,   1),  160),
- ("ub"                  , "dense" , ""               , ctypes.c_double, numpy.float64, (160,   1),  160),
- ("xinit"               , "dense" , ""               , ctypes.c_double, numpy.float64, ( 13,   1),   13),
- ("x0"                  , "dense" , ""               , ctypes.c_double, numpy.float64, (680,   1),  680),
- ("all_parameters"      , "dense" , ""               , ctypes.c_double, numpy.float64, (360,   1),  360),
- ("reinitialize"        , ""      , "FORCENLPsolver_int", ctypes.c_int   , numpy.int32  , (  0,   1),    1)]
-
-# Output                | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
-outputs = \
-[("x01"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x02"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x03"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x04"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x05"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x06"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x07"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x08"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x09"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x10"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x11"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x12"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x13"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x14"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x15"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x16"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x17"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x18"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x19"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x20"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x21"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x22"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x23"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x24"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x25"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x26"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x27"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x28"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x29"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x30"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x31"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x32"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x33"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x34"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x35"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x36"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x37"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x38"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x39"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17),
- ("x40"                 , ""      , ""               , ctypes.c_double, numpy.float64,     ( 17,),   17)]
-
-# Info Struct Fields
-info = \
-[("it", ctypes.c_int),
- ("res_eq", ctypes.c_double),
- ("rsnorm", ctypes.c_double),
- ("pobj", ctypes.c_double),
- ("solvetime", ctypes.c_double),
- ("fevalstime", ctypes.c_double),
- ("QPtime", ctypes.c_double)]
-
-# Dynamics dimensions
-#   nvar    |   neq   |   dimh    |   dimp    |   diml    |   dimu    |   dimhl   |   dimhu    
-dynamics_dims = [
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0), 
-	(17, 13, 1, 9, 4, 4, 1, 0)
-]
\ No newline at end of file
Index: FORCENLPsolver/FORCENLPsolver_model.c
===================================================================
diff --git a/FORCENLPsolver/FORCENLPsolver_model.c b/FORCENLPsolver/FORCENLPsolver_model.c
deleted file mode 100644
--- a/FORCENLPsolver/FORCENLPsolver_model.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,6427 +0,0 @@
-/* This file was automatically generated by CasADi.
-   The CasADi copyright holders make no ownership claim of its contents. */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* How to prefix internal symbols */
-#ifdef CASADI_CODEGEN_PREFIX
-  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
-  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
-  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
-#else
-  #define CASADI_PREFIX(ID) FORCENLPsolver_model_ ## ID
-#endif
-
-#include <math.h> 
-#include "FORCENLPsolver_model.h"
-
-#ifndef casadi_real
-#define casadi_real FORCENLPsolver_float
-#endif
-
-#ifndef casadi_int
-#define casadi_int solver_int32_default
-#endif
-
-/* Add prefix to internal symbols */
-#define casadi_f0 CASADI_PREFIX(f0)
-#define casadi_f1 CASADI_PREFIX(f1)
-#define casadi_f2 CASADI_PREFIX(f2)
-#define casadi_f3 CASADI_PREFIX(f3)
-#define casadi_f4 CASADI_PREFIX(f4)
-#define casadi_f5 CASADI_PREFIX(f5)
-#define casadi_f6 CASADI_PREFIX(f6)
-#define casadi_f7 CASADI_PREFIX(f7)
-#define casadi_f8 CASADI_PREFIX(f8)
-#define casadi_f9 CASADI_PREFIX(f9)
-#define casadi_s0 CASADI_PREFIX(s0)
-#define casadi_s1 CASADI_PREFIX(s1)
-#define casadi_s2 CASADI_PREFIX(s2)
-#define casadi_s3 CASADI_PREFIX(s3)
-#define casadi_s4 CASADI_PREFIX(s4)
-#define casadi_s5 CASADI_PREFIX(s5)
-#define casadi_s6 CASADI_PREFIX(s6)
-#define casadi_sq CASADI_PREFIX(sq)
-
-/* Symbol visibility in DLLs */
-#if 0
-  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-    #if defined(STATIC_LINKED)
-      #define CASADI_SYMBOL_EXPORT
-    #else
-      #define __declspec(dllexport)
-    #endif
-  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-    #define __attribute__ ((visibility ("default")))
-  #else
-    #define CASADI_SYMBOL_EXPORT
-  #endif
-#endif
-
-casadi_real casadi_sq(casadi_real x) { return x*x;}
-
-static const casadi_int casadi_s0[21] = {17, 1, 0, 17, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
-static const casadi_int casadi_s1[13] = {9, 1, 0, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8};
-static const casadi_int casadi_s2[5] = {1, 1, 0, 1, 0};
-static const casadi_int casadi_s3[37] = {1, 17, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-static const casadi_int casadi_s4[17] = {13, 1, 0, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
-static const casadi_int casadi_s5[153] = {13, 17, 0, 6, 19, 32, 45, 46, 47, 48, 50, 52, 54, 64, 74, 84, 94, 107, 120, 133, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
-static const casadi_int casadi_s6[23] = {1, 17, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0};
-
-/* FORCENLPsolver_objective_0:(i0[17],i1[9])->(o0) */
-static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a3=(a3*a1);
-  a1=arg[0]? arg[0][5] : 0;
-  a2=arg[1]? arg[1][1] : 0;
-  a4=(a1-a2);
-  a4=(a0*a4);
-  a1=(a1-a2);
-  a4=(a4*a1);
-  a3=(a3+a4);
-  a4=arg[0]? arg[0][6] : 0;
-  a1=arg[1]? arg[1][2] : 0;
-  a2=(a4-a1);
-  a0=(a0*a2);
-  a4=(a4-a1);
-  a0=(a0*a4);
-  a3=(a3+a0);
-  a0=20.;
-  a4=arg[0]? arg[0][7] : 0;
-  a1=arg[1]? arg[1][3] : 0;
-  a2=(a4-a1);
-  a2=(a0*a2);
-  a4=(a4-a1);
-  a2=(a2*a4);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][8] : 0;
-  a4=arg[1]? arg[1][4] : 0;
-  a1=(a2-a4);
-  a1=(a0*a1);
-  a2=(a2-a4);
-  a1=(a1*a2);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][9] : 0;
-  a2=arg[1]? arg[1][5] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=10.;
-  a1=arg[0]? arg[0][10] : 0;
-  a2=(a0*a1);
-  a2=(a2*a1);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][11] : 0;
-  a1=(a0*a2);
-  a1=(a1*a2);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][12] : 0;
-  a2=(a0*a1);
-  a2=(a2*a1);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][13] : 0;
-  a1=1.;
-  a4=(a2-a1);
-  a4=(a0*a4);
-  a2=(a2-a1);
-  a4=(a4*a2);
-  a3=(a3+a4);
-  a4=arg[0]? arg[0][14] : 0;
-  a2=(a0*a4);
-  a2=(a2*a4);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][15] : 0;
-  a4=(a0*a2);
-  a4=(a4*a2);
-  a3=(a3+a4);
-  a4=arg[0]? arg[0][16] : 0;
-  a0=(a0*a4);
-  a0=(a0*a4);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-01;
-  a4=arg[0]? arg[0][0] : 0;
-  a4=casadi_sq(a4);
-  a2=arg[0]? arg[0][1] : 0;
-  a2=casadi_sq(a2);
-  a4=(a4+a2);
-  a2=arg[0]? arg[0][2] : 0;
-  a2=casadi_sq(a2);
-  a4=(a4+a2);
-  a2=arg[0]? arg[0][3] : 0;
-  a2=casadi_sq(a2);
-  a4=(a4+a2);
-  a0=(a0*a4);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][0]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f0(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_objective_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_objective_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_objective_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_0_release(int mem) {
-}
-
-void FORCENLPsolver_objective_0_incref(void) {
-}
-
-void FORCENLPsolver_objective_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_objective_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_objective_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_objective_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dobjective_0:(i0[17],i1[9])->(o0[1x17]) */
-static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-01;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][0]=a1;
-  a1=arg[0]? arg[0][1] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][1]=a1;
-  a1=arg[0]? arg[0][2] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][2]=a1;
-  a1=arg[0]? arg[0][3] : 0;
-  a1=(a1+a1);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][3]=a0;
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][4]=a3;
-  a3=arg[0]? arg[0][5] : 0;
-  a1=arg[1]? arg[1][1] : 0;
-  a2=(a3-a1);
-  a2=(a0*a2);
-  a3=(a3-a1);
-  a3=(a0*a3);
-  a2=(a2+a3);
-  if (res[0]!=0) res[0][5]=a2;
-  a2=arg[0]? arg[0][6] : 0;
-  a3=arg[1]? arg[1][2] : 0;
-  a1=(a2-a3);
-  a1=(a0*a1);
-  a2=(a2-a3);
-  a0=(a0*a2);
-  a1=(a1+a0);
-  if (res[0]!=0) res[0][6]=a1;
-  a1=20.;
-  a0=arg[0]? arg[0][7] : 0;
-  a2=arg[1]? arg[1][3] : 0;
-  a3=(a0-a2);
-  a3=(a1*a3);
-  a0=(a0-a2);
-  a0=(a1*a0);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][7]=a3;
-  a3=arg[0]? arg[0][8] : 0;
-  a0=arg[1]? arg[1][4] : 0;
-  a2=(a3-a0);
-  a2=(a1*a2);
-  a3=(a3-a0);
-  a3=(a1*a3);
-  a2=(a2+a3);
-  if (res[0]!=0) res[0][8]=a2;
-  a2=arg[0]? arg[0][9] : 0;
-  a3=arg[1]? arg[1][5] : 0;
-  a0=(a2-a3);
-  a0=(a1*a0);
-  a2=(a2-a3);
-  a1=(a1*a2);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][9]=a0;
-  a0=10.;
-  a1=arg[0]? arg[0][10] : 0;
-  a2=(a0*a1);
-  a1=(a0*a1);
-  a2=(a2+a1);
-  if (res[0]!=0) res[0][10]=a2;
-  a2=arg[0]? arg[0][11] : 0;
-  a1=(a0*a2);
-  a2=(a0*a2);
-  a1=(a1+a2);
-  if (res[0]!=0) res[0][11]=a1;
-  a1=arg[0]? arg[0][12] : 0;
-  a2=(a0*a1);
-  a1=(a0*a1);
-  a2=(a2+a1);
-  if (res[0]!=0) res[0][12]=a2;
-  a2=arg[0]? arg[0][13] : 0;
-  a1=1.;
-  a3=(a2-a1);
-  a3=(a0*a3);
-  a2=(a2-a1);
-  a2=(a0*a2);
-  a3=(a3+a2);
-  if (res[0]!=0) res[0][13]=a3;
-  a3=arg[0]? arg[0][14] : 0;
-  a2=(a0*a3);
-  a3=(a0*a3);
-  a2=(a2+a3);
-  if (res[0]!=0) res[0][14]=a2;
-  a2=arg[0]? arg[0][15] : 0;
-  a3=(a0*a2);
-  a2=(a0*a2);
-  a3=(a3+a2);
-  if (res[0]!=0) res[0][15]=a3;
-  a3=arg[0]? arg[0][16] : 0;
-  a2=(a0*a3);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][16]=a2;
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f1(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dobjective_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dobjective_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_0_release(int mem) {
-}
-
-void FORCENLPsolver_dobjective_0_incref(void) {
-}
-
-void FORCENLPsolver_dobjective_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dobjective_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dobjective_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dobjective_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s3;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dynamics_0:(i0[17],i1[9])->(o0[13]) */
-static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a2, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a3, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a4, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a5, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a6, a60, a7, a8, a9;
-  a0=arg[0]? arg[0][4] : 0;
-  a1=1.6666666666666668e-03;
-  a2=arg[0]? arg[0][7] : 0;
-  a3=2.;
-  a4=5.0000000000000001e-03;
-  a5=arg[0]? arg[0][0] : 0;
-  a6=arg[0]? arg[0][10] : 0;
-  a7=arg[0]? arg[0][12] : 0;
-  a8=(a6*a7);
-  a9=arg[0]? arg[0][11] : 0;
-  a10=arg[0]? arg[0][13] : 0;
-  a11=(a9*a10);
-  a8=(a8+a11);
-  a8=(a3*a8);
-  a8=(a5*a8);
-  a11=2.9999999999999999e-02;
-  a8=(a8/a11);
-  a12=(a4*a8);
-  a12=(a2+a12);
-  a12=(a3*a12);
-  a12=(a2+a12);
-  a13=5.0000000000000000e-01;
-  a14=(a13*a10);
-  a15=arg[0]? arg[0][14] : 0;
-  a14=(a14*a15);
-  a16=(a13*a7);
-  a17=arg[0]? arg[0][15] : 0;
-  a16=(a16*a17);
-  a14=(a14-a16);
-  a16=(a13*a9);
-  a18=arg[0]? arg[0][16] : 0;
-  a16=(a16*a18);
-  a14=(a14+a16);
-  a16=casadi_sq(a6);
-  a19=casadi_sq(a9);
-  a16=(a16+a19);
-  a19=casadi_sq(a7);
-  a16=(a16+a19);
-  a19=casadi_sq(a10);
-  a16=(a16+a19);
-  a19=1.;
-  a16=(a16-a19);
-  a20=(a3*a6);
-  a20=(a16*a20);
-  a14=(a14-a20);
-  a20=(a4*a14);
-  a20=(a6+a20);
-  a21=(a13*a6);
-  a21=(a21*a17);
-  a22=(a13*a9);
-  a22=(a22*a15);
-  a21=(a21-a22);
-  a22=(a13*a10);
-  a22=(a22*a18);
-  a21=(a21+a22);
-  a22=(a3*a7);
-  a22=(a16*a22);
-  a21=(a21-a22);
-  a22=(a4*a21);
-  a22=(a7+a22);
-  a23=(a20*a22);
-  a24=(a13*a7);
-  a24=(a24*a15);
-  a25=(a13*a10);
-  a25=(a25*a17);
-  a24=(a24+a25);
-  a25=(a13*a6);
-  a25=(a25*a18);
-  a24=(a24-a25);
-  a25=(a3*a9);
-  a25=(a16*a25);
-  a24=(a24-a25);
-  a25=(a4*a24);
-  a25=(a9+a25);
-  a26=(a13*a6);
-  a26=(a26*a15);
-  a27=(a13*a9);
-  a27=(a27*a17);
-  a26=(a26+a27);
-  a27=(a13*a7);
-  a27=(a27*a18);
-  a26=(a26+a27);
-  a27=(a3*a10);
-  a16=(a16*a27);
-  a26=(a26+a16);
-  a16=(a4*a26);
-  a16=(a10-a16);
-  a27=(a25*a16);
-  a23=(a23+a27);
-  a23=(a3*a23);
-  a23=(a5*a23);
-  a23=(a23/a11);
-  a27=(a4*a23);
-  a27=(a2+a27);
-  a27=(a3*a27);
-  a12=(a12+a27);
-  a27=1.0000000000000000e-02;
-  a28=(a13*a16);
-  a29=6.9930069930069934e+04;
-  a30=arg[0]? arg[0][1] : 0;
-  a31=2.8900000000000001e-05;
-  a32=(a31*a18);
-  a33=(a17*a32);
-  a34=1.4300000000000000e-05;
-  a35=(a34*a17);
-  a36=(a18*a35);
-  a33=(a33-a36);
-  a33=(a30-a33);
-  a33=(a29*a33);
-  a36=(a4*a33);
-  a36=(a15+a36);
-  a28=(a28*a36);
-  a37=(a13*a22);
-  a38=arg[0]? arg[0][2] : 0;
-  a39=(a34*a15);
-  a40=(a18*a39);
-  a32=(a15*a32);
-  a40=(a40-a32);
-  a40=(a38-a40);
-  a40=(a29*a40);
-  a32=(a4*a40);
-  a32=(a17+a32);
-  a37=(a37*a32);
-  a28=(a28-a37);
-  a37=(a13*a25);
-  a41=3.4602076124567473e+04;
-  a42=arg[0]? arg[0][3] : 0;
-  a35=(a15*a35);
-  a39=(a17*a39);
-  a35=(a35-a39);
-  a35=(a42-a35);
-  a35=(a41*a35);
-  a39=(a4*a35);
-  a39=(a18+a39);
-  a37=(a37*a39);
-  a28=(a28+a37);
-  a37=casadi_sq(a20);
-  a43=casadi_sq(a25);
-  a37=(a37+a43);
-  a43=casadi_sq(a22);
-  a37=(a37+a43);
-  a43=casadi_sq(a16);
-  a37=(a37+a43);
-  a37=(a37-a19);
-  a43=(a3*a20);
-  a43=(a37*a43);
-  a28=(a28-a43);
-  a43=(a4*a28);
-  a43=(a6+a43);
-  a44=(a13*a20);
-  a44=(a44*a32);
-  a45=(a13*a25);
-  a45=(a45*a36);
-  a44=(a44-a45);
-  a45=(a13*a16);
-  a45=(a45*a39);
-  a44=(a44+a45);
-  a45=(a3*a22);
-  a45=(a37*a45);
-  a44=(a44-a45);
-  a45=(a4*a44);
-  a45=(a7+a45);
-  a46=(a43*a45);
-  a47=(a13*a22);
-  a47=(a47*a36);
-  a48=(a13*a16);
-  a48=(a48*a32);
-  a47=(a47+a48);
-  a48=(a13*a20);
-  a48=(a48*a39);
-  a47=(a47-a48);
-  a48=(a3*a25);
-  a48=(a37*a48);
-  a47=(a47-a48);
-  a48=(a4*a47);
-  a48=(a9+a48);
-  a49=(a13*a20);
-  a49=(a49*a36);
-  a50=(a13*a25);
-  a50=(a50*a32);
-  a49=(a49+a50);
-  a50=(a13*a22);
-  a50=(a50*a39);
-  a49=(a49+a50);
-  a50=(a3*a16);
-  a37=(a37*a50);
-  a49=(a49+a37);
-  a37=(a4*a49);
-  a37=(a10-a37);
-  a50=(a48*a37);
-  a46=(a46+a50);
-  a46=(a3*a46);
-  a46=(a5*a46);
-  a46=(a46/a11);
-  a50=(a27*a46);
-  a50=(a2+a50);
-  a12=(a12+a50);
-  a12=(a1*a12);
-  a0=(a0+a12);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][5] : 0;
-  a12=arg[0]? arg[0][8] : 0;
-  a50=(a9*a7);
-  a51=(a6*a10);
-  a50=(a50-a51);
-  a50=(a3*a50);
-  a50=(a5*a50);
-  a50=(a50/a11);
-  a51=(a4*a50);
-  a51=(a12+a51);
-  a51=(a3*a51);
-  a51=(a12+a51);
-  a22=(a25*a22);
-  a16=(a20*a16);
-  a22=(a22-a16);
-  a22=(a3*a22);
-  a22=(a5*a22);
-  a22=(a22/a11);
-  a16=(a4*a22);
-  a16=(a12+a16);
-  a16=(a3*a16);
-  a51=(a51+a16);
-  a16=(a48*a45);
-  a52=(a43*a37);
-  a16=(a16-a52);
-  a16=(a3*a16);
-  a16=(a5*a16);
-  a16=(a16/a11);
-  a52=(a27*a16);
-  a52=(a12+a52);
-  a51=(a51+a52);
-  a51=(a1*a51);
-  a0=(a0+a51);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=arg[0]? arg[0][6] : 0;
-  a51=arg[0]? arg[0][9] : 0;
-  a52=-2.9430000000000001e-01;
-  a53=casadi_sq(a6);
-  a54=casadi_sq(a9);
-  a53=(a53+a54);
-  a53=(a3*a53);
-  a53=(a19-a53);
-  a53=(a5*a53);
-  a53=(a52+a53);
-  a53=(a53/a11);
-  a54=(a4*a53);
-  a54=(a51+a54);
-  a54=(a3*a54);
-  a54=(a51+a54);
-  a20=casadi_sq(a20);
-  a25=casadi_sq(a25);
-  a20=(a20+a25);
-  a20=(a3*a20);
-  a20=(a19-a20);
-  a20=(a5*a20);
-  a20=(a52+a20);
-  a20=(a20/a11);
-  a25=(a4*a20);
-  a25=(a51+a25);
-  a25=(a3*a25);
-  a54=(a54+a25);
-  a25=casadi_sq(a43);
-  a55=casadi_sq(a48);
-  a25=(a25+a55);
-  a25=(a3*a25);
-  a25=(a19-a25);
-  a25=(a5*a25);
-  a25=(a52+a25);
-  a25=(a25/a11);
-  a55=(a27*a25);
-  a55=(a51+a55);
-  a54=(a54+a55);
-  a54=(a1*a54);
-  a0=(a0+a54);
-  if (res[0]!=0) res[0][2]=a0;
-  a23=(a3*a23);
-  a8=(a8+a23);
-  a46=(a3*a46);
-  a8=(a8+a46);
-  a46=(a13*a37);
-  a23=(a31*a39);
-  a0=(a32*a23);
-  a54=(a34*a32);
-  a55=(a39*a54);
-  a0=(a0-a55);
-  a0=(a30-a0);
-  a0=(a29*a0);
-  a55=(a4*a0);
-  a55=(a15+a55);
-  a46=(a46*a55);
-  a56=(a13*a45);
-  a57=(a34*a36);
-  a39=(a39*a57);
-  a23=(a36*a23);
-  a39=(a39-a23);
-  a39=(a38-a39);
-  a39=(a29*a39);
-  a23=(a4*a39);
-  a23=(a17+a23);
-  a56=(a56*a23);
-  a46=(a46-a56);
-  a56=(a13*a48);
-  a36=(a36*a54);
-  a32=(a32*a57);
-  a36=(a36-a32);
-  a36=(a42-a36);
-  a36=(a41*a36);
-  a4=(a4*a36);
-  a4=(a18+a4);
-  a56=(a56*a4);
-  a46=(a46+a56);
-  a56=casadi_sq(a43);
-  a32=casadi_sq(a48);
-  a56=(a56+a32);
-  a32=casadi_sq(a45);
-  a56=(a56+a32);
-  a32=casadi_sq(a37);
-  a56=(a56+a32);
-  a56=(a56-a19);
-  a32=(a3*a43);
-  a32=(a56*a32);
-  a46=(a46-a32);
-  a32=(a27*a46);
-  a32=(a6+a32);
-  a57=(a13*a43);
-  a57=(a57*a23);
-  a54=(a13*a48);
-  a54=(a54*a55);
-  a57=(a57-a54);
-  a54=(a13*a37);
-  a54=(a54*a4);
-  a57=(a57+a54);
-  a54=(a3*a45);
-  a54=(a56*a54);
-  a57=(a57-a54);
-  a54=(a27*a57);
-  a54=(a7+a54);
-  a58=(a32*a54);
-  a59=(a13*a45);
-  a59=(a59*a55);
-  a60=(a13*a37);
-  a60=(a60*a23);
-  a59=(a59+a60);
-  a60=(a13*a43);
-  a60=(a60*a4);
-  a59=(a59-a60);
-  a60=(a3*a48);
-  a60=(a56*a60);
-  a59=(a59-a60);
-  a60=(a27*a59);
-  a60=(a9+a60);
-  a43=(a13*a43);
-  a43=(a43*a55);
-  a48=(a13*a48);
-  a48=(a48*a23);
-  a43=(a43+a48);
-  a45=(a13*a45);
-  a45=(a45*a4);
-  a43=(a43+a45);
-  a37=(a3*a37);
-  a56=(a56*a37);
-  a43=(a43+a56);
-  a56=(a27*a43);
-  a56=(a10-a56);
-  a37=(a60*a56);
-  a58=(a58+a37);
-  a58=(a3*a58);
-  a58=(a5*a58);
-  a58=(a58/a11);
-  a8=(a8+a58);
-  a8=(a1*a8);
-  a2=(a2+a8);
-  if (res[0]!=0) res[0][3]=a2;
-  a22=(a3*a22);
-  a50=(a50+a22);
-  a16=(a3*a16);
-  a50=(a50+a16);
-  a16=(a60*a54);
-  a22=(a32*a56);
-  a16=(a16-a22);
-  a16=(a3*a16);
-  a16=(a5*a16);
-  a16=(a16/a11);
-  a50=(a50+a16);
-  a50=(a1*a50);
-  a12=(a12+a50);
-  if (res[0]!=0) res[0][4]=a12;
-  a20=(a3*a20);
-  a53=(a53+a20);
-  a25=(a3*a25);
-  a53=(a53+a25);
-  a25=casadi_sq(a32);
-  a20=casadi_sq(a60);
-  a25=(a25+a20);
-  a25=(a3*a25);
-  a25=(a19-a25);
-  a5=(a5*a25);
-  a52=(a52+a5);
-  a52=(a52/a11);
-  a53=(a53+a52);
-  a53=(a1*a53);
-  a51=(a51+a53);
-  if (res[0]!=0) res[0][5]=a51;
-  a28=(a3*a28);
-  a14=(a14+a28);
-  a46=(a3*a46);
-  a14=(a14+a46);
-  a46=(a13*a56);
-  a28=(a31*a4);
-  a51=(a23*a28);
-  a53=(a34*a23);
-  a52=(a4*a53);
-  a51=(a51-a52);
-  a51=(a30-a51);
-  a51=(a29*a51);
-  a52=(a27*a51);
-  a52=(a15+a52);
-  a46=(a46*a52);
-  a11=(a13*a54);
-  a5=(a34*a55);
-  a4=(a4*a5);
-  a28=(a55*a28);
-  a4=(a4-a28);
-  a4=(a38-a4);
-  a4=(a29*a4);
-  a28=(a27*a4);
-  a28=(a17+a28);
-  a11=(a11*a28);
-  a46=(a46-a11);
-  a11=(a13*a60);
-  a55=(a55*a53);
-  a23=(a23*a5);
-  a55=(a55-a23);
-  a55=(a42-a55);
-  a55=(a41*a55);
-  a27=(a27*a55);
-  a27=(a18+a27);
-  a11=(a11*a27);
-  a46=(a46+a11);
-  a11=casadi_sq(a32);
-  a23=casadi_sq(a60);
-  a11=(a11+a23);
-  a23=casadi_sq(a54);
-  a11=(a11+a23);
-  a23=casadi_sq(a56);
-  a11=(a11+a23);
-  a11=(a11-a19);
-  a19=(a3*a32);
-  a19=(a11*a19);
-  a46=(a46-a19);
-  a14=(a14+a46);
-  a14=(a1*a14);
-  a6=(a6+a14);
-  if (res[0]!=0) res[0][6]=a6;
-  a47=(a3*a47);
-  a24=(a24+a47);
-  a59=(a3*a59);
-  a24=(a24+a59);
-  a59=(a13*a54);
-  a59=(a59*a52);
-  a47=(a13*a56);
-  a47=(a47*a28);
-  a59=(a59+a47);
-  a47=(a13*a32);
-  a47=(a47*a27);
-  a59=(a59-a47);
-  a47=(a3*a60);
-  a47=(a11*a47);
-  a59=(a59-a47);
-  a24=(a24+a59);
-  a24=(a1*a24);
-  a9=(a9+a24);
-  if (res[0]!=0) res[0][7]=a9;
-  a44=(a3*a44);
-  a21=(a21+a44);
-  a57=(a3*a57);
-  a21=(a21+a57);
-  a57=(a13*a32);
-  a57=(a57*a28);
-  a44=(a13*a60);
-  a44=(a44*a52);
-  a57=(a57-a44);
-  a44=(a13*a56);
-  a44=(a44*a27);
-  a57=(a57+a44);
-  a44=(a3*a54);
-  a44=(a11*a44);
-  a57=(a57-a44);
-  a21=(a21+a57);
-  a21=(a1*a21);
-  a7=(a7+a21);
-  if (res[0]!=0) res[0][8]=a7;
-  a49=(a3*a49);
-  a26=(a26+a49);
-  a43=(a3*a43);
-  a26=(a26+a43);
-  a32=(a13*a32);
-  a32=(a32*a52);
-  a60=(a13*a60);
-  a60=(a60*a28);
-  a32=(a32+a60);
-  a13=(a13*a54);
-  a13=(a13*a27);
-  a32=(a32+a13);
-  a56=(a3*a56);
-  a11=(a11*a56);
-  a32=(a32+a11);
-  a26=(a26+a32);
-  a26=(a1*a26);
-  a10=(a10-a26);
-  if (res[0]!=0) res[0][9]=a10;
-  a0=(a3*a0);
-  a33=(a33+a0);
-  a51=(a3*a51);
-  a33=(a33+a51);
-  a31=(a31*a27);
-  a51=(a28*a31);
-  a0=(a34*a28);
-  a10=(a27*a0);
-  a51=(a51-a10);
-  a30=(a30-a51);
-  a30=(a29*a30);
-  a33=(a33+a30);
-  a33=(a1*a33);
-  a15=(a15+a33);
-  if (res[0]!=0) res[0][10]=a15;
-  a39=(a3*a39);
-  a40=(a40+a39);
-  a4=(a3*a4);
-  a40=(a40+a4);
-  a34=(a34*a52);
-  a27=(a27*a34);
-  a31=(a52*a31);
-  a27=(a27-a31);
-  a38=(a38-a27);
-  a29=(a29*a38);
-  a40=(a40+a29);
-  a40=(a1*a40);
-  a17=(a17+a40);
-  if (res[0]!=0) res[0][11]=a17;
-  a36=(a3*a36);
-  a35=(a35+a36);
-  a3=(a3*a55);
-  a35=(a35+a3);
-  a52=(a52*a0);
-  a28=(a28*a34);
-  a52=(a52-a28);
-  a42=(a42-a52);
-  a41=(a41*a42);
-  a35=(a35+a41);
-  a1=(a1*a35);
-  a18=(a18+a1);
-  if (res[0]!=0) res[0][12]=a18;
-  return 0;
-}
-
-int FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f2(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dynamics_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dynamics_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dynamics_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dynamics_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dynamics_0_release(int mem) {
-}
-
-void FORCENLPsolver_dynamics_0_incref(void) {
-}
-
-void FORCENLPsolver_dynamics_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dynamics_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dynamics_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dynamics_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dynamics_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dynamics_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s4;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_ddynamics_0:(i0[17],i1[9])->(o0[13x17,133nz]) */
-static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a100, a101, a102, a103, a104, a105, a106, a107, a108, a109, a11, a110, a111, a112, a113, a114, a115, a116, a117, a118, a119, a12, a120, a121, a122, a123, a124, a125, a126, a127, a128, a129, a13, a130, a131, a132, a133, a134, a135, a136, a137, a138, a139, a14, a140, a141, a142, a143, a144, a145, a146, a147, a148, a149, a15, a150, a151, a152, a153, a154, a155, a156, a157, a158, a159, a16, a160, a161, a162, a163, a164, a165, a17, a18, a19, a2, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a3, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a4, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a5, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a6, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a7, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a8, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a9, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99;
-  a0=1.6666666666666668e-03;
-  a1=2.;
-  a2=5.0000000000000001e-03;
-  a3=3.3333333333333336e+01;
-  a4=arg[0]? arg[0][10] : 0;
-  a5=arg[0]? arg[0][12] : 0;
-  a6=(a4*a5);
-  a7=arg[0]? arg[0][11] : 0;
-  a8=arg[0]? arg[0][13] : 0;
-  a9=(a7*a8);
-  a6=(a6+a9);
-  a6=(a1*a6);
-  a6=(a3*a6);
-  a9=(a2*a6);
-  a9=(a1*a9);
-  a10=5.0000000000000000e-01;
-  a11=(a10*a8);
-  a12=arg[0]? arg[0][14] : 0;
-  a13=(a11*a12);
-  a14=(a10*a5);
-  a15=arg[0]? arg[0][15] : 0;
-  a16=(a14*a15);
-  a13=(a13-a16);
-  a16=(a10*a7);
-  a17=arg[0]? arg[0][16] : 0;
-  a18=(a16*a17);
-  a13=(a13+a18);
-  a18=casadi_sq(a4);
-  a19=casadi_sq(a7);
-  a18=(a18+a19);
-  a19=casadi_sq(a5);
-  a18=(a18+a19);
-  a19=casadi_sq(a8);
-  a18=(a18+a19);
-  a19=1.;
-  a18=(a18-a19);
-  a20=(a1*a4);
-  a21=(a18*a20);
-  a13=(a13-a21);
-  a13=(a2*a13);
-  a13=(a4+a13);
-  a21=(a10*a4);
-  a22=(a21*a15);
-  a23=(a10*a7);
-  a24=(a23*a12);
-  a22=(a22-a24);
-  a24=(a10*a8);
-  a25=(a24*a17);
-  a22=(a22+a25);
-  a25=(a1*a5);
-  a26=(a18*a25);
-  a22=(a22-a26);
-  a22=(a2*a22);
-  a22=(a5+a22);
-  a26=(a13*a22);
-  a27=(a10*a5);
-  a28=(a27*a12);
-  a29=(a10*a8);
-  a30=(a29*a15);
-  a28=(a28+a30);
-  a30=(a10*a4);
-  a31=(a30*a17);
-  a28=(a28-a31);
-  a31=(a1*a7);
-  a32=(a18*a31);
-  a28=(a28-a32);
-  a28=(a2*a28);
-  a28=(a7+a28);
-  a32=(a10*a4);
-  a33=(a32*a12);
-  a34=(a10*a7);
-  a35=(a34*a15);
-  a33=(a33+a35);
-  a35=(a10*a5);
-  a36=(a35*a17);
-  a33=(a33+a36);
-  a36=(a1*a8);
-  a37=(a18*a36);
-  a33=(a33+a37);
-  a33=(a2*a33);
-  a33=(a8-a33);
-  a37=(a28*a33);
-  a26=(a26+a37);
-  a26=(a1*a26);
-  a26=(a3*a26);
-  a37=(a2*a26);
-  a37=(a1*a37);
-  a9=(a9+a37);
-  a37=1.0000000000000000e-02;
-  a38=(a10*a33);
-  a39=6.9930069930069934e+04;
-  a40=arg[0]? arg[0][1] : 0;
-  a41=2.8900000000000001e-05;
-  a42=(a41*a17);
-  a43=(a15*a42);
-  a44=1.4300000000000000e-05;
-  a45=(a44*a15);
-  a46=(a17*a45);
-  a43=(a43-a46);
-  a43=(a40-a43);
-  a43=(a39*a43);
-  a43=(a2*a43);
-  a43=(a12+a43);
-  a46=(a38*a43);
-  a47=(a10*a22);
-  a48=arg[0]? arg[0][2] : 0;
-  a49=(a44*a12);
-  a50=(a17*a49);
-  a51=(a12*a42);
-  a50=(a50-a51);
-  a50=(a48-a50);
-  a50=(a39*a50);
-  a50=(a2*a50);
-  a50=(a15+a50);
-  a51=(a47*a50);
-  a46=(a46-a51);
-  a51=(a10*a28);
-  a52=3.4602076124567473e+04;
-  a53=arg[0]? arg[0][3] : 0;
-  a54=(a12*a45);
-  a55=(a15*a49);
-  a54=(a54-a55);
-  a54=(a53-a54);
-  a54=(a52*a54);
-  a54=(a2*a54);
-  a54=(a17+a54);
-  a55=(a51*a54);
-  a46=(a46+a55);
-  a55=casadi_sq(a13);
-  a56=casadi_sq(a28);
-  a55=(a55+a56);
-  a56=casadi_sq(a22);
-  a55=(a55+a56);
-  a56=casadi_sq(a33);
-  a55=(a55+a56);
-  a55=(a55-a19);
-  a56=(a1*a13);
-  a57=(a55*a56);
-  a46=(a46-a57);
-  a46=(a2*a46);
-  a46=(a4+a46);
-  a57=(a10*a13);
-  a58=(a57*a50);
-  a59=(a10*a28);
-  a60=(a59*a43);
-  a58=(a58-a60);
-  a60=(a10*a33);
-  a61=(a60*a54);
-  a58=(a58+a61);
-  a61=(a1*a22);
-  a62=(a55*a61);
-  a58=(a58-a62);
-  a58=(a2*a58);
-  a58=(a5+a58);
-  a62=(a46*a58);
-  a63=(a10*a22);
-  a64=(a63*a43);
-  a65=(a10*a33);
-  a66=(a65*a50);
-  a64=(a64+a66);
-  a66=(a10*a13);
-  a67=(a66*a54);
-  a64=(a64-a67);
-  a67=(a1*a28);
-  a68=(a55*a67);
-  a64=(a64-a68);
-  a64=(a2*a64);
-  a64=(a7+a64);
-  a68=(a10*a13);
-  a69=(a68*a43);
-  a70=(a10*a28);
-  a71=(a70*a50);
-  a69=(a69+a71);
-  a71=(a10*a22);
-  a72=(a71*a54);
-  a69=(a69+a72);
-  a72=(a1*a33);
-  a73=(a55*a72);
-  a69=(a69+a73);
-  a69=(a2*a69);
-  a69=(a8-a69);
-  a73=(a64*a69);
-  a62=(a62+a73);
-  a62=(a1*a62);
-  a62=(a3*a62);
-  a73=(a37*a62);
-  a9=(a9+a73);
-  a9=(a0*a9);
-  if (res[0]!=0) res[0][0]=a9;
-  a9=(a7*a5);
-  a73=(a4*a8);
-  a9=(a9-a73);
-  a9=(a1*a9);
-  a9=(a3*a9);
-  a73=(a2*a9);
-  a73=(a1*a73);
-  a74=(a28*a22);
-  a75=(a13*a33);
-  a74=(a74-a75);
-  a74=(a1*a74);
-  a74=(a3*a74);
-  a75=(a2*a74);
-  a75=(a1*a75);
-  a73=(a73+a75);
-  a75=(a64*a58);
-  a76=(a46*a69);
-  a75=(a75-a76);
-  a75=(a1*a75);
-  a75=(a3*a75);
-  a76=(a37*a75);
-  a73=(a73+a76);
-  a73=(a0*a73);
-  if (res[0]!=0) res[0][1]=a73;
-  a73=casadi_sq(a4);
-  a76=casadi_sq(a7);
-  a73=(a73+a76);
-  a73=(a1*a73);
-  a73=(a19-a73);
-  a73=(a3*a73);
-  a76=(a2*a73);
-  a76=(a1*a76);
-  a77=casadi_sq(a13);
-  a78=casadi_sq(a28);
-  a77=(a77+a78);
-  a77=(a1*a77);
-  a77=(a19-a77);
-  a77=(a3*a77);
-  a78=(a2*a77);
-  a78=(a1*a78);
-  a76=(a76+a78);
-  a78=casadi_sq(a46);
-  a79=casadi_sq(a64);
-  a78=(a78+a79);
-  a78=(a1*a78);
-  a78=(a19-a78);
-  a78=(a3*a78);
-  a79=(a37*a78);
-  a76=(a76+a79);
-  a76=(a0*a76);
-  if (res[0]!=0) res[0][2]=a76;
-  a26=(a1*a26);
-  a6=(a6+a26);
-  a62=(a1*a62);
-  a6=(a6+a62);
-  a62=(a10*a69);
-  a26=(a41*a54);
-  a76=(a50*a26);
-  a79=(a44*a50);
-  a80=(a54*a79);
-  a76=(a76-a80);
-  a76=(a40-a76);
-  a76=(a39*a76);
-  a76=(a2*a76);
-  a76=(a12+a76);
-  a80=(a62*a76);
-  a81=(a10*a58);
-  a82=(a44*a43);
-  a83=(a54*a82);
-  a84=(a43*a26);
-  a83=(a83-a84);
-  a83=(a48-a83);
-  a83=(a39*a83);
-  a83=(a2*a83);
-  a83=(a15+a83);
-  a84=(a81*a83);
-  a80=(a80-a84);
-  a84=(a10*a64);
-  a85=(a43*a79);
-  a86=(a50*a82);
-  a85=(a85-a86);
-  a85=(a53-a85);
-  a85=(a52*a85);
-  a85=(a2*a85);
-  a85=(a17+a85);
-  a86=(a84*a85);
-  a80=(a80+a86);
-  a86=casadi_sq(a46);
-  a87=casadi_sq(a64);
-  a86=(a86+a87);
-  a87=casadi_sq(a58);
-  a86=(a86+a87);
-  a87=casadi_sq(a69);
-  a86=(a86+a87);
-  a86=(a86-a19);
-  a87=(a1*a46);
-  a88=(a86*a87);
-  a80=(a80-a88);
-  a80=(a37*a80);
-  a80=(a4+a80);
-  a88=(a10*a46);
-  a89=(a88*a83);
-  a90=(a10*a64);
-  a91=(a90*a76);
-  a89=(a89-a91);
-  a91=(a10*a69);
-  a92=(a91*a85);
-  a89=(a89+a92);
-  a92=(a1*a58);
-  a93=(a86*a92);
-  a89=(a89-a93);
-  a89=(a37*a89);
-  a89=(a5+a89);
-  a93=(a80*a89);
-  a94=(a10*a58);
-  a95=(a94*a76);
-  a96=(a10*a69);
-  a97=(a96*a83);
-  a95=(a95+a97);
-  a97=(a10*a46);
-  a98=(a97*a85);
-  a95=(a95-a98);
-  a98=(a1*a64);
-  a99=(a86*a98);
-  a95=(a95-a99);
-  a95=(a37*a95);
-  a95=(a7+a95);
-  a99=(a10*a46);
-  a100=(a99*a76);
-  a101=(a10*a64);
-  a102=(a101*a83);
-  a100=(a100+a102);
-  a102=(a10*a58);
-  a103=(a102*a85);
-  a100=(a100+a103);
-  a103=(a1*a69);
-  a104=(a86*a103);
-  a100=(a100+a104);
-  a100=(a37*a100);
-  a100=(a8-a100);
-  a104=(a95*a100);
-  a93=(a93+a104);
-  a93=(a1*a93);
-  a93=(a3*a93);
-  a6=(a6+a93);
-  a6=(a0*a6);
-  if (res[0]!=0) res[0][3]=a6;
-  a74=(a1*a74);
-  a9=(a9+a74);
-  a75=(a1*a75);
-  a9=(a9+a75);
-  a75=(a95*a89);
-  a74=(a80*a100);
-  a75=(a75-a74);
-  a75=(a1*a75);
-  a75=(a3*a75);
-  a9=(a9+a75);
-  a9=(a0*a9);
-  if (res[0]!=0) res[0][4]=a9;
-  a77=(a1*a77);
-  a73=(a73+a77);
-  a78=(a1*a78);
-  a73=(a73+a78);
-  a78=casadi_sq(a80);
-  a77=casadi_sq(a95);
-  a78=(a78+a77);
-  a78=(a1*a78);
-  a78=(a19-a78);
-  a78=(a3*a78);
-  a73=(a73+a78);
-  a73=(a0*a73);
-  if (res[0]!=0) res[0][5]=a73;
-  a73=arg[0]? arg[0][0] : 0;
-  a78=3.4965034965034965e+02;
-  a77=(a78*a38);
-  a9=(a2*a77);
-  a75=(a58*a9);
-  a74=(a78*a59);
-  a6=(a2*a74);
-  a93=(a46*a6);
-  a75=(a75-a93);
-  a93=(a78*a63);
-  a104=(a2*a93);
-  a105=(a69*a104);
-  a106=(a78*a68);
-  a107=(a2*a106);
-  a108=(a64*a107);
-  a105=(a105-a108);
-  a75=(a75+a105);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a105=(a37*a75);
-  a105=(a0*a105);
-  if (res[0]!=0) res[0][6]=a105;
-  a105=(a58*a104);
-  a108=(a64*a6);
-  a105=(a105-a108);
-  a108=(a69*a9);
-  a109=(a46*a107);
-  a108=(a108-a109);
-  a105=(a105-a108);
-  a105=(a1*a105);
-  a105=(a73*a105);
-  a105=(a3*a105);
-  a108=(a37*a105);
-  a108=(a0*a108);
-  if (res[0]!=0) res[0][7]=a108;
-  a108=(a46+a46);
-  a109=(a108*a9);
-  a110=(a64+a64);
-  a111=(a110*a104);
-  a109=(a109+a111);
-  a109=(a1*a109);
-  a109=(a73*a109);
-  a109=(a3*a109);
-  a111=(a37*a109);
-  a111=(a0*a111);
-  a111=(-a111);
-  if (res[0]!=0) res[0][8]=a111;
-  a75=(a1*a75);
-  a111=(a78*a62);
-  a112=(a10*a107);
-  a112=(a76*a112);
-  a111=(a111-a112);
-  a112=(a10*a6);
-  a112=(a83*a112);
-  a113=(a2*a54);
-  a114=(a78*a26);
-  a113=(a113-a114);
-  a113=(a39*a113);
-  a114=(a2*a113);
-  a115=(a81*a114);
-  a112=(a112+a115);
-  a111=(a111+a112);
-  a112=(a10*a104);
-  a112=(a85*a112);
-  a115=(a78*a79);
-  a116=(a2*a50);
-  a115=(a115-a116);
-  a115=(a52*a115);
-  a116=(a2*a115);
-  a117=(a84*a116);
-  a112=(a112-a117);
-  a111=(a111+a112);
-  a112=(a46+a46);
-  a117=(a112*a9);
-  a118=(a64+a64);
-  a119=(a118*a104);
-  a117=(a117+a119);
-  a119=(a58+a58);
-  a120=(a119*a6);
-  a117=(a117-a120);
-  a120=(a69+a69);
-  a121=(a120*a107);
-  a117=(a117-a121);
-  a121=(a87*a117);
-  a122=(a1*a9);
-  a122=(a86*a122);
-  a121=(a121+a122);
-  a111=(a111-a121);
-  a121=(a37*a111);
-  a122=(a89*a121);
-  a123=(a10*a9);
-  a123=(a83*a123);
-  a124=(a88*a114);
-  a123=(a123-a124);
-  a124=(a10*a104);
-  a124=(a76*a124);
-  a125=(a78*a90);
-  a124=(a124+a125);
-  a123=(a123-a124);
-  a124=(a10*a107);
-  a124=(a85*a124);
-  a125=(a91*a116);
-  a124=(a124+a125);
-  a123=(a123-a124);
-  a124=(a92*a117);
-  a125=(a1*a6);
-  a125=(a86*a125);
-  a124=(a124-a125);
-  a123=(a123-a124);
-  a124=(a37*a123);
-  a125=(a80*a124);
-  a122=(a122+a125);
-  a125=(a78*a94);
-  a126=(a10*a6);
-  a126=(a76*a126);
-  a125=(a125-a126);
-  a126=(a10*a107);
-  a126=(a83*a126);
-  a127=(a96*a114);
-  a126=(a126+a127);
-  a125=(a125-a126);
-  a126=(a10*a9);
-  a126=(a85*a126);
-  a127=(a97*a116);
-  a126=(a126-a127);
-  a125=(a125-a126);
-  a126=(a98*a117);
-  a127=(a1*a104);
-  a127=(a86*a127);
-  a126=(a126+a127);
-  a125=(a125-a126);
-  a126=(a37*a125);
-  a127=(a100*a126);
-  a9=(a10*a9);
-  a9=(a76*a9);
-  a128=(a78*a99);
-  a9=(a9+a128);
-  a104=(a10*a104);
-  a104=(a83*a104);
-  a128=(a101*a114);
-  a104=(a104-a128);
-  a9=(a9+a104);
-  a6=(a10*a6);
-  a6=(a85*a6);
-  a104=(a102*a116);
-  a6=(a6+a104);
-  a9=(a9-a6);
-  a117=(a103*a117);
-  a107=(a1*a107);
-  a107=(a86*a107);
-  a117=(a117-a107);
-  a9=(a9+a117);
-  a117=(a37*a9);
-  a107=(a95*a117);
-  a127=(a127-a107);
-  a122=(a122+a127);
-  a122=(a1*a122);
-  a122=(a73*a122);
-  a122=(a3*a122);
-  a75=(a75+a122);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][9]=a75;
-  a105=(a1*a105);
-  a75=(a89*a126);
-  a122=(a95*a124);
-  a75=(a75+a122);
-  a122=(a100*a121);
-  a127=(a80*a117);
-  a122=(a122-a127);
-  a75=(a75-a122);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a105=(a105+a75);
-  a105=(a0*a105);
-  if (res[0]!=0) res[0][10]=a105;
-  a109=(a1*a109);
-  a105=(a80+a80);
-  a75=(a105*a121);
-  a122=(a95+a95);
-  a127=(a122*a126);
-  a75=(a75+a127);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a109=(a109+a75);
-  a109=(a0*a109);
-  a109=(-a109);
-  if (res[0]!=0) res[0][11]=a109;
-  a77=(a1*a77);
-  a111=(a1*a111);
-  a77=(a77+a111);
-  a111=(a10*a100);
-  a109=(a44*a83);
-  a75=(a109*a116);
-  a127=(a44*a114);
-  a107=(a85*a127);
-  a75=(a75+a107);
-  a107=(a41*a85);
-  a6=(a107*a114);
-  a104=(a41*a116);
-  a128=(a83*a104);
-  a6=(a6+a128);
-  a75=(a75-a6);
-  a75=(a19-a75);
-  a75=(a39*a75);
-  a6=(a37*a75);
-  a128=(a111*a6);
-  a129=(a83*a107);
-  a130=(a85*a109);
-  a129=(a129-a130);
-  a40=(a40-a129);
-  a40=(a39*a40);
-  a40=(a37*a40);
-  a40=(a12+a40);
-  a129=(a10*a117);
-  a129=(a40*a129);
-  a128=(a128-a129);
-  a129=(a44*a76);
-  a130=(a85*a129);
-  a131=(a76*a107);
-  a130=(a130-a131);
-  a48=(a48-a130);
-  a48=(a39*a48);
-  a48=(a37*a48);
-  a48=(a15+a48);
-  a130=(a10*a124);
-  a130=(a48*a130);
-  a131=(a10*a89);
-  a132=(a2*a85);
-  a116=(a129*a116);
-  a132=(a132-a116);
-  a116=(a78*a107);
-  a104=(a76*a104);
-  a116=(a116-a104);
-  a132=(a132-a116);
-  a132=(a39*a132);
-  a116=(a37*a132);
-  a104=(a131*a116);
-  a130=(a130-a104);
-  a128=(a128-a130);
-  a130=(a76*a109);
-  a104=(a83*a129);
-  a130=(a130-a104);
-  a53=(a53-a130);
-  a53=(a52*a53);
-  a53=(a37*a53);
-  a53=(a17+a53);
-  a130=(a10*a126);
-  a130=(a53*a130);
-  a104=(a10*a95);
-  a133=(a78*a109);
-  a127=(a76*a127);
-  a133=(a133-a127);
-  a127=(a2*a83);
-  a114=(a129*a114);
-  a127=(a127-a114);
-  a133=(a133-a127);
-  a133=(a52*a133);
-  a127=(a37*a133);
-  a114=(a104*a127);
-  a130=(a130-a114);
-  a128=(a128+a130);
-  a130=(a1*a80);
-  a114=(a80+a80);
-  a134=(a114*a121);
-  a135=(a95+a95);
-  a136=(a135*a126);
-  a134=(a134+a136);
-  a136=(a89+a89);
-  a137=(a136*a124);
-  a134=(a134+a137);
-  a137=(a100+a100);
-  a138=(a137*a117);
-  a134=(a134-a138);
-  a138=(a130*a134);
-  a139=casadi_sq(a80);
-  a140=casadi_sq(a95);
-  a139=(a139+a140);
-  a140=casadi_sq(a89);
-  a139=(a139+a140);
-  a140=casadi_sq(a100);
-  a139=(a139+a140);
-  a139=(a139-a19);
-  a140=(a1*a121);
-  a140=(a139*a140);
-  a138=(a138+a140);
-  a128=(a128-a138);
-  a77=(a77+a128);
-  a77=(a0*a77);
-  if (res[0]!=0) res[0][12]=a77;
-  a93=(a1*a93);
-  a125=(a1*a125);
-  a93=(a93+a125);
-  a125=(a10*a124);
-  a125=(a40*a125);
-  a77=(a10*a89);
-  a128=(a77*a6);
-  a125=(a125+a128);
-  a128=(a10*a117);
-  a128=(a48*a128);
-  a138=(a10*a100);
-  a140=(a138*a116);
-  a128=(a128+a140);
-  a125=(a125-a128);
-  a128=(a10*a121);
-  a128=(a53*a128);
-  a140=(a10*a80);
-  a141=(a140*a127);
-  a128=(a128-a141);
-  a125=(a125-a128);
-  a128=(a1*a95);
-  a141=(a128*a134);
-  a142=(a1*a126);
-  a142=(a139*a142);
-  a141=(a141+a142);
-  a125=(a125-a141);
-  a93=(a93+a125);
-  a93=(a0*a93);
-  if (res[0]!=0) res[0][13]=a93;
-  a123=(a1*a123);
-  a74=(a1*a74);
-  a123=(a123-a74);
-  a74=(a10*a121);
-  a74=(a48*a74);
-  a93=(a10*a80);
-  a125=(a93*a116);
-  a74=(a74-a125);
-  a125=(a10*a126);
-  a125=(a40*a125);
-  a141=(a10*a95);
-  a142=(a141*a6);
-  a125=(a125+a142);
-  a74=(a74-a125);
-  a125=(a10*a117);
-  a125=(a53*a125);
-  a142=(a10*a100);
-  a143=(a142*a127);
-  a125=(a125+a143);
-  a74=(a74-a125);
-  a125=(a1*a89);
-  a143=(a125*a134);
-  a144=(a1*a124);
-  a144=(a139*a144);
-  a143=(a143+a144);
-  a74=(a74-a143);
-  a123=(a123+a74);
-  a123=(a0*a123);
-  if (res[0]!=0) res[0][14]=a123;
-  a106=(a1*a106);
-  a9=(a1*a9);
-  a106=(a106+a9);
-  a121=(a10*a121);
-  a121=(a40*a121);
-  a9=(a10*a80);
-  a123=(a9*a6);
-  a121=(a121+a123);
-  a126=(a10*a126);
-  a126=(a48*a126);
-  a123=(a10*a95);
-  a74=(a123*a116);
-  a126=(a126-a74);
-  a121=(a121+a126);
-  a124=(a10*a124);
-  a124=(a53*a124);
-  a126=(a10*a89);
-  a74=(a126*a127);
-  a124=(a124-a74);
-  a121=(a121+a124);
-  a124=(a1*a100);
-  a134=(a124*a134);
-  a117=(a1*a117);
-  a117=(a139*a117);
-  a134=(a134-a117);
-  a121=(a121+a134);
-  a106=(a106+a121);
-  a106=(a0*a106);
-  a106=(-a106);
-  if (res[0]!=0) res[0][15]=a106;
-  a106=2.0979020979020980e+05;
-  a75=(a1*a75);
-  a75=(a106+a75);
-  a121=(a44*a48);
-  a134=(a121*a127);
-  a117=(a44*a116);
-  a74=(a53*a117);
-  a134=(a134+a74);
-  a74=(a41*a53);
-  a143=(a74*a116);
-  a144=(a41*a127);
-  a145=(a48*a144);
-  a143=(a143+a145);
-  a134=(a134-a143);
-  a134=(a19-a134);
-  a134=(a39*a134);
-  a75=(a75+a134);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][16]=a75;
-  a113=(a1*a113);
-  a132=(a1*a132);
-  a113=(a113+a132);
-  a132=(a44*a6);
-  a75=(a53*a132);
-  a134=(a44*a40);
-  a127=(a134*a127);
-  a75=(a75-a127);
-  a127=(a74*a6);
-  a144=(a40*a144);
-  a127=(a127-a144);
-  a75=(a75-a127);
-  a75=(a39*a75);
-  a113=(a113+a75);
-  a113=(a0*a113);
-  a113=(-a113);
-  if (res[0]!=0) res[0][17]=a113;
-  a115=(a1*a115);
-  a133=(a1*a133);
-  a115=(a115+a133);
-  a6=(a121*a6);
-  a117=(a40*a117);
-  a6=(a6-a117);
-  a132=(a48*a132);
-  a116=(a134*a116);
-  a132=(a132-a116);
-  a6=(a6-a132);
-  a6=(a52*a6);
-  a115=(a115+a6);
-  a115=(a0*a115);
-  a115=(-a115);
-  if (res[0]!=0) res[0][18]=a115;
-  a115=(a78*a57);
-  a6=(a2*a115);
-  a132=(a46*a6);
-  a116=(a78*a47);
-  a117=(a2*a116);
-  a133=(a58*a117);
-  a132=(a132-a133);
-  a133=(a78*a65);
-  a113=(a2*a133);
-  a75=(a69*a113);
-  a127=(a78*a70);
-  a144=(a2*a127);
-  a143=(a64*a144);
-  a75=(a75-a143);
-  a132=(a132+a75);
-  a132=(a1*a132);
-  a132=(a73*a132);
-  a132=(a3*a132);
-  a75=(a37*a132);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][19]=a75;
-  a75=(a58*a113);
-  a143=(a64*a6);
-  a75=(a75+a143);
-  a143=(a69*a117);
-  a145=(a46*a144);
-  a143=(a143+a145);
-  a75=(a75+a143);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a143=(a37*a75);
-  a143=(a0*a143);
-  if (res[0]!=0) res[0][20]=a143;
-  a143=(a110*a113);
-  a145=(a108*a117);
-  a143=(a143-a145);
-  a143=(a1*a143);
-  a143=(a73*a143);
-  a143=(a3*a143);
-  a145=(a37*a143);
-  a145=(a0*a145);
-  a145=(-a145);
-  if (res[0]!=0) res[0][21]=a145;
-  a132=(a1*a132);
-  a145=(a10*a113);
-  a145=(a85*a145);
-  a146=(a2*a43);
-  a147=(a78*a82);
-  a146=(a146-a147);
-  a146=(a52*a146);
-  a147=(a2*a146);
-  a148=(a84*a147);
-  a145=(a145-a148);
-  a148=(a10*a144);
-  a148=(a76*a148);
-  a149=(a78*a26);
-  a150=(a2*a54);
-  a149=(a149-a150);
-  a149=(a39*a149);
-  a150=(a2*a149);
-  a151=(a62*a150);
-  a148=(a148+a151);
-  a151=(a10*a6);
-  a151=(a83*a151);
-  a152=(a78*a81);
-  a151=(a151+a152);
-  a148=(a148+a151);
-  a145=(a145-a148);
-  a148=(a118*a113);
-  a151=(a112*a117);
-  a148=(a148-a151);
-  a151=(a119*a6);
-  a148=(a148+a151);
-  a151=(a120*a144);
-  a148=(a148-a151);
-  a151=(a87*a148);
-  a152=(a1*a117);
-  a152=(a86*a152);
-  a151=(a151-a152);
-  a145=(a145-a151);
-  a151=(a37*a145);
-  a152=(a89*a151);
-  a153=(a78*a88);
-  a154=(a10*a117);
-  a154=(a83*a154);
-  a153=(a153-a154);
-  a154=(a10*a113);
-  a154=(a76*a154);
-  a155=(a90*a150);
-  a154=(a154-a155);
-  a153=(a153-a154);
-  a154=(a10*a144);
-  a154=(a85*a154);
-  a155=(a91*a147);
-  a154=(a154+a155);
-  a153=(a153-a154);
-  a154=(a92*a148);
-  a155=(a1*a6);
-  a155=(a86*a155);
-  a154=(a154+a155);
-  a153=(a153-a154);
-  a154=(a37*a153);
-  a155=(a80*a154);
-  a152=(a152+a155);
-  a155=(a10*a6);
-  a155=(a76*a155);
-  a156=(a94*a150);
-  a155=(a155-a156);
-  a156=(a78*a96);
-  a157=(a10*a144);
-  a157=(a83*a157);
-  a156=(a156-a157);
-  a155=(a155+a156);
-  a156=(a10*a117);
-  a156=(a85*a156);
-  a157=(a97*a147);
-  a156=(a156+a157);
-  a155=(a155+a156);
-  a156=(a98*a148);
-  a157=(a1*a113);
-  a157=(a86*a157);
-  a156=(a156+a157);
-  a155=(a155-a156);
-  a156=(a37*a155);
-  a157=(a100*a156);
-  a113=(a10*a113);
-  a113=(a83*a113);
-  a158=(a78*a101);
-  a113=(a113+a158);
-  a117=(a10*a117);
-  a117=(a76*a117);
-  a158=(a99*a150);
-  a117=(a117+a158);
-  a113=(a113-a117);
-  a6=(a10*a6);
-  a6=(a85*a6);
-  a117=(a102*a147);
-  a6=(a6-a117);
-  a113=(a113+a6);
-  a148=(a103*a148);
-  a144=(a1*a144);
-  a144=(a86*a144);
-  a148=(a148-a144);
-  a113=(a113+a148);
-  a148=(a37*a113);
-  a144=(a95*a148);
-  a157=(a157-a144);
-  a152=(a152+a157);
-  a152=(a1*a152);
-  a152=(a73*a152);
-  a152=(a3*a152);
-  a132=(a132+a152);
-  a132=(a0*a132);
-  if (res[0]!=0) res[0][22]=a132;
-  a75=(a1*a75);
-  a132=(a89*a156);
-  a152=(a95*a154);
-  a132=(a132+a152);
-  a152=(a100*a151);
-  a157=(a80*a148);
-  a152=(a152-a157);
-  a132=(a132-a152);
-  a132=(a1*a132);
-  a132=(a73*a132);
-  a132=(a3*a132);
-  a75=(a75+a132);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][23]=a75;
-  a143=(a1*a143);
-  a75=(a105*a151);
-  a132=(a122*a156);
-  a75=(a75+a132);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a143=(a143+a75);
-  a143=(a0*a143);
-  a143=(-a143);
-  if (res[0]!=0) res[0][24]=a143;
-  a145=(a1*a145);
-  a116=(a1*a116);
-  a145=(a145-a116);
-  a116=(a10*a156);
-  a116=(a53*a116);
-  a143=(a2*a76);
-  a75=(a109*a150);
-  a143=(a143-a75);
-  a75=(a78*a129);
-  a132=(a44*a150);
-  a152=(a83*a132);
-  a75=(a75-a152);
-  a143=(a143-a75);
-  a143=(a52*a143);
-  a75=(a37*a143);
-  a152=(a104*a75);
-  a116=(a116-a152);
-  a152=(a10*a148);
-  a152=(a40*a152);
-  a78=(a78*a107);
-  a157=(a41*a147);
-  a144=(a83*a157);
-  a78=(a78-a144);
-  a144=(a2*a85);
-  a6=(a109*a147);
-  a144=(a144-a6);
-  a78=(a78-a144);
-  a78=(a39*a78);
-  a144=(a37*a78);
-  a6=(a111*a144);
-  a152=(a152+a6);
-  a6=(a10*a154);
-  a6=(a48*a6);
-  a150=(a107*a150);
-  a157=(a76*a157);
-  a150=(a150+a157);
-  a147=(a129*a147);
-  a132=(a85*a132);
-  a147=(a147+a132);
-  a150=(a150-a147);
-  a150=(a19-a150);
-  a150=(a39*a150);
-  a147=(a37*a150);
-  a132=(a131*a147);
-  a6=(a6+a132);
-  a152=(a152+a6);
-  a116=(a116-a152);
-  a152=(a114*a151);
-  a6=(a135*a156);
-  a152=(a152+a6);
-  a6=(a136*a154);
-  a152=(a152+a6);
-  a6=(a137*a148);
-  a152=(a152-a6);
-  a6=(a130*a152);
-  a132=(a1*a151);
-  a132=(a139*a132);
-  a6=(a6+a132);
-  a116=(a116-a6);
-  a145=(a145+a116);
-  a145=(a0*a145);
-  if (res[0]!=0) res[0][25]=a145;
-  a133=(a1*a133);
-  a155=(a1*a155);
-  a133=(a133+a155);
-  a155=(a10*a154);
-  a155=(a40*a155);
-  a145=(a77*a144);
-  a155=(a155-a145);
-  a145=(a138*a147);
-  a116=(a10*a148);
-  a116=(a48*a116);
-  a145=(a145-a116);
-  a155=(a155+a145);
-  a145=(a10*a151);
-  a145=(a53*a145);
-  a116=(a140*a75);
-  a145=(a145-a116);
-  a155=(a155-a145);
-  a145=(a128*a152);
-  a116=(a1*a156);
-  a116=(a139*a116);
-  a145=(a145+a116);
-  a155=(a155-a145);
-  a133=(a133+a155);
-  a133=(a0*a133);
-  if (res[0]!=0) res[0][26]=a133;
-  a115=(a1*a115);
-  a153=(a1*a153);
-  a115=(a115+a153);
-  a153=(a10*a151);
-  a153=(a48*a153);
-  a133=(a93*a147);
-  a153=(a153+a133);
-  a133=(a10*a156);
-  a133=(a40*a133);
-  a155=(a141*a144);
-  a133=(a133-a155);
-  a153=(a153-a133);
-  a133=(a10*a148);
-  a133=(a53*a133);
-  a155=(a142*a75);
-  a133=(a133+a155);
-  a153=(a153-a133);
-  a133=(a125*a152);
-  a155=(a1*a154);
-  a155=(a139*a155);
-  a133=(a133+a155);
-  a153=(a153-a133);
-  a115=(a115+a153);
-  a115=(a0*a115);
-  if (res[0]!=0) res[0][27]=a115;
-  a127=(a1*a127);
-  a113=(a1*a113);
-  a127=(a127+a113);
-  a151=(a10*a151);
-  a151=(a40*a151);
-  a113=(a9*a144);
-  a151=(a151-a113);
-  a156=(a10*a156);
-  a156=(a48*a156);
-  a113=(a123*a147);
-  a156=(a156+a113);
-  a151=(a151+a156);
-  a154=(a10*a154);
-  a154=(a53*a154);
-  a156=(a126*a75);
-  a154=(a154-a156);
-  a151=(a151+a154);
-  a152=(a124*a152);
-  a148=(a1*a148);
-  a148=(a139*a148);
-  a152=(a152-a148);
-  a151=(a151+a152);
-  a127=(a127+a151);
-  a127=(a0*a127);
-  a127=(-a127);
-  if (res[0]!=0) res[0][28]=a127;
-  a149=(a1*a149);
-  a78=(a1*a78);
-  a149=(a149+a78);
-  a78=(a74*a147);
-  a127=(a41*a75);
-  a151=(a48*a127);
-  a78=(a78-a151);
-  a151=(a44*a147);
-  a152=(a53*a151);
-  a148=(a121*a75);
-  a152=(a152-a148);
-  a78=(a78-a152);
-  a78=(a39*a78);
-  a149=(a149+a78);
-  a149=(a0*a149);
-  a149=(-a149);
-  if (res[0]!=0) res[0][29]=a149;
-  a150=(a1*a150);
-  a106=(a106+a150);
-  a150=(a74*a144);
-  a127=(a40*a127);
-  a150=(a150+a127);
-  a75=(a134*a75);
-  a127=(a44*a144);
-  a149=(a53*a127);
-  a75=(a75+a149);
-  a150=(a150-a75);
-  a150=(a19-a150);
-  a150=(a39*a150);
-  a106=(a106+a150);
-  a106=(a0*a106);
-  if (res[0]!=0) res[0][30]=a106;
-  a146=(a1*a146);
-  a143=(a1*a143);
-  a146=(a146+a143);
-  a151=(a40*a151);
-  a144=(a121*a144);
-  a151=(a151-a144);
-  a147=(a134*a147);
-  a127=(a48*a127);
-  a147=(a147-a127);
-  a151=(a151-a147);
-  a151=(a52*a151);
-  a146=(a146+a151);
-  a146=(a0*a146);
-  a146=(-a146);
-  if (res[0]!=0) res[0][31]=a146;
-  a146=1.7301038062283737e+02;
-  a151=(a146*a51);
-  a147=(a2*a151);
-  a127=(a58*a147);
-  a144=(a146*a60);
-  a143=(a2*a144);
-  a106=(a46*a143);
-  a127=(a127+a106);
-  a106=(a146*a66);
-  a150=(a2*a106);
-  a75=(a69*a150);
-  a149=(a146*a71);
-  a78=(a2*a149);
-  a152=(a64*a78);
-  a75=(a75+a152);
-  a127=(a127-a75);
-  a127=(a1*a127);
-  a127=(a73*a127);
-  a127=(a3*a127);
-  a75=(a37*a127);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][32]=a75;
-  a75=(a64*a143);
-  a152=(a58*a150);
-  a75=(a75-a152);
-  a152=(a69*a147);
-  a148=(a46*a78);
-  a152=(a152-a148);
-  a75=(a75-a152);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a152=(a37*a75);
-  a152=(a0*a152);
-  if (res[0]!=0) res[0][33]=a152;
-  a152=(a108*a147);
-  a148=(a110*a150);
-  a152=(a152-a148);
-  a152=(a1*a152);
-  a152=(a73*a152);
-  a152=(a3*a152);
-  a148=(a37*a152);
-  a148=(a0*a148);
-  a148=(-a148);
-  if (res[0]!=0) res[0][34]=a148;
-  a127=(a1*a127);
-  a148=(a146*a84);
-  a154=(a10*a150);
-  a154=(a85*a154);
-  a148=(a148-a154);
-  a154=(a10*a78);
-  a154=(a76*a154);
-  a156=(a2*a50);
-  a113=(a146*a79);
-  a156=(a156-a113);
-  a156=(a39*a156);
-  a113=(a2*a156);
-  a115=(a62*a113);
-  a154=(a154+a115);
-  a115=(a10*a143);
-  a115=(a83*a115);
-  a153=(a146*a82);
-  a133=(a2*a43);
-  a153=(a153-a133);
-  a153=(a39*a153);
-  a133=(a2*a153);
-  a155=(a81*a133);
-  a115=(a115-a155);
-  a154=(a154+a115);
-  a148=(a148-a154);
-  a154=(a112*a147);
-  a115=(a118*a150);
-  a154=(a154-a115);
-  a115=(a119*a143);
-  a154=(a154+a115);
-  a115=(a120*a78);
-  a154=(a154-a115);
-  a115=(a87*a154);
-  a155=(a1*a147);
-  a155=(a86*a155);
-  a115=(a115+a155);
-  a148=(a148-a115);
-  a115=(a37*a148);
-  a155=(a89*a115);
-  a145=(a10*a147);
-  a145=(a83*a145);
-  a116=(a88*a133);
-  a145=(a145-a116);
-  a116=(a10*a150);
-  a116=(a76*a116);
-  a6=(a90*a113);
-  a116=(a116+a6);
-  a145=(a145+a116);
-  a116=(a146*a91);
-  a6=(a10*a78);
-  a6=(a85*a6);
-  a116=(a116-a6);
-  a145=(a145+a116);
-  a116=(a92*a154);
-  a6=(a1*a143);
-  a6=(a86*a6);
-  a116=(a116+a6);
-  a145=(a145-a116);
-  a116=(a37*a145);
-  a6=(a80*a116);
-  a155=(a155+a6);
-  a6=(a10*a143);
-  a6=(a76*a6);
-  a132=(a94*a113);
-  a6=(a6-a132);
-  a132=(a10*a78);
-  a132=(a83*a132);
-  a157=(a96*a133);
-  a132=(a132+a157);
-  a6=(a6-a132);
-  a132=(a10*a147);
-  a132=(a85*a132);
-  a157=(a146*a97);
-  a132=(a132+a157);
-  a6=(a6-a132);
-  a132=(a98*a154);
-  a157=(a1*a150);
-  a157=(a86*a157);
-  a132=(a132-a157);
-  a6=(a6-a132);
-  a132=(a37*a6);
-  a157=(a100*a132);
-  a147=(a10*a147);
-  a147=(a76*a147);
-  a117=(a99*a113);
-  a147=(a147-a117);
-  a150=(a10*a150);
-  a150=(a83*a150);
-  a117=(a101*a133);
-  a150=(a150+a117);
-  a147=(a147-a150);
-  a143=(a10*a143);
-  a143=(a85*a143);
-  a150=(a146*a102);
-  a143=(a143+a150);
-  a147=(a147+a143);
-  a154=(a103*a154);
-  a78=(a1*a78);
-  a78=(a86*a78);
-  a154=(a154-a78);
-  a147=(a147+a154);
-  a154=(a37*a147);
-  a78=(a95*a154);
-  a157=(a157-a78);
-  a155=(a155+a157);
-  a155=(a1*a155);
-  a155=(a73*a155);
-  a155=(a3*a155);
-  a127=(a127+a155);
-  a127=(a0*a127);
-  if (res[0]!=0) res[0][35]=a127;
-  a75=(a1*a75);
-  a127=(a89*a132);
-  a155=(a95*a116);
-  a127=(a127+a155);
-  a155=(a100*a115);
-  a157=(a80*a154);
-  a155=(a155-a157);
-  a127=(a127-a155);
-  a127=(a1*a127);
-  a127=(a73*a127);
-  a127=(a3*a127);
-  a75=(a75+a127);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][36]=a75;
-  a152=(a1*a152);
-  a75=(a105*a115);
-  a127=(a122*a132);
-  a75=(a75+a127);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a152=(a152+a75);
-  a152=(a0*a152);
-  a152=(-a152);
-  if (res[0]!=0) res[0][37]=a152;
-  a151=(a1*a151);
-  a148=(a1*a148);
-  a151=(a151+a148);
-  a148=(a10*a132);
-  a148=(a53*a148);
-  a152=(a129*a133);
-  a75=(a44*a113);
-  a127=(a83*a75);
-  a152=(a152+a127);
-  a127=(a109*a113);
-  a155=(a44*a133);
-  a157=(a76*a155);
-  a127=(a127+a157);
-  a152=(a152-a127);
-  a152=(a19-a152);
-  a152=(a52*a152);
-  a127=(a37*a152);
-  a157=(a104*a127);
-  a148=(a148+a157);
-  a157=(a10*a154);
-  a157=(a40*a157);
-  a78=(a2*a83);
-  a133=(a107*a133);
-  a78=(a78-a133);
-  a133=(a146*a109);
-  a155=(a85*a155);
-  a133=(a133-a155);
-  a78=(a78-a133);
-  a78=(a39*a78);
-  a133=(a37*a78);
-  a155=(a111*a133);
-  a157=(a157+a155);
-  a155=(a10*a116);
-  a155=(a48*a155);
-  a146=(a146*a129);
-  a75=(a85*a75);
-  a146=(a146-a75);
-  a75=(a2*a76);
-  a113=(a107*a113);
-  a75=(a75-a113);
-  a146=(a146-a75);
-  a146=(a39*a146);
-  a75=(a37*a146);
-  a113=(a131*a75);
-  a155=(a155-a113);
-  a157=(a157+a155);
-  a148=(a148-a157);
-  a157=(a114*a115);
-  a155=(a135*a132);
-  a157=(a157+a155);
-  a155=(a136*a116);
-  a157=(a157+a155);
-  a155=(a137*a154);
-  a157=(a157-a155);
-  a155=(a130*a157);
-  a113=(a1*a115);
-  a113=(a139*a113);
-  a155=(a155+a113);
-  a148=(a148-a155);
-  a151=(a151+a148);
-  a151=(a0*a151);
-  if (res[0]!=0) res[0][38]=a151;
-  a6=(a1*a6);
-  a106=(a1*a106);
-  a6=(a6-a106);
-  a106=(a10*a116);
-  a106=(a40*a106);
-  a151=(a77*a133);
-  a106=(a106-a151);
-  a151=(a10*a154);
-  a151=(a48*a151);
-  a148=(a138*a75);
-  a151=(a151+a148);
-  a106=(a106-a151);
-  a151=(a10*a115);
-  a151=(a53*a151);
-  a148=(a140*a127);
-  a151=(a151+a148);
-  a106=(a106-a151);
-  a151=(a128*a157);
-  a148=(a1*a132);
-  a148=(a139*a148);
-  a151=(a151+a148);
-  a106=(a106-a151);
-  a6=(a6+a106);
-  a6=(a0*a6);
-  if (res[0]!=0) res[0][39]=a6;
-  a144=(a1*a144);
-  a145=(a1*a145);
-  a144=(a144+a145);
-  a145=(a10*a115);
-  a145=(a48*a145);
-  a6=(a93*a75);
-  a145=(a145-a6);
-  a6=(a10*a132);
-  a6=(a40*a6);
-  a106=(a141*a133);
-  a6=(a6-a106);
-  a145=(a145-a6);
-  a6=(a142*a127);
-  a106=(a10*a154);
-  a106=(a53*a106);
-  a6=(a6-a106);
-  a145=(a145+a6);
-  a6=(a125*a157);
-  a106=(a1*a116);
-  a106=(a139*a106);
-  a6=(a6+a106);
-  a145=(a145-a6);
-  a144=(a144+a145);
-  a144=(a0*a144);
-  if (res[0]!=0) res[0][40]=a144;
-  a149=(a1*a149);
-  a147=(a1*a147);
-  a149=(a149+a147);
-  a115=(a10*a115);
-  a115=(a40*a115);
-  a147=(a9*a133);
-  a115=(a115-a147);
-  a132=(a10*a132);
-  a132=(a48*a132);
-  a147=(a123*a75);
-  a132=(a132-a147);
-  a115=(a115+a132);
-  a116=(a10*a116);
-  a116=(a53*a116);
-  a132=(a126*a127);
-  a116=(a116+a132);
-  a115=(a115+a116);
-  a157=(a124*a157);
-  a154=(a1*a154);
-  a154=(a139*a154);
-  a157=(a157-a154);
-  a115=(a115+a157);
-  a149=(a149+a115);
-  a149=(a0*a149);
-  a149=(-a149);
-  if (res[0]!=0) res[0][41]=a149;
-  a156=(a1*a156);
-  a78=(a1*a78);
-  a156=(a156+a78);
-  a78=(a41*a127);
-  a149=(a48*a78);
-  a115=(a74*a75);
-  a149=(a149-a115);
-  a115=(a121*a127);
-  a157=(a44*a75);
-  a154=(a53*a157);
-  a115=(a115-a154);
-  a149=(a149-a115);
-  a149=(a39*a149);
-  a156=(a156+a149);
-  a156=(a0*a156);
-  a156=(-a156);
-  if (res[0]!=0) res[0][42]=a156;
-  a153=(a1*a153);
-  a146=(a1*a146);
-  a153=(a153+a146);
-  a127=(a134*a127);
-  a146=(a44*a133);
-  a156=(a53*a146);
-  a127=(a127-a156);
-  a78=(a40*a78);
-  a156=(a74*a133);
-  a78=(a78-a156);
-  a127=(a127-a78);
-  a127=(a39*a127);
-  a153=(a153+a127);
-  a153=(a0*a153);
-  a153=(-a153);
-  if (res[0]!=0) res[0][43]=a153;
-  a153=1.0380622837370241e+05;
-  a152=(a1*a152);
-  a153=(a153+a152);
-  a75=(a134*a75);
-  a146=(a48*a146);
-  a75=(a75+a146);
-  a133=(a121*a133);
-  a157=(a40*a157);
-  a133=(a133+a157);
-  a75=(a75-a133);
-  a75=(a19-a75);
-  a75=(a52*a75);
-  a153=(a153+a75);
-  a153=(a0*a153);
-  if (res[0]!=0) res[0][44]=a153;
-  if (res[0]!=0) res[0][45]=a19;
-  if (res[0]!=0) res[0][46]=a19;
-  if (res[0]!=0) res[0][47]=a19;
-  if (res[0]!=0) res[0][48]=a37;
-  if (res[0]!=0) res[0][49]=a19;
-  if (res[0]!=0) res[0][50]=a37;
-  if (res[0]!=0) res[0][51]=a19;
-  if (res[0]!=0) res[0][52]=a37;
-  if (res[0]!=0) res[0][53]=a19;
-  a153=(a1*a5);
-  a153=(a73*a153);
-  a153=(a3*a153);
-  a75=(a2*a153);
-  a75=(a1*a75);
-  a133=(a4+a4);
-  a157=(a20*a133);
-  a146=(a1*a18);
-  a157=(a157+a146);
-  a146=(a2*a157);
-  a146=(a19-a146);
-  a152=(a22*a146);
-  a127=(a10*a15);
-  a78=(a25*a133);
-  a127=(a127-a78);
-  a78=(a2*a127);
-  a156=(a13*a78);
-  a152=(a152+a156);
-  a156=(a10*a17);
-  a149=(a31*a133);
-  a156=(a156+a149);
-  a149=(a2*a156);
-  a115=(a33*a149);
-  a154=(a10*a12);
-  a133=(a36*a133);
-  a154=(a154+a133);
-  a133=(a2*a154);
-  a116=(a28*a133);
-  a115=(a115+a116);
-  a152=(a152-a115);
-  a152=(a1*a152);
-  a152=(a73*a152);
-  a152=(a3*a152);
-  a115=(a2*a152);
-  a115=(a1*a115);
-  a75=(a75+a115);
-  a115=(a10*a133);
-  a115=(a43*a115);
-  a116=(a10*a78);
-  a116=(a50*a116);
-  a115=(a115+a116);
-  a116=(a10*a149);
-  a116=(a54*a116);
-  a115=(a115+a116);
-  a116=(a13+a13);
-  a132=(a116*a146);
-  a147=(a28+a28);
-  a144=(a147*a149);
-  a132=(a132-a144);
-  a144=(a22+a22);
-  a145=(a144*a78);
-  a132=(a132+a145);
-  a145=(a33+a33);
-  a6=(a145*a133);
-  a132=(a132-a6);
-  a6=(a56*a132);
-  a106=(a1*a146);
-  a106=(a55*a106);
-  a6=(a6+a106);
-  a115=(a115+a6);
-  a6=(a2*a115);
-  a6=(a19-a6);
-  a106=(a58*a6);
-  a151=(a10*a146);
-  a151=(a50*a151);
-  a148=(a10*a149);
-  a148=(a43*a148);
-  a151=(a151+a148);
-  a148=(a10*a133);
-  a148=(a54*a148);
-  a151=(a151-a148);
-  a148=(a61*a132);
-  a155=(a1*a78);
-  a155=(a55*a155);
-  a148=(a148+a155);
-  a151=(a151-a148);
-  a148=(a2*a151);
-  a155=(a46*a148);
-  a106=(a106+a155);
-  a155=(a10*a78);
-  a155=(a43*a155);
-  a113=(a10*a133);
-  a113=(a50*a113);
-  a155=(a155-a113);
-  a113=(a10*a146);
-  a113=(a54*a113);
-  a155=(a155-a113);
-  a113=(a67*a132);
-  a143=(a1*a149);
-  a143=(a55*a143);
-  a113=(a113-a143);
-  a155=(a155-a113);
-  a113=(a2*a155);
-  a143=(a69*a113);
-  a150=(a10*a146);
-  a150=(a43*a150);
-  a117=(a10*a149);
-  a117=(a50*a117);
-  a150=(a150-a117);
-  a117=(a10*a78);
-  a117=(a54*a117);
-  a150=(a150+a117);
-  a132=(a72*a132);
-  a117=(a1*a133);
-  a117=(a55*a117);
-  a132=(a132-a117);
-  a150=(a150+a132);
-  a132=(a2*a150);
-  a117=(a64*a132);
-  a143=(a143-a117);
-  a106=(a106+a143);
-  a106=(a1*a106);
-  a106=(a73*a106);
-  a106=(a3*a106);
-  a143=(a37*a106);
-  a75=(a75+a143);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][54]=a75;
-  a78=(a28*a78);
-  a75=(a22*a149);
-  a78=(a78-a75);
-  a75=(a33*a146);
-  a133=(a13*a133);
-  a75=(a75-a133);
-  a78=(a78-a75);
-  a78=(a1*a78);
-  a78=(a73*a78);
-  a78=(a3*a78);
-  a75=(a2*a78);
-  a75=(a1*a75);
-  a133=(a1*a8);
-  a133=(a73*a133);
-  a133=(a3*a133);
-  a143=(a2*a133);
-  a143=(a1*a143);
-  a75=(a75-a143);
-  a143=(a58*a113);
-  a117=(a64*a148);
-  a143=(a143+a117);
-  a117=(a69*a6);
-  a158=(a46*a132);
-  a117=(a117-a158);
-  a143=(a143-a117);
-  a143=(a1*a143);
-  a143=(a73*a143);
-  a143=(a3*a143);
-  a117=(a37*a143);
-  a75=(a75+a117);
-  a75=(a0*a75);
-  if (res[0]!=0) res[0][55]=a75;
-  a75=(a4+a4);
-  a75=(a1*a75);
-  a75=(a73*a75);
-  a75=(a3*a75);
-  a117=(a2*a75);
-  a117=(a1*a117);
-  a158=(a13+a13);
-  a146=(a158*a146);
-  a159=(a28+a28);
-  a149=(a159*a149);
-  a146=(a146-a149);
-  a146=(a1*a146);
-  a146=(a73*a146);
-  a146=(a3*a146);
-  a149=(a2*a146);
-  a149=(a1*a149);
-  a117=(a117+a149);
-  a149=(a108*a6);
-  a160=(a110*a113);
-  a149=(a149+a160);
-  a149=(a1*a149);
-  a149=(a73*a149);
-  a149=(a3*a149);
-  a160=(a37*a149);
-  a117=(a117+a160);
-  a117=(a0*a117);
-  a117=(-a117);
-  if (res[0]!=0) res[0][56]=a117;
-  a152=(a1*a152);
-  a153=(a153+a152);
-  a106=(a1*a106);
-  a153=(a153+a106);
-  a106=(a10*a113);
-  a106=(a85*a106);
-  a152=(a10*a132);
-  a152=(a76*a152);
-  a117=(a10*a148);
-  a117=(a83*a117);
-  a152=(a152+a117);
-  a106=(a106-a152);
-  a152=(a112*a6);
-  a117=(a118*a113);
-  a152=(a152+a117);
-  a117=(a119*a148);
-  a152=(a152+a117);
-  a117=(a120*a132);
-  a152=(a152-a117);
-  a117=(a87*a152);
-  a160=(a1*a6);
-  a160=(a86*a160);
-  a117=(a117+a160);
-  a106=(a106-a117);
-  a117=(a37*a106);
-  a117=(a19+a117);
-  a160=(a89*a117);
-  a161=(a10*a6);
-  a161=(a83*a161);
-  a162=(a10*a113);
-  a162=(a76*a162);
-  a161=(a161-a162);
-  a162=(a10*a132);
-  a162=(a85*a162);
-  a161=(a161-a162);
-  a162=(a92*a152);
-  a163=(a1*a148);
-  a163=(a86*a163);
-  a162=(a162+a163);
-  a161=(a161-a162);
-  a162=(a37*a161);
-  a163=(a80*a162);
-  a160=(a160+a163);
-  a163=(a10*a148);
-  a163=(a76*a163);
-  a164=(a10*a132);
-  a164=(a83*a164);
-  a163=(a163-a164);
-  a164=(a10*a6);
-  a164=(a85*a164);
-  a163=(a163-a164);
-  a164=(a98*a152);
-  a165=(a1*a113);
-  a165=(a86*a165);
-  a164=(a164+a165);
-  a163=(a163-a164);
-  a164=(a37*a163);
-  a165=(a100*a164);
-  a6=(a10*a6);
-  a6=(a76*a6);
-  a113=(a10*a113);
-  a113=(a83*a113);
-  a6=(a6+a113);
-  a148=(a10*a148);
-  a148=(a85*a148);
-  a6=(a6+a148);
-  a152=(a103*a152);
-  a132=(a1*a132);
-  a132=(a86*a132);
-  a152=(a152-a132);
-  a6=(a6+a152);
-  a152=(a37*a6);
-  a132=(a95*a152);
-  a165=(a165-a132);
-  a160=(a160+a165);
-  a160=(a1*a160);
-  a160=(a73*a160);
-  a160=(a3*a160);
-  a153=(a153+a160);
-  a153=(a0*a153);
-  if (res[0]!=0) res[0][57]=a153;
-  a78=(a1*a78);
-  a78=(a78-a133);
-  a143=(a1*a143);
-  a78=(a78+a143);
-  a143=(a89*a164);
-  a133=(a95*a162);
-  a143=(a143+a133);
-  a133=(a100*a117);
-  a153=(a80*a152);
-  a133=(a133-a153);
-  a143=(a143-a133);
-  a143=(a1*a143);
-  a143=(a73*a143);
-  a143=(a3*a143);
-  a78=(a78+a143);
-  a78=(a0*a78);
-  if (res[0]!=0) res[0][58]=a78;
-  a146=(a1*a146);
-  a75=(a75+a146);
-  a149=(a1*a149);
-  a75=(a75+a149);
-  a149=(a105*a117);
-  a146=(a122*a164);
-  a149=(a149+a146);
-  a149=(a1*a149);
-  a149=(a73*a149);
-  a149=(a3*a149);
-  a75=(a75+a149);
-  a75=(a0*a75);
-  a75=(-a75);
-  if (res[0]!=0) res[0][59]=a75;
-  a106=(a1*a106);
-  a115=(a1*a115);
-  a157=(a157+a115);
-  a106=(a106-a157);
-  a157=(a10*a164);
-  a157=(a53*a157);
-  a115=(a10*a152);
-  a115=(a40*a115);
-  a75=(a10*a162);
-  a75=(a48*a75);
-  a115=(a115+a75);
-  a157=(a157-a115);
-  a115=(a114*a117);
-  a75=(a135*a164);
-  a115=(a115+a75);
-  a75=(a136*a162);
-  a115=(a115+a75);
-  a75=(a137*a152);
-  a115=(a115-a75);
-  a75=(a130*a115);
-  a149=(a1*a117);
-  a149=(a139*a149);
-  a75=(a75+a149);
-  a157=(a157-a75);
-  a106=(a106+a157);
-  a106=(a0*a106);
-  a106=(a19+a106);
-  if (res[0]!=0) res[0][60]=a106;
-  a155=(a1*a155);
-  a155=(a155-a156);
-  a163=(a1*a163);
-  a155=(a155+a163);
-  a163=(a10*a162);
-  a163=(a40*a163);
-  a156=(a10*a152);
-  a156=(a48*a156);
-  a163=(a163-a156);
-  a156=(a10*a117);
-  a156=(a53*a156);
-  a163=(a163-a156);
-  a156=(a128*a115);
-  a106=(a1*a164);
-  a106=(a139*a106);
-  a156=(a156+a106);
-  a163=(a163-a156);
-  a155=(a155+a163);
-  a155=(a0*a155);
-  if (res[0]!=0) res[0][61]=a155;
-  a151=(a1*a151);
-  a127=(a127+a151);
-  a161=(a1*a161);
-  a127=(a127+a161);
-  a161=(a10*a117);
-  a161=(a48*a161);
-  a151=(a10*a164);
-  a151=(a40*a151);
-  a161=(a161-a151);
-  a151=(a10*a152);
-  a151=(a53*a151);
-  a161=(a161-a151);
-  a151=(a125*a115);
-  a155=(a1*a162);
-  a155=(a139*a155);
-  a151=(a151+a155);
-  a161=(a161-a151);
-  a127=(a127+a161);
-  a127=(a0*a127);
-  if (res[0]!=0) res[0][62]=a127;
-  a150=(a1*a150);
-  a154=(a154+a150);
-  a6=(a1*a6);
-  a154=(a154+a6);
-  a117=(a10*a117);
-  a117=(a40*a117);
-  a164=(a10*a164);
-  a164=(a48*a164);
-  a117=(a117+a164);
-  a162=(a10*a162);
-  a162=(a53*a162);
-  a117=(a117+a162);
-  a115=(a124*a115);
-  a152=(a1*a152);
-  a152=(a139*a152);
-  a115=(a115-a152);
-  a117=(a117+a115);
-  a154=(a154+a117);
-  a154=(a0*a154);
-  a154=(-a154);
-  if (res[0]!=0) res[0][63]=a154;
-  a154=(a1*a8);
-  a154=(a73*a154);
-  a154=(a3*a154);
-  a117=(a2*a154);
-  a117=(a1*a117);
-  a115=(a10*a17);
-  a152=(a7+a7);
-  a162=(a20*a152);
-  a115=(a115-a162);
-  a162=(a2*a115);
-  a164=(a22*a162);
-  a6=(a10*a12);
-  a150=(a25*a152);
-  a6=(a6+a150);
-  a150=(a2*a6);
-  a127=(a13*a150);
-  a164=(a164-a127);
-  a127=(a31*a152);
-  a161=(a1*a18);
-  a127=(a127+a161);
-  a161=(a2*a127);
-  a161=(a19-a161);
-  a151=(a33*a161);
-  a155=(a10*a15);
-  a152=(a36*a152);
-  a155=(a155+a152);
-  a152=(a2*a155);
-  a163=(a28*a152);
-  a151=(a151-a163);
-  a164=(a164+a151);
-  a164=(a1*a164);
-  a164=(a73*a164);
-  a164=(a3*a164);
-  a151=(a2*a164);
-  a151=(a1*a151);
-  a117=(a117+a151);
-  a151=(a10*a150);
-  a151=(a50*a151);
-  a163=(a10*a152);
-  a163=(a43*a163);
-  a151=(a151-a163);
-  a163=(a10*a161);
-  a163=(a54*a163);
-  a151=(a151+a163);
-  a163=(a116*a162);
-  a156=(a147*a161);
-  a163=(a163+a156);
-  a156=(a144*a150);
-  a163=(a163-a156);
-  a156=(a145*a152);
-  a163=(a163-a156);
-  a156=(a56*a163);
-  a106=(a1*a162);
-  a106=(a55*a106);
-  a156=(a156+a106);
-  a151=(a151-a156);
-  a156=(a2*a151);
-  a106=(a58*a156);
-  a157=(a10*a162);
-  a157=(a50*a157);
-  a75=(a10*a161);
-  a75=(a43*a75);
-  a157=(a157-a75);
-  a75=(a10*a152);
-  a75=(a54*a75);
-  a157=(a157-a75);
-  a75=(a61*a163);
-  a149=(a1*a150);
-  a149=(a55*a149);
-  a75=(a75-a149);
-  a157=(a157-a75);
-  a75=(a2*a157);
-  a149=(a46*a75);
-  a106=(a106+a149);
-  a149=(a10*a150);
-  a149=(a43*a149);
-  a146=(a10*a152);
-  a146=(a50*a146);
-  a149=(a149+a146);
-  a146=(a10*a162);
-  a146=(a54*a146);
-  a149=(a149+a146);
-  a146=(a67*a163);
-  a78=(a1*a161);
-  a78=(a55*a78);
-  a146=(a146+a78);
-  a149=(a149+a146);
-  a146=(a2*a149);
-  a146=(a19-a146);
-  a78=(a69*a146);
-  a143=(a10*a162);
-  a143=(a43*a143);
-  a133=(a10*a161);
-  a133=(a50*a133);
-  a143=(a143+a133);
-  a133=(a10*a150);
-  a133=(a54*a133);
-  a143=(a143-a133);
-  a163=(a72*a163);
-  a133=(a1*a152);
-  a133=(a55*a133);
-  a163=(a163-a133);
-  a143=(a143+a163);
-  a163=(a2*a143);
-  a133=(a64*a163);
-  a78=(a78-a133);
-  a106=(a106+a78);
-  a106=(a1*a106);
-  a106=(a73*a106);
-  a106=(a3*a106);
-  a78=(a37*a106);
-  a117=(a117+a78);
-  a117=(a0*a117);
-  if (res[0]!=0) res[0][64]=a117;
-  a117=(a1*a5);
-  a117=(a73*a117);
-  a117=(a3*a117);
-  a78=(a2*a117);
-  a78=(a1*a78);
-  a133=(a22*a161);
-  a150=(a28*a150);
-  a133=(a133-a150);
-  a150=(a33*a162);
-  a152=(a13*a152);
-  a150=(a150-a152);
-  a133=(a133-a150);
-  a133=(a1*a133);
-  a133=(a73*a133);
-  a133=(a3*a133);
-  a150=(a2*a133);
-  a150=(a1*a150);
-  a78=(a78+a150);
-  a150=(a58*a146);
-  a152=(a64*a75);
-  a150=(a150+a152);
-  a152=(a69*a156);
-  a153=(a46*a163);
-  a152=(a152-a153);
-  a150=(a150-a152);
-  a150=(a1*a150);
-  a150=(a73*a150);
-  a150=(a3*a150);
-  a152=(a37*a150);
-  a78=(a78+a152);
-  a78=(a0*a78);
-  if (res[0]!=0) res[0][65]=a78;
-  a78=(a7+a7);
-  a78=(a1*a78);
-  a78=(a73*a78);
-  a78=(a3*a78);
-  a152=(a2*a78);
-  a152=(a1*a152);
-  a162=(a158*a162);
-  a161=(a159*a161);
-  a162=(a162+a161);
-  a162=(a1*a162);
-  a162=(a73*a162);
-  a162=(a3*a162);
-  a161=(a2*a162);
-  a161=(a1*a161);
-  a152=(a152+a161);
-  a161=(a108*a156);
-  a153=(a110*a146);
-  a161=(a161+a153);
-  a161=(a1*a161);
-  a161=(a73*a161);
-  a161=(a3*a161);
-  a153=(a37*a161);
-  a152=(a152+a153);
-  a152=(a0*a152);
-  a152=(-a152);
-  if (res[0]!=0) res[0][66]=a152;
-  a164=(a1*a164);
-  a154=(a154+a164);
-  a106=(a1*a106);
-  a154=(a154+a106);
-  a106=(a10*a146);
-  a106=(a85*a106);
-  a164=(a10*a163);
-  a164=(a76*a164);
-  a152=(a10*a75);
-  a152=(a83*a152);
-  a164=(a164+a152);
-  a106=(a106-a164);
-  a164=(a112*a156);
-  a152=(a118*a146);
-  a164=(a164+a152);
-  a152=(a119*a75);
-  a164=(a164+a152);
-  a152=(a120*a163);
-  a164=(a164-a152);
-  a152=(a87*a164);
-  a153=(a1*a156);
-  a153=(a86*a153);
-  a152=(a152+a153);
-  a106=(a106-a152);
-  a152=(a37*a106);
-  a153=(a89*a152);
-  a160=(a10*a156);
-  a160=(a83*a160);
-  a165=(a10*a146);
-  a165=(a76*a165);
-  a160=(a160-a165);
-  a165=(a10*a163);
-  a165=(a85*a165);
-  a160=(a160-a165);
-  a165=(a92*a164);
-  a132=(a1*a75);
-  a132=(a86*a132);
-  a165=(a165+a132);
-  a160=(a160-a165);
-  a165=(a37*a160);
-  a132=(a80*a165);
-  a153=(a153+a132);
-  a132=(a10*a75);
-  a132=(a76*a132);
-  a148=(a10*a163);
-  a148=(a83*a148);
-  a132=(a132-a148);
-  a148=(a10*a156);
-  a148=(a85*a148);
-  a132=(a132-a148);
-  a148=(a98*a164);
-  a113=(a1*a146);
-  a113=(a86*a113);
-  a148=(a148+a113);
-  a132=(a132-a148);
-  a148=(a37*a132);
-  a148=(a19+a148);
-  a113=(a100*a148);
-  a156=(a10*a156);
-  a156=(a76*a156);
-  a146=(a10*a146);
-  a146=(a83*a146);
-  a156=(a156+a146);
-  a75=(a10*a75);
-  a75=(a85*a75);
-  a156=(a156+a75);
-  a164=(a103*a164);
-  a163=(a1*a163);
-  a163=(a86*a163);
-  a164=(a164-a163);
-  a156=(a156+a164);
-  a164=(a37*a156);
-  a163=(a95*a164);
-  a113=(a113-a163);
-  a153=(a153+a113);
-  a153=(a1*a153);
-  a153=(a73*a153);
-  a153=(a3*a153);
-  a154=(a154+a153);
-  a154=(a0*a154);
-  if (res[0]!=0) res[0][67]=a154;
-  a133=(a1*a133);
-  a117=(a117+a133);
-  a150=(a1*a150);
-  a117=(a117+a150);
-  a150=(a89*a148);
-  a133=(a95*a165);
-  a150=(a150+a133);
-  a133=(a100*a152);
-  a154=(a80*a164);
-  a133=(a133-a154);
-  a150=(a150-a133);
-  a150=(a1*a150);
-  a150=(a73*a150);
-  a150=(a3*a150);
-  a117=(a117+a150);
-  a117=(a0*a117);
-  if (res[0]!=0) res[0][68]=a117;
-  a162=(a1*a162);
-  a78=(a78+a162);
-  a161=(a1*a161);
-  a78=(a78+a161);
-  a161=(a105*a152);
-  a162=(a122*a148);
-  a161=(a161+a162);
-  a161=(a1*a161);
-  a161=(a73*a161);
-  a161=(a3*a161);
-  a78=(a78+a161);
-  a78=(a0*a78);
-  a78=(-a78);
-  if (res[0]!=0) res[0][69]=a78;
-  a151=(a1*a151);
-  a115=(a115+a151);
-  a106=(a1*a106);
-  a115=(a115+a106);
-  a106=(a10*a148);
-  a106=(a53*a106);
-  a151=(a10*a164);
-  a151=(a40*a151);
-  a78=(a10*a165);
-  a78=(a48*a78);
-  a151=(a151+a78);
-  a106=(a106-a151);
-  a151=(a114*a152);
-  a78=(a135*a148);
-  a151=(a151+a78);
-  a78=(a136*a165);
-  a151=(a151+a78);
-  a78=(a137*a164);
-  a151=(a151-a78);
-  a78=(a130*a151);
-  a161=(a1*a152);
-  a161=(a139*a161);
-  a78=(a78+a161);
-  a106=(a106-a78);
-  a115=(a115+a106);
-  a115=(a0*a115);
-  if (res[0]!=0) res[0][70]=a115;
-  a132=(a1*a132);
-  a149=(a1*a149);
-  a127=(a127+a149);
-  a132=(a132-a127);
-  a127=(a10*a165);
-  a127=(a40*a127);
-  a149=(a10*a164);
-  a149=(a48*a149);
-  a127=(a127-a149);
-  a149=(a10*a152);
-  a149=(a53*a149);
-  a127=(a127-a149);
-  a149=(a128*a151);
-  a115=(a1*a148);
-  a115=(a139*a115);
-  a149=(a149+a115);
-  a127=(a127-a149);
-  a132=(a132+a127);
-  a132=(a0*a132);
-  a132=(a19+a132);
-  if (res[0]!=0) res[0][71]=a132;
-  a157=(a1*a157);
-  a157=(a157-a6);
-  a160=(a1*a160);
-  a157=(a157+a160);
-  a160=(a10*a152);
-  a160=(a48*a160);
-  a6=(a10*a148);
-  a6=(a40*a6);
-  a160=(a160-a6);
-  a6=(a10*a164);
-  a6=(a53*a6);
-  a160=(a160-a6);
-  a6=(a125*a151);
-  a132=(a1*a165);
-  a132=(a139*a132);
-  a6=(a6+a132);
-  a160=(a160-a6);
-  a157=(a157+a160);
-  a157=(a0*a157);
-  if (res[0]!=0) res[0][72]=a157;
-  a143=(a1*a143);
-  a155=(a155+a143);
-  a156=(a1*a156);
-  a155=(a155+a156);
-  a152=(a10*a152);
-  a152=(a40*a152);
-  a148=(a10*a148);
-  a148=(a48*a148);
-  a152=(a152+a148);
-  a165=(a10*a165);
-  a165=(a53*a165);
-  a152=(a152+a165);
-  a151=(a124*a151);
-  a164=(a1*a164);
-  a164=(a139*a164);
-  a151=(a151-a164);
-  a152=(a152+a151);
-  a155=(a155+a152);
-  a155=(a0*a155);
-  a155=(-a155);
-  if (res[0]!=0) res[0][73]=a155;
-  a155=(a1*a4);
-  a155=(a73*a155);
-  a155=(a3*a155);
-  a152=(a2*a155);
-  a152=(a1*a152);
-  a5=(a5+a5);
-  a151=(a25*a5);
-  a164=(a1*a18);
-  a151=(a151+a164);
-  a164=(a2*a151);
-  a164=(a19-a164);
-  a165=(a13*a164);
-  a148=(a10*a15);
-  a156=(a20*a5);
-  a148=(a148+a156);
-  a156=(a2*a148);
-  a143=(a22*a156);
-  a165=(a165-a143);
-  a143=(a10*a12);
-  a157=(a31*a5);
-  a143=(a143-a157);
-  a157=(a2*a143);
-  a160=(a33*a157);
-  a6=(a10*a17);
-  a5=(a36*a5);
-  a6=(a6+a5);
-  a5=(a2*a6);
-  a132=(a28*a5);
-  a160=(a160-a132);
-  a165=(a165+a160);
-  a165=(a1*a165);
-  a165=(a73*a165);
-  a165=(a3*a165);
-  a160=(a2*a165);
-  a160=(a1*a160);
-  a152=(a152+a160);
-  a160=(a10*a157);
-  a160=(a54*a160);
-  a132=(a10*a5);
-  a132=(a43*a132);
-  a127=(a10*a164);
-  a127=(a50*a127);
-  a132=(a132+a127);
-  a160=(a160-a132);
-  a132=(a147*a157);
-  a127=(a116*a156);
-  a132=(a132-a127);
-  a127=(a144*a164);
-  a132=(a132+a127);
-  a127=(a145*a5);
-  a132=(a132-a127);
-  a127=(a56*a132);
-  a149=(a1*a156);
-  a149=(a55*a149);
-  a127=(a127-a149);
-  a160=(a160-a127);
-  a127=(a2*a160);
-  a149=(a58*a127);
-  a115=(a10*a156);
-  a115=(a50*a115);
-  a106=(a10*a157);
-  a106=(a43*a106);
-  a115=(a115+a106);
-  a106=(a10*a5);
-  a106=(a54*a106);
-  a115=(a115+a106);
-  a106=(a61*a132);
-  a78=(a1*a164);
-  a78=(a55*a78);
-  a106=(a106+a78);
-  a115=(a115+a106);
-  a106=(a2*a115);
-  a106=(a19-a106);
-  a78=(a46*a106);
-  a149=(a149+a78);
-  a78=(a10*a164);
-  a78=(a43*a78);
-  a161=(a10*a5);
-  a161=(a50*a161);
-  a78=(a78-a161);
-  a161=(a10*a156);
-  a161=(a54*a161);
-  a78=(a78+a161);
-  a161=(a67*a132);
-  a162=(a1*a157);
-  a162=(a55*a162);
-  a161=(a161+a162);
-  a78=(a78-a161);
-  a161=(a2*a78);
-  a162=(a69*a161);
-  a117=(a10*a157);
-  a117=(a50*a117);
-  a150=(a10*a156);
-  a150=(a43*a150);
-  a117=(a117-a150);
-  a150=(a10*a164);
-  a150=(a54*a150);
-  a117=(a117+a150);
-  a132=(a72*a132);
-  a150=(a1*a5);
-  a150=(a55*a150);
-  a132=(a132-a150);
-  a117=(a117+a132);
-  a132=(a2*a117);
-  a150=(a64*a132);
-  a162=(a162-a150);
-  a149=(a149+a162);
-  a149=(a1*a149);
-  a149=(a73*a149);
-  a149=(a3*a149);
-  a162=(a37*a149);
-  a152=(a152+a162);
-  a152=(a0*a152);
-  if (res[0]!=0) res[0][74]=a152;
-  a152=(a1*a7);
-  a152=(a73*a152);
-  a152=(a3*a152);
-  a162=(a2*a152);
-  a162=(a1*a162);
-  a150=(a22*a157);
-  a164=(a28*a164);
-  a150=(a150+a164);
-  a164=(a33*a156);
-  a5=(a13*a5);
-  a164=(a164+a5);
-  a150=(a150+a164);
-  a150=(a1*a150);
-  a150=(a73*a150);
-  a150=(a3*a150);
-  a164=(a2*a150);
-  a164=(a1*a164);
-  a162=(a162+a164);
-  a164=(a58*a161);
-  a5=(a64*a106);
-  a164=(a164+a5);
-  a5=(a69*a127);
-  a133=(a46*a132);
-  a5=(a5-a133);
-  a164=(a164-a5);
-  a164=(a1*a164);
-  a164=(a73*a164);
-  a164=(a3*a164);
-  a5=(a37*a164);
-  a162=(a162+a5);
-  a162=(a0*a162);
-  if (res[0]!=0) res[0][75]=a162;
-  a157=(a159*a157);
-  a156=(a158*a156);
-  a157=(a157-a156);
-  a157=(a1*a157);
-  a157=(a73*a157);
-  a157=(a3*a157);
-  a156=(a2*a157);
-  a156=(a1*a156);
-  a162=(a108*a127);
-  a5=(a110*a161);
-  a162=(a162+a5);
-  a162=(a1*a162);
-  a162=(a73*a162);
-  a162=(a3*a162);
-  a5=(a37*a162);
-  a156=(a156+a5);
-  a156=(a0*a156);
-  a156=(-a156);
-  if (res[0]!=0) res[0][76]=a156;
-  a165=(a1*a165);
-  a155=(a155+a165);
-  a149=(a1*a149);
-  a155=(a155+a149);
-  a149=(a10*a161);
-  a149=(a85*a149);
-  a165=(a10*a132);
-  a165=(a76*a165);
-  a156=(a10*a106);
-  a156=(a83*a156);
-  a165=(a165+a156);
-  a149=(a149-a165);
-  a165=(a112*a127);
-  a156=(a118*a161);
-  a165=(a165+a156);
-  a156=(a119*a106);
-  a165=(a165+a156);
-  a156=(a120*a132);
-  a165=(a165-a156);
-  a156=(a87*a165);
-  a5=(a1*a127);
-  a5=(a86*a5);
-  a156=(a156+a5);
-  a149=(a149-a156);
-  a156=(a37*a149);
-  a5=(a89*a156);
-  a133=(a10*a127);
-  a133=(a83*a133);
-  a154=(a10*a161);
-  a154=(a76*a154);
-  a133=(a133-a154);
-  a154=(a10*a132);
-  a154=(a85*a154);
-  a133=(a133-a154);
-  a154=(a92*a165);
-  a153=(a1*a106);
-  a153=(a86*a153);
-  a154=(a154+a153);
-  a133=(a133-a154);
-  a154=(a37*a133);
-  a154=(a19+a154);
-  a153=(a80*a154);
-  a5=(a5+a153);
-  a153=(a10*a106);
-  a153=(a76*a153);
-  a113=(a10*a132);
-  a113=(a83*a113);
-  a153=(a153-a113);
-  a113=(a10*a127);
-  a113=(a85*a113);
-  a153=(a153-a113);
-  a113=(a98*a165);
-  a163=(a1*a161);
-  a163=(a86*a163);
-  a113=(a113+a163);
-  a153=(a153-a113);
-  a113=(a37*a153);
-  a163=(a100*a113);
-  a127=(a10*a127);
-  a127=(a76*a127);
-  a161=(a10*a161);
-  a161=(a83*a161);
-  a127=(a127+a161);
-  a106=(a10*a106);
-  a106=(a85*a106);
-  a127=(a127+a106);
-  a165=(a103*a165);
-  a132=(a1*a132);
-  a132=(a86*a132);
-  a165=(a165-a132);
-  a127=(a127+a165);
-  a165=(a37*a127);
-  a132=(a95*a165);
-  a163=(a163-a132);
-  a5=(a5+a163);
-  a5=(a1*a5);
-  a5=(a73*a5);
-  a5=(a3*a5);
-  a155=(a155+a5);
-  a155=(a0*a155);
-  if (res[0]!=0) res[0][77]=a155;
-  a150=(a1*a150);
-  a152=(a152+a150);
-  a164=(a1*a164);
-  a152=(a152+a164);
-  a164=(a89*a113);
-  a150=(a95*a154);
-  a164=(a164+a150);
-  a150=(a100*a156);
-  a155=(a80*a165);
-  a150=(a150-a155);
-  a164=(a164-a150);
-  a164=(a1*a164);
-  a164=(a73*a164);
-  a164=(a3*a164);
-  a152=(a152+a164);
-  a152=(a0*a152);
-  if (res[0]!=0) res[0][78]=a152;
-  a157=(a1*a157);
-  a162=(a1*a162);
-  a157=(a157+a162);
-  a162=(a105*a156);
-  a152=(a122*a113);
-  a162=(a162+a152);
-  a162=(a1*a162);
-  a162=(a73*a162);
-  a162=(a3*a162);
-  a157=(a157+a162);
-  a157=(a0*a157);
-  a157=(-a157);
-  if (res[0]!=0) res[0][79]=a157;
-  a160=(a1*a160);
-  a160=(a160-a148);
-  a149=(a1*a149);
-  a160=(a160+a149);
-  a149=(a10*a113);
-  a149=(a53*a149);
-  a148=(a10*a165);
-  a148=(a40*a148);
-  a157=(a10*a154);
-  a157=(a48*a157);
-  a148=(a148+a157);
-  a149=(a149-a148);
-  a148=(a114*a156);
-  a157=(a135*a113);
-  a148=(a148+a157);
-  a157=(a136*a154);
-  a148=(a148+a157);
-  a157=(a137*a165);
-  a148=(a148-a157);
-  a157=(a130*a148);
-  a162=(a1*a156);
-  a162=(a139*a162);
-  a157=(a157+a162);
-  a149=(a149-a157);
-  a160=(a160+a149);
-  a160=(a0*a160);
-  if (res[0]!=0) res[0][80]=a160;
-  a78=(a1*a78);
-  a143=(a143+a78);
-  a153=(a1*a153);
-  a143=(a143+a153);
-  a153=(a10*a154);
-  a153=(a40*a153);
-  a78=(a10*a165);
-  a78=(a48*a78);
-  a153=(a153-a78);
-  a78=(a10*a156);
-  a78=(a53*a78);
-  a153=(a153-a78);
-  a78=(a128*a148);
-  a160=(a1*a113);
-  a160=(a139*a160);
-  a78=(a78+a160);
-  a153=(a153-a78);
-  a143=(a143+a153);
-  a143=(a0*a143);
-  if (res[0]!=0) res[0][81]=a143;
-  a133=(a1*a133);
-  a115=(a1*a115);
-  a151=(a151+a115);
-  a133=(a133-a151);
-  a151=(a10*a156);
-  a151=(a48*a151);
-  a115=(a10*a113);
-  a115=(a40*a115);
-  a151=(a151-a115);
-  a115=(a10*a165);
-  a115=(a53*a115);
-  a151=(a151-a115);
-  a115=(a125*a148);
-  a143=(a1*a154);
-  a143=(a139*a143);
-  a115=(a115+a143);
-  a151=(a151-a115);
-  a133=(a133+a151);
-  a133=(a0*a133);
-  a133=(a19+a133);
-  if (res[0]!=0) res[0][82]=a133;
-  a117=(a1*a117);
-  a6=(a6+a117);
-  a127=(a1*a127);
-  a6=(a6+a127);
-  a156=(a10*a156);
-  a156=(a40*a156);
-  a113=(a10*a113);
-  a113=(a48*a113);
-  a156=(a156+a113);
-  a154=(a10*a154);
-  a154=(a53*a154);
-  a156=(a156+a154);
-  a148=(a124*a148);
-  a165=(a1*a165);
-  a165=(a139*a165);
-  a148=(a148-a165);
-  a156=(a156+a148);
-  a6=(a6+a156);
-  a6=(a0*a6);
-  a6=(-a6);
-  if (res[0]!=0) res[0][83]=a6;
-  a7=(a1*a7);
-  a7=(a73*a7);
-  a7=(a3*a7);
-  a6=(a2*a7);
-  a6=(a1*a6);
-  a156=(a10*a12);
-  a8=(a8+a8);
-  a20=(a20*a8);
-  a156=(a156-a20);
-  a20=(a2*a156);
-  a148=(a22*a20);
-  a165=(a10*a17);
-  a25=(a25*a8);
-  a165=(a165-a25);
-  a25=(a2*a165);
-  a154=(a13*a25);
-  a148=(a148+a154);
-  a154=(a10*a15);
-  a31=(a31*a8);
-  a154=(a154-a31);
-  a31=(a2*a154);
-  a113=(a33*a31);
-  a36=(a36*a8);
-  a18=(a1*a18);
-  a36=(a36+a18);
-  a18=(a2*a36);
-  a18=(a19-a18);
-  a8=(a28*a18);
-  a113=(a113+a8);
-  a148=(a148+a113);
-  a148=(a1*a148);
-  a148=(a73*a148);
-  a148=(a3*a148);
-  a113=(a2*a148);
-  a113=(a1*a113);
-  a6=(a6+a113);
-  a113=(a10*a18);
-  a113=(a43*a113);
-  a8=(a10*a25);
-  a8=(a50*a8);
-  a113=(a113-a8);
-  a8=(a10*a31);
-  a8=(a54*a8);
-  a113=(a113+a8);
-  a8=(a116*a20);
-  a127=(a147*a31);
-  a8=(a8+a127);
-  a127=(a144*a25);
-  a8=(a8+a127);
-  a127=(a145*a18);
-  a8=(a8+a127);
-  a127=(a56*a8);
-  a117=(a1*a20);
-  a117=(a55*a117);
-  a127=(a127+a117);
-  a113=(a113-a127);
-  a127=(a2*a113);
-  a117=(a58*a127);
-  a133=(a10*a20);
-  a133=(a50*a133);
-  a151=(a10*a31);
-  a151=(a43*a151);
-  a133=(a133-a151);
-  a151=(a10*a18);
-  a151=(a54*a151);
-  a133=(a133+a151);
-  a151=(a61*a8);
-  a115=(a1*a25);
-  a115=(a55*a115);
-  a151=(a151+a115);
-  a133=(a133-a151);
-  a151=(a2*a133);
-  a115=(a46*a151);
-  a117=(a117+a115);
-  a115=(a10*a25);
-  a115=(a43*a115);
-  a143=(a10*a18);
-  a143=(a50*a143);
-  a115=(a115+a143);
-  a143=(a10*a20);
-  a143=(a54*a143);
-  a115=(a115-a143);
-  a143=(a67*a8);
-  a153=(a1*a31);
-  a153=(a55*a153);
-  a143=(a143+a153);
-  a115=(a115-a143);
-  a143=(a2*a115);
-  a153=(a69*a143);
-  a78=(a10*a20);
-  a78=(a43*a78);
-  a160=(a10*a31);
-  a160=(a50*a160);
-  a78=(a78+a160);
-  a160=(a10*a25);
-  a160=(a54*a160);
-  a78=(a78+a160);
-  a8=(a72*a8);
-  a160=(a1*a18);
-  a160=(a55*a160);
-  a8=(a8+a160);
-  a78=(a78+a8);
-  a8=(a2*a78);
-  a8=(a19-a8);
-  a160=(a64*a8);
-  a153=(a153+a160);
-  a117=(a117+a153);
-  a117=(a1*a117);
-  a117=(a73*a117);
-  a117=(a3*a117);
-  a153=(a37*a117);
-  a6=(a6+a153);
-  a6=(a0*a6);
-  if (res[0]!=0) res[0][84]=a6;
-  a6=(a22*a31);
-  a25=(a28*a25);
-  a6=(a6+a25);
-  a25=(a33*a20);
-  a18=(a13*a18);
-  a25=(a25+a18);
-  a6=(a6-a25);
-  a6=(a1*a6);
-  a6=(a73*a6);
-  a6=(a3*a6);
-  a25=(a2*a6);
-  a25=(a1*a25);
-  a4=(a1*a4);
-  a4=(a73*a4);
-  a4=(a3*a4);
-  a18=(a2*a4);
-  a18=(a1*a18);
-  a25=(a25-a18);
-  a18=(a58*a143);
-  a153=(a64*a151);
-  a18=(a18+a153);
-  a153=(a69*a127);
-  a160=(a46*a8);
-  a153=(a153+a160);
-  a18=(a18-a153);
-  a18=(a1*a18);
-  a18=(a73*a18);
-  a18=(a3*a18);
-  a153=(a37*a18);
-  a25=(a25+a153);
-  a25=(a0*a25);
-  if (res[0]!=0) res[0][85]=a25;
-  a20=(a158*a20);
-  a31=(a159*a31);
-  a20=(a20+a31);
-  a20=(a1*a20);
-  a20=(a73*a20);
-  a20=(a3*a20);
-  a31=(a2*a20);
-  a31=(a1*a31);
-  a25=(a108*a127);
-  a153=(a110*a143);
-  a25=(a25+a153);
-  a25=(a1*a25);
-  a25=(a73*a25);
-  a25=(a3*a25);
-  a153=(a37*a25);
-  a31=(a31+a153);
-  a31=(a0*a31);
-  a31=(-a31);
-  if (res[0]!=0) res[0][86]=a31;
-  a148=(a1*a148);
-  a7=(a7+a148);
-  a117=(a1*a117);
-  a7=(a7+a117);
-  a117=(a10*a8);
-  a117=(a76*a117);
-  a148=(a10*a151);
-  a148=(a83*a148);
-  a117=(a117-a148);
-  a148=(a10*a143);
-  a148=(a85*a148);
-  a117=(a117+a148);
-  a148=(a112*a127);
-  a31=(a118*a143);
-  a148=(a148+a31);
-  a31=(a119*a151);
-  a148=(a148+a31);
-  a31=(a120*a8);
-  a148=(a148+a31);
-  a31=(a87*a148);
-  a153=(a1*a127);
-  a153=(a86*a153);
-  a31=(a31+a153);
-  a117=(a117-a31);
-  a31=(a37*a117);
-  a153=(a89*a31);
-  a160=(a10*a127);
-  a160=(a83*a160);
-  a149=(a10*a143);
-  a149=(a76*a149);
-  a160=(a160-a149);
-  a149=(a10*a8);
-  a149=(a85*a149);
-  a160=(a160+a149);
-  a149=(a92*a148);
-  a157=(a1*a151);
-  a157=(a86*a157);
-  a149=(a149+a157);
-  a160=(a160-a149);
-  a149=(a37*a160);
-  a157=(a80*a149);
-  a153=(a153+a157);
-  a157=(a10*a151);
-  a157=(a76*a157);
-  a162=(a10*a8);
-  a162=(a83*a162);
-  a157=(a157+a162);
-  a162=(a10*a127);
-  a162=(a85*a162);
-  a157=(a157-a162);
-  a162=(a98*a148);
-  a152=(a1*a143);
-  a152=(a86*a152);
-  a162=(a162+a152);
-  a157=(a157-a162);
-  a162=(a37*a157);
-  a152=(a100*a162);
-  a127=(a10*a127);
-  a127=(a76*a127);
-  a143=(a10*a143);
-  a143=(a83*a143);
-  a127=(a127+a143);
-  a151=(a10*a151);
-  a151=(a85*a151);
-  a127=(a127+a151);
-  a148=(a103*a148);
-  a8=(a1*a8);
-  a8=(a86*a8);
-  a148=(a148+a8);
-  a127=(a127+a148);
-  a148=(a37*a127);
-  a148=(a19-a148);
-  a8=(a95*a148);
-  a152=(a152+a8);
-  a153=(a153+a152);
-  a153=(a1*a153);
-  a153=(a73*a153);
-  a153=(a3*a153);
-  a7=(a7+a153);
-  a7=(a0*a7);
-  if (res[0]!=0) res[0][87]=a7;
-  a6=(a1*a6);
-  a6=(a6-a4);
-  a18=(a1*a18);
-  a6=(a6+a18);
-  a18=(a89*a162);
-  a4=(a95*a149);
-  a18=(a18+a4);
-  a4=(a100*a31);
-  a7=(a80*a148);
-  a4=(a4+a7);
-  a18=(a18-a4);
-  a18=(a1*a18);
-  a18=(a73*a18);
-  a18=(a3*a18);
-  a6=(a6+a18);
-  a6=(a0*a6);
-  if (res[0]!=0) res[0][88]=a6;
-  a20=(a1*a20);
-  a25=(a1*a25);
-  a20=(a20+a25);
-  a25=(a105*a31);
-  a6=(a122*a162);
-  a25=(a25+a6);
-  a25=(a1*a25);
-  a25=(a73*a25);
-  a25=(a3*a25);
-  a20=(a20+a25);
-  a20=(a0*a20);
-  a20=(-a20);
-  if (res[0]!=0) res[0][89]=a20;
-  a113=(a1*a113);
-  a156=(a156+a113);
-  a117=(a1*a117);
-  a156=(a156+a117);
-  a117=(a10*a148);
-  a117=(a40*a117);
-  a113=(a10*a149);
-  a113=(a48*a113);
-  a117=(a117-a113);
-  a113=(a10*a162);
-  a113=(a53*a113);
-  a117=(a117+a113);
-  a113=(a114*a31);
-  a20=(a135*a162);
-  a113=(a113+a20);
-  a20=(a136*a149);
-  a113=(a113+a20);
-  a20=(a137*a148);
-  a113=(a113+a20);
-  a20=(a130*a113);
-  a25=(a1*a31);
-  a25=(a139*a25);
-  a20=(a20+a25);
-  a117=(a117-a20);
-  a156=(a156+a117);
-  a156=(a0*a156);
-  if (res[0]!=0) res[0][90]=a156;
-  a115=(a1*a115);
-  a154=(a154+a115);
-  a157=(a1*a157);
-  a154=(a154+a157);
-  a157=(a10*a149);
-  a157=(a40*a157);
-  a115=(a10*a148);
-  a115=(a48*a115);
-  a157=(a157+a115);
-  a115=(a10*a31);
-  a115=(a53*a115);
-  a157=(a157-a115);
-  a115=(a128*a113);
-  a156=(a1*a162);
-  a156=(a139*a156);
-  a115=(a115+a156);
-  a157=(a157-a115);
-  a154=(a154+a157);
-  a154=(a0*a154);
-  if (res[0]!=0) res[0][91]=a154;
-  a133=(a1*a133);
-  a165=(a165+a133);
-  a160=(a1*a160);
-  a165=(a165+a160);
-  a160=(a10*a31);
-  a160=(a48*a160);
-  a133=(a10*a162);
-  a133=(a40*a133);
-  a160=(a160-a133);
-  a133=(a10*a148);
-  a133=(a53*a133);
-  a160=(a160+a133);
-  a133=(a125*a113);
-  a154=(a1*a149);
-  a154=(a139*a154);
-  a133=(a133+a154);
-  a160=(a160-a133);
-  a165=(a165+a160);
-  a165=(a0*a165);
-  if (res[0]!=0) res[0][92]=a165;
-  a78=(a1*a78);
-  a36=(a36+a78);
-  a127=(a1*a127);
-  a36=(a36+a127);
-  a31=(a10*a31);
-  a31=(a40*a31);
-  a162=(a10*a162);
-  a162=(a48*a162);
-  a31=(a31+a162);
-  a149=(a10*a149);
-  a149=(a53*a149);
-  a31=(a31+a149);
-  a113=(a124*a113);
-  a148=(a1*a148);
-  a148=(a139*a148);
-  a113=(a113+a148);
-  a31=(a31+a113);
-  a36=(a36+a31);
-  a36=(a0*a36);
-  a36=(a19-a36);
-  if (res[0]!=0) res[0][93]=a36;
-  a36=(a2*a11);
-  a31=(a22*a36);
-  a113=(a2*a23);
-  a148=(a13*a113);
-  a31=(a31-a148);
-  a148=(a2*a27);
-  a149=(a33*a148);
-  a162=(a2*a32);
-  a127=(a28*a162);
-  a149=(a149-a127);
-  a31=(a31+a149);
-  a31=(a1*a31);
-  a31=(a73*a31);
-  a31=(a3*a31);
-  a149=(a2*a31);
-  a149=(a1*a149);
-  a127=(a10*a162);
-  a127=(a43*a127);
-  a127=(a38-a127);
-  a78=(a10*a113);
-  a78=(a50*a78);
-  a165=(a44*a17);
-  a165=(a165-a42);
-  a165=(a39*a165);
-  a160=(a2*a165);
-  a133=(a47*a160);
-  a78=(a78+a133);
-  a127=(a127+a78);
-  a78=(a10*a148);
-  a78=(a54*a78);
-  a127=(a127+a78);
-  a78=(a116*a36);
-  a133=(a147*a148);
-  a78=(a78+a133);
-  a133=(a144*a113);
-  a78=(a78-a133);
-  a133=(a145*a162);
-  a78=(a78-a133);
-  a133=(a56*a78);
-  a154=(a1*a36);
-  a154=(a55*a154);
-  a133=(a133+a154);
-  a127=(a127-a133);
-  a133=(a2*a127);
-  a154=(a58*a133);
-  a157=(a10*a36);
-  a157=(a50*a157);
-  a115=(a57*a160);
-  a157=(a157-a115);
-  a115=(a10*a148);
-  a115=(a43*a115);
-  a115=(a115+a59);
-  a157=(a157-a115);
-  a115=(a10*a162);
-  a115=(a54*a115);
-  a157=(a157-a115);
-  a115=(a61*a78);
-  a156=(a1*a113);
-  a156=(a55*a156);
-  a115=(a115-a156);
-  a157=(a157-a115);
-  a115=(a2*a157);
-  a156=(a46*a115);
-  a154=(a154+a156);
-  a156=(a10*a113);
-  a156=(a43*a156);
-  a156=(a63-a156);
-  a117=(a10*a162);
-  a117=(a50*a117);
-  a20=(a65*a160);
-  a117=(a117+a20);
-  a156=(a156-a117);
-  a117=(a10*a36);
-  a117=(a54*a117);
-  a156=(a156-a117);
-  a117=(a67*a78);
-  a20=(a1*a148);
-  a20=(a55*a20);
-  a117=(a117+a20);
-  a156=(a156-a117);
-  a117=(a2*a156);
-  a20=(a69*a117);
-  a25=(a10*a36);
-  a25=(a43*a25);
-  a25=(a25+a68);
-  a6=(a10*a148);
-  a6=(a50*a6);
-  a18=(a70*a160);
-  a6=(a6-a18);
-  a25=(a25+a6);
-  a6=(a10*a113);
-  a6=(a54*a6);
-  a25=(a25-a6);
-  a78=(a72*a78);
-  a6=(a1*a162);
-  a6=(a55*a6);
-  a78=(a78-a6);
-  a25=(a25+a78);
-  a78=(a2*a25);
-  a6=(a64*a78);
-  a20=(a20-a6);
-  a154=(a154+a20);
-  a154=(a1*a154);
-  a154=(a73*a154);
-  a154=(a3*a154);
-  a20=(a37*a154);
-  a149=(a149+a20);
-  a149=(a0*a149);
-  if (res[0]!=0) res[0][94]=a149;
-  a149=(a22*a148);
-  a113=(a28*a113);
-  a149=(a149-a113);
-  a113=(a33*a36);
-  a162=(a13*a162);
-  a113=(a113-a162);
-  a149=(a149-a113);
-  a149=(a1*a149);
-  a149=(a73*a149);
-  a149=(a3*a149);
-  a113=(a2*a149);
-  a113=(a1*a113);
-  a162=(a58*a117);
-  a20=(a64*a115);
-  a162=(a162+a20);
-  a20=(a69*a133);
-  a6=(a46*a78);
-  a20=(a20-a6);
-  a162=(a162-a20);
-  a162=(a1*a162);
-  a162=(a73*a162);
-  a162=(a3*a162);
-  a20=(a37*a162);
-  a113=(a113+a20);
-  a113=(a0*a113);
-  if (res[0]!=0) res[0][95]=a113;
-  a36=(a158*a36);
-  a148=(a159*a148);
-  a36=(a36+a148);
-  a36=(a1*a36);
-  a36=(a73*a36);
-  a36=(a3*a36);
-  a148=(a2*a36);
-  a148=(a1*a148);
-  a113=(a108*a133);
-  a20=(a110*a117);
-  a113=(a113+a20);
-  a113=(a1*a113);
-  a113=(a73*a113);
-  a113=(a3*a113);
-  a20=(a37*a113);
-  a148=(a148+a20);
-  a148=(a0*a148);
-  a148=(-a148);
-  if (res[0]!=0) res[0][96]=a148;
-  a31=(a1*a31);
-  a154=(a1*a154);
-  a31=(a31+a154);
-  a154=(a44*a160);
-  a148=(a54*a154);
-  a20=(a26*a160);
-  a148=(a148-a20);
-  a148=(a39*a148);
-  a20=(a2*a148);
-  a20=(a19-a20);
-  a6=(a62*a20);
-  a18=(a10*a78);
-  a18=(a76*a18);
-  a6=(a6-a18);
-  a18=(a10*a115);
-  a18=(a83*a18);
-  a4=(a44*a54);
-  a4=(a4-a26);
-  a4=(a39*a4);
-  a7=(a2*a4);
-  a153=(a81*a7);
-  a18=(a18-a153);
-  a6=(a6-a18);
-  a18=(a10*a117);
-  a18=(a85*a18);
-  a154=(a43*a154);
-  a154=(a79-a154);
-  a153=(a44*a50);
-  a160=(a82*a160);
-  a153=(a153-a160);
-  a154=(a154-a153);
-  a154=(a52*a154);
-  a153=(a2*a154);
-  a160=(a84*a153);
-  a18=(a18-a160);
-  a6=(a6+a18);
-  a18=(a112*a133);
-  a160=(a118*a117);
-  a18=(a18+a160);
-  a160=(a119*a115);
-  a18=(a18+a160);
-  a160=(a120*a78);
-  a18=(a18-a160);
-  a160=(a87*a18);
-  a152=(a1*a133);
-  a152=(a86*a152);
-  a160=(a160+a152);
-  a6=(a6-a160);
-  a160=(a37*a6);
-  a152=(a89*a160);
-  a8=(a10*a133);
-  a8=(a83*a8);
-  a151=(a88*a7);
-  a8=(a8-a151);
-  a151=(a10*a117);
-  a151=(a76*a151);
-  a143=(a90*a20);
-  a151=(a151+a143);
-  a8=(a8-a151);
-  a151=(a10*a78);
-  a151=(a85*a151);
-  a143=(a91*a153);
-  a151=(a151+a143);
-  a8=(a8-a151);
-  a151=(a92*a18);
-  a143=(a1*a115);
-  a143=(a86*a143);
-  a151=(a151+a143);
-  a8=(a8-a151);
-  a151=(a37*a8);
-  a143=(a80*a151);
-  a152=(a152+a143);
-  a143=(a10*a115);
-  a143=(a76*a143);
-  a164=(a94*a20);
-  a143=(a143+a164);
-  a164=(a10*a78);
-  a164=(a83*a164);
-  a150=(a96*a7);
-  a164=(a164+a150);
-  a143=(a143-a164);
-  a164=(a10*a133);
-  a164=(a85*a164);
-  a150=(a97*a153);
-  a164=(a164-a150);
-  a143=(a143-a164);
-  a164=(a98*a18);
-  a150=(a1*a117);
-  a150=(a86*a150);
-  a164=(a164+a150);
-  a143=(a143-a164);
-  a164=(a37*a143);
-  a150=(a100*a164);
-  a133=(a10*a133);
-  a133=(a76*a133);
-  a155=(a99*a20);
-  a133=(a133+a155);
-  a117=(a10*a117);
-  a117=(a83*a117);
-  a155=(a101*a7);
-  a117=(a117-a155);
-  a133=(a133+a117);
-  a115=(a10*a115);
-  a115=(a85*a115);
-  a117=(a102*a153);
-  a115=(a115-a117);
-  a133=(a133+a115);
-  a18=(a103*a18);
-  a78=(a1*a78);
-  a78=(a86*a78);
-  a18=(a18-a78);
-  a133=(a133+a18);
-  a18=(a37*a133);
-  a78=(a95*a18);
-  a150=(a150-a78);
-  a152=(a152+a150);
-  a152=(a1*a152);
-  a152=(a73*a152);
-  a152=(a3*a152);
-  a31=(a31+a152);
-  a31=(a0*a31);
-  if (res[0]!=0) res[0][97]=a31;
-  a149=(a1*a149);
-  a162=(a1*a162);
-  a149=(a149+a162);
-  a162=(a89*a164);
-  a31=(a95*a151);
-  a162=(a162+a31);
-  a31=(a100*a160);
-  a152=(a80*a18);
-  a31=(a31-a152);
-  a162=(a162-a31);
-  a162=(a1*a162);
-  a162=(a73*a162);
-  a162=(a3*a162);
-  a149=(a149+a162);
-  a149=(a0*a149);
-  if (res[0]!=0) res[0][98]=a149;
-  a36=(a1*a36);
-  a113=(a1*a113);
-  a36=(a36+a113);
-  a113=(a105*a160);
-  a149=(a122*a164);
-  a113=(a113+a149);
-  a113=(a1*a113);
-  a113=(a73*a113);
-  a113=(a3*a113);
-  a36=(a36+a113);
-  a36=(a0*a36);
-  a36=(-a36);
-  if (res[0]!=0) res[0][99]=a36;
-  a127=(a1*a127);
-  a11=(a11+a127);
-  a6=(a1*a6);
-  a11=(a11+a6);
-  a6=(a109*a153);
-  a127=(a44*a7);
-  a36=(a85*a127);
-  a6=(a6+a36);
-  a36=(a107*a7);
-  a113=(a41*a153);
-  a149=(a83*a113);
-  a36=(a36+a149);
-  a6=(a6-a36);
-  a6=(a39*a6);
-  a36=(a37*a6);
-  a36=(a19-a36);
-  a149=(a111*a36);
-  a162=(a10*a18);
-  a162=(a40*a162);
-  a149=(a149-a162);
-  a162=(a10*a151);
-  a162=(a48*a162);
-  a31=(a44*a20);
-  a152=(a85*a31);
-  a153=(a129*a153);
-  a152=(a152-a153);
-  a153=(a107*a20);
-  a113=(a76*a113);
-  a153=(a153-a113);
-  a152=(a152-a153);
-  a152=(a39*a152);
-  a153=(a37*a152);
-  a113=(a131*a153);
-  a162=(a162-a113);
-  a149=(a149-a162);
-  a162=(a10*a164);
-  a162=(a53*a162);
-  a20=(a109*a20);
-  a127=(a76*a127);
-  a20=(a20-a127);
-  a31=(a83*a31);
-  a7=(a129*a7);
-  a31=(a31-a7);
-  a20=(a20-a31);
-  a20=(a52*a20);
-  a31=(a37*a20);
-  a7=(a104*a31);
-  a162=(a162-a7);
-  a149=(a149+a162);
-  a162=(a114*a160);
-  a7=(a135*a164);
-  a162=(a162+a7);
-  a7=(a136*a151);
-  a162=(a162+a7);
-  a7=(a137*a18);
-  a162=(a162-a7);
-  a7=(a130*a162);
-  a127=(a1*a160);
-  a127=(a139*a127);
-  a7=(a7+a127);
-  a149=(a149-a7);
-  a11=(a11+a149);
-  a11=(a0*a11);
-  if (res[0]!=0) res[0][100]=a11;
-  a156=(a1*a156);
-  a27=(a27+a156);
-  a143=(a1*a143);
-  a27=(a27+a143);
-  a143=(a10*a151);
-  a143=(a40*a143);
-  a156=(a77*a36);
-  a143=(a143+a156);
-  a156=(a10*a18);
-  a156=(a48*a156);
-  a11=(a138*a153);
-  a156=(a156+a11);
-  a143=(a143-a156);
-  a156=(a10*a160);
-  a156=(a53*a156);
-  a11=(a140*a31);
-  a156=(a156-a11);
-  a143=(a143-a156);
-  a156=(a128*a162);
-  a11=(a1*a164);
-  a11=(a139*a11);
-  a156=(a156+a11);
-  a143=(a143-a156);
-  a27=(a27+a143);
-  a27=(a0*a27);
-  if (res[0]!=0) res[0][101]=a27;
-  a157=(a1*a157);
-  a157=(a157-a23);
-  a8=(a1*a8);
-  a157=(a157+a8);
-  a8=(a10*a160);
-  a8=(a48*a8);
-  a23=(a93*a153);
-  a8=(a8-a23);
-  a23=(a10*a164);
-  a23=(a40*a23);
-  a27=(a141*a36);
-  a23=(a23+a27);
-  a8=(a8-a23);
-  a23=(a10*a18);
-  a23=(a53*a23);
-  a27=(a142*a31);
-  a23=(a23+a27);
-  a8=(a8-a23);
-  a23=(a125*a162);
-  a27=(a1*a151);
-  a27=(a139*a27);
-  a23=(a23+a27);
-  a8=(a8-a23);
-  a157=(a157+a8);
-  a157=(a0*a157);
-  if (res[0]!=0) res[0][102]=a157;
-  a25=(a1*a25);
-  a32=(a32+a25);
-  a133=(a1*a133);
-  a32=(a32+a133);
-  a160=(a10*a160);
-  a160=(a40*a160);
-  a133=(a9*a36);
-  a160=(a160+a133);
-  a164=(a10*a164);
-  a164=(a48*a164);
-  a133=(a123*a153);
-  a164=(a164-a133);
-  a160=(a160+a164);
-  a151=(a10*a151);
-  a151=(a53*a151);
-  a164=(a126*a31);
-  a151=(a151-a164);
-  a160=(a160+a151);
-  a162=(a124*a162);
-  a18=(a1*a18);
-  a18=(a139*a18);
-  a162=(a162-a18);
-  a160=(a160+a162);
-  a32=(a32+a160);
-  a32=(a0*a32);
-  a32=(-a32);
-  if (res[0]!=0) res[0][103]=a32;
-  a148=(a1*a148);
-  a6=(a1*a6);
-  a148=(a148+a6);
-  a6=(a121*a31);
-  a32=(a44*a153);
-  a160=(a53*a32);
-  a6=(a6+a160);
-  a160=(a74*a153);
-  a162=(a41*a31);
-  a18=(a48*a162);
-  a160=(a160+a18);
-  a6=(a6-a160);
-  a6=(a39*a6);
-  a148=(a148+a6);
-  a148=(a0*a148);
-  a148=(a19-a148);
-  if (res[0]!=0) res[0][104]=a148;
-  a4=(a1*a4);
-  a165=(a165+a4);
-  a152=(a1*a152);
-  a165=(a165+a152);
-  a152=(a44*a36);
-  a4=(a53*a152);
-  a31=(a134*a31);
-  a4=(a4-a31);
-  a31=(a74*a36);
-  a162=(a40*a162);
-  a31=(a31-a162);
-  a4=(a4-a31);
-  a4=(a39*a4);
-  a165=(a165+a4);
-  a165=(a0*a165);
-  a165=(-a165);
-  if (res[0]!=0) res[0][105]=a165;
-  a154=(a1*a154);
-  a20=(a1*a20);
-  a154=(a154+a20);
-  a36=(a121*a36);
-  a32=(a40*a32);
-  a36=(a36-a32);
-  a152=(a48*a152);
-  a153=(a134*a153);
-  a152=(a152-a153);
-  a36=(a36-a152);
-  a36=(a52*a36);
-  a154=(a154+a36);
-  a154=(a0*a154);
-  a154=(-a154);
-  if (res[0]!=0) res[0][106]=a154;
-  a154=(a2*a21);
-  a36=(a13*a154);
-  a152=(a2*a14);
-  a153=(a22*a152);
-  a36=(a36-a153);
-  a153=(a2*a29);
-  a32=(a33*a153);
-  a20=(a2*a34);
-  a165=(a28*a20);
-  a32=(a32-a165);
-  a36=(a36+a32);
-  a36=(a1*a36);
-  a36=(a73*a36);
-  a36=(a3*a36);
-  a32=(a2*a36);
-  a32=(a1*a32);
-  a165=(a10*a153);
-  a165=(a54*a165);
-  a4=(a10*a20);
-  a4=(a43*a4);
-  a17=(a44*a17);
-  a42=(a42-a17);
-  a42=(a39*a42);
-  a17=(a2*a42);
-  a31=(a38*a17);
-  a4=(a4+a31);
-  a31=(a10*a154);
-  a31=(a50*a31);
-  a31=(a31+a47);
-  a4=(a4+a31);
-  a165=(a165-a4);
-  a4=(a147*a153);
-  a31=(a116*a152);
-  a4=(a4-a31);
-  a31=(a144*a154);
-  a4=(a4+a31);
-  a31=(a145*a20);
-  a4=(a4-a31);
-  a31=(a56*a4);
-  a162=(a1*a152);
-  a162=(a55*a162);
-  a31=(a31-a162);
-  a165=(a165-a31);
-  a31=(a2*a165);
-  a162=(a58*a31);
-  a148=(a10*a152);
-  a148=(a50*a148);
-  a148=(a57-a148);
-  a6=(a10*a153);
-  a6=(a43*a6);
-  a160=(a59*a17);
-  a6=(a6-a160);
-  a148=(a148-a6);
-  a6=(a10*a20);
-  a6=(a54*a6);
-  a148=(a148-a6);
-  a6=(a61*a4);
-  a160=(a1*a154);
-  a160=(a55*a160);
-  a6=(a6+a160);
-  a148=(a148-a6);
-  a6=(a2*a148);
-  a160=(a46*a6);
-  a162=(a162+a160);
-  a160=(a10*a154);
-  a160=(a43*a160);
-  a18=(a63*a17);
-  a160=(a160-a18);
-  a18=(a10*a20);
-  a18=(a50*a18);
-  a18=(a65-a18);
-  a160=(a160+a18);
-  a18=(a10*a152);
-  a18=(a54*a18);
-  a160=(a160+a18);
-  a18=(a67*a4);
-  a151=(a1*a153);
-  a151=(a55*a151);
-  a18=(a18+a151);
-  a160=(a160-a18);
-  a18=(a2*a160);
-  a151=(a69*a18);
-  a164=(a10*a153);
-  a164=(a50*a164);
-  a164=(a164+a70);
-  a133=(a10*a152);
-  a133=(a43*a133);
-  a25=(a68*a17);
-  a133=(a133+a25);
-  a164=(a164-a133);
-  a133=(a10*a154);
-  a133=(a54*a133);
-  a164=(a164+a133);
-  a4=(a72*a4);
-  a133=(a1*a20);
-  a133=(a55*a133);
-  a4=(a4-a133);
-  a164=(a164+a4);
-  a4=(a2*a164);
-  a133=(a64*a4);
-  a151=(a151-a133);
-  a162=(a162+a151);
-  a162=(a1*a162);
-  a162=(a73*a162);
-  a162=(a3*a162);
-  a151=(a37*a162);
-  a32=(a32+a151);
-  a32=(a0*a32);
-  if (res[0]!=0) res[0][107]=a32;
-  a32=(a22*a153);
-  a154=(a28*a154);
-  a32=(a32+a154);
-  a154=(a33*a152);
-  a20=(a13*a20);
-  a154=(a154+a20);
-  a32=(a32+a154);
-  a32=(a1*a32);
-  a32=(a73*a32);
-  a32=(a3*a32);
-  a154=(a2*a32);
-  a154=(a1*a154);
-  a20=(a58*a18);
-  a151=(a64*a6);
-  a20=(a20+a151);
-  a151=(a69*a31);
-  a133=(a46*a4);
-  a151=(a151-a133);
-  a20=(a20-a151);
-  a20=(a1*a20);
-  a20=(a73*a20);
-  a20=(a3*a20);
-  a151=(a37*a20);
-  a154=(a154+a151);
-  a154=(a0*a154);
-  if (res[0]!=0) res[0][108]=a154;
-  a153=(a159*a153);
-  a152=(a158*a152);
-  a153=(a153-a152);
-  a153=(a1*a153);
-  a153=(a73*a153);
-  a153=(a3*a153);
-  a152=(a2*a153);
-  a152=(a1*a152);
-  a154=(a108*a31);
-  a151=(a110*a18);
-  a154=(a154+a151);
-  a154=(a1*a154);
-  a154=(a73*a154);
-  a154=(a3*a154);
-  a151=(a37*a154);
-  a152=(a152+a151);
-  a152=(a0*a152);
-  a152=(-a152);
-  if (res[0]!=0) res[0][109]=a152;
-  a36=(a1*a36);
-  a162=(a1*a162);
-  a36=(a36+a162);
-  a162=(a10*a18);
-  a162=(a85*a162);
-  a152=(a44*a43);
-  a151=(a79*a17);
-  a152=(a152-a151);
-  a151=(a44*a17);
-  a133=(a50*a151);
-  a133=(a82-a133);
-  a152=(a152-a133);
-  a152=(a52*a152);
-  a133=(a2*a152);
-  a25=(a84*a133);
-  a162=(a162-a25);
-  a25=(a10*a4);
-  a25=(a76*a25);
-  a157=(a44*a54);
-  a157=(a26-a157);
-  a157=(a39*a157);
-  a8=(a2*a157);
-  a23=(a62*a8);
-  a25=(a25+a23);
-  a23=(a10*a6);
-  a23=(a83*a23);
-  a17=(a26*a17);
-  a151=(a54*a151);
-  a17=(a17-a151);
-  a17=(a39*a17);
-  a151=(a2*a17);
-  a151=(a19-a151);
-  a27=(a81*a151);
-  a23=(a23+a27);
-  a25=(a25+a23);
-  a162=(a162-a25);
-  a25=(a112*a31);
-  a23=(a118*a18);
-  a25=(a25+a23);
-  a23=(a119*a6);
-  a25=(a25+a23);
-  a23=(a120*a4);
-  a25=(a25-a23);
-  a23=(a87*a25);
-  a27=(a1*a31);
-  a27=(a86*a27);
-  a23=(a23+a27);
-  a162=(a162-a23);
-  a23=(a37*a162);
-  a27=(a89*a23);
-  a143=(a10*a31);
-  a143=(a83*a143);
-  a156=(a88*a151);
-  a143=(a143+a156);
-  a156=(a10*a18);
-  a156=(a76*a156);
-  a11=(a90*a8);
-  a156=(a156-a11);
-  a143=(a143-a156);
-  a156=(a10*a4);
-  a156=(a85*a156);
-  a11=(a91*a133);
-  a156=(a156+a11);
-  a143=(a143-a156);
-  a156=(a92*a25);
-  a11=(a1*a6);
-  a11=(a86*a11);
-  a156=(a156+a11);
-  a143=(a143-a156);
-  a156=(a37*a143);
-  a11=(a80*a156);
-  a27=(a27+a11);
-  a11=(a10*a6);
-  a11=(a76*a11);
-  a149=(a94*a8);
-  a11=(a11-a149);
-  a149=(a96*a151);
-  a7=(a10*a4);
-  a7=(a83*a7);
-  a149=(a149-a7);
-  a11=(a11+a149);
-  a149=(a10*a31);
-  a149=(a85*a149);
-  a7=(a97*a133);
-  a149=(a149-a7);
-  a11=(a11-a149);
-  a149=(a98*a25);
-  a7=(a1*a18);
-  a7=(a86*a7);
-  a149=(a149+a7);
-  a11=(a11-a149);
-  a149=(a37*a11);
-  a7=(a100*a149);
-  a31=(a10*a31);
-  a31=(a76*a31);
-  a127=(a99*a8);
-  a31=(a31-a127);
-  a18=(a10*a18);
-  a18=(a83*a18);
-  a127=(a101*a151);
-  a18=(a18+a127);
-  a31=(a31+a18);
-  a6=(a10*a6);
-  a6=(a85*a6);
-  a18=(a102*a133);
-  a6=(a6-a18);
-  a31=(a31+a6);
-  a25=(a103*a25);
-  a4=(a1*a4);
-  a4=(a86*a4);
-  a25=(a25-a4);
-  a31=(a31+a25);
-  a25=(a37*a31);
-  a4=(a95*a25);
-  a7=(a7-a4);
-  a27=(a27+a7);
-  a27=(a1*a27);
-  a27=(a73*a27);
-  a27=(a3*a27);
-  a36=(a36+a27);
-  a36=(a0*a36);
-  if (res[0]!=0) res[0][110]=a36;
-  a32=(a1*a32);
-  a20=(a1*a20);
-  a32=(a32+a20);
-  a20=(a89*a149);
-  a36=(a95*a156);
-  a20=(a20+a36);
-  a36=(a100*a23);
-  a27=(a80*a25);
-  a36=(a36-a27);
-  a20=(a20-a36);
-  a20=(a1*a20);
-  a20=(a73*a20);
-  a20=(a3*a20);
-  a32=(a32+a20);
-  a32=(a0*a32);
-  if (res[0]!=0) res[0][111]=a32;
-  a153=(a1*a153);
-  a154=(a1*a154);
-  a153=(a153+a154);
-  a154=(a105*a23);
-  a32=(a122*a149);
-  a154=(a154+a32);
-  a154=(a1*a154);
-  a154=(a73*a154);
-  a154=(a3*a154);
-  a153=(a153+a154);
-  a153=(a0*a153);
-  a153=(-a153);
-  if (res[0]!=0) res[0][112]=a153;
-  a165=(a1*a165);
-  a165=(a165-a14);
-  a162=(a1*a162);
-  a165=(a165+a162);
-  a162=(a10*a149);
-  a162=(a53*a162);
-  a14=(a44*a151);
-  a153=(a76*a14);
-  a154=(a109*a8);
-  a153=(a153-a154);
-  a154=(a129*a151);
-  a32=(a44*a8);
-  a20=(a83*a32);
-  a154=(a154-a20);
-  a153=(a153-a154);
-  a153=(a52*a153);
-  a154=(a37*a153);
-  a20=(a104*a154);
-  a162=(a162-a20);
-  a20=(a10*a25);
-  a20=(a40*a20);
-  a151=(a107*a151);
-  a36=(a41*a133);
-  a27=(a83*a36);
-  a151=(a151-a27);
-  a14=(a85*a14);
-  a27=(a109*a133);
-  a14=(a14-a27);
-  a151=(a151-a14);
-  a151=(a39*a151);
-  a14=(a37*a151);
-  a27=(a111*a14);
-  a20=(a20+a27);
-  a27=(a10*a156);
-  a27=(a48*a27);
-  a8=(a107*a8);
-  a36=(a76*a36);
-  a8=(a8+a36);
-  a133=(a129*a133);
-  a32=(a85*a32);
-  a133=(a133+a32);
-  a8=(a8-a133);
-  a8=(a39*a8);
-  a133=(a37*a8);
-  a133=(a19-a133);
-  a32=(a131*a133);
-  a27=(a27+a32);
-  a20=(a20+a27);
-  a162=(a162-a20);
-  a20=(a114*a23);
-  a27=(a135*a149);
-  a20=(a20+a27);
-  a27=(a136*a156);
-  a20=(a20+a27);
-  a27=(a137*a25);
-  a20=(a20-a27);
-  a27=(a130*a20);
-  a32=(a1*a23);
-  a32=(a139*a32);
-  a27=(a27+a32);
-  a162=(a162-a27);
-  a165=(a165+a162);
-  a165=(a0*a165);
-  if (res[0]!=0) res[0][113]=a165;
-  a160=(a1*a160);
-  a29=(a29+a160);
-  a11=(a1*a11);
-  a29=(a29+a11);
-  a11=(a10*a156);
-  a11=(a40*a11);
-  a160=(a77*a14);
-  a11=(a11-a160);
-  a160=(a138*a133);
-  a165=(a10*a25);
-  a165=(a48*a165);
-  a160=(a160-a165);
-  a11=(a11+a160);
-  a160=(a10*a23);
-  a160=(a53*a160);
-  a165=(a140*a154);
-  a160=(a160-a165);
-  a11=(a11-a160);
-  a160=(a128*a20);
-  a165=(a1*a149);
-  a165=(a139*a165);
-  a160=(a160+a165);
-  a11=(a11-a160);
-  a29=(a29+a11);
-  a29=(a0*a29);
-  if (res[0]!=0) res[0][114]=a29;
-  a148=(a1*a148);
-  a21=(a21+a148);
-  a143=(a1*a143);
-  a21=(a21+a143);
-  a143=(a10*a23);
-  a143=(a48*a143);
-  a148=(a93*a133);
-  a143=(a143+a148);
-  a148=(a10*a149);
-  a148=(a40*a148);
-  a29=(a141*a14);
-  a148=(a148-a29);
-  a143=(a143-a148);
-  a148=(a10*a25);
-  a148=(a53*a148);
-  a29=(a142*a154);
-  a148=(a148+a29);
-  a143=(a143-a148);
-  a148=(a125*a20);
-  a29=(a1*a156);
-  a29=(a139*a29);
-  a148=(a148+a29);
-  a143=(a143-a148);
-  a21=(a21+a143);
-  a21=(a0*a21);
-  if (res[0]!=0) res[0][115]=a21;
-  a164=(a1*a164);
-  a34=(a34+a164);
-  a31=(a1*a31);
-  a34=(a34+a31);
-  a23=(a10*a23);
-  a23=(a40*a23);
-  a31=(a9*a14);
-  a23=(a23-a31);
-  a149=(a10*a149);
-  a149=(a48*a149);
-  a31=(a123*a133);
-  a149=(a149+a31);
-  a23=(a23+a149);
-  a156=(a10*a156);
-  a156=(a53*a156);
-  a149=(a126*a154);
-  a156=(a156-a149);
-  a23=(a23+a156);
-  a20=(a124*a20);
-  a25=(a1*a25);
-  a25=(a139*a25);
-  a20=(a20-a25);
-  a23=(a23+a20);
-  a34=(a34+a23);
-  a34=(a0*a34);
-  a34=(-a34);
-  if (res[0]!=0) res[0][116]=a34;
-  a157=(a1*a157);
-  a42=(a42+a157);
-  a151=(a1*a151);
-  a42=(a42+a151);
-  a151=(a74*a133);
-  a157=(a41*a154);
-  a34=(a48*a157);
-  a151=(a151-a34);
-  a34=(a44*a133);
-  a23=(a53*a34);
-  a20=(a121*a154);
-  a23=(a23-a20);
-  a151=(a151-a23);
-  a151=(a39*a151);
-  a42=(a42+a151);
-  a42=(a0*a42);
-  a42=(-a42);
-  if (res[0]!=0) res[0][117]=a42;
-  a17=(a1*a17);
-  a8=(a1*a8);
-  a17=(a17+a8);
-  a8=(a74*a14);
-  a157=(a40*a157);
-  a8=(a8+a157);
-  a154=(a134*a154);
-  a157=(a44*a14);
-  a42=(a53*a157);
-  a154=(a154+a42);
-  a8=(a8-a154);
-  a8=(a39*a8);
-  a17=(a17+a8);
-  a17=(a0*a17);
-  a17=(a19-a17);
-  if (res[0]!=0) res[0][118]=a17;
-  a152=(a1*a152);
-  a153=(a1*a153);
-  a152=(a152+a153);
-  a34=(a40*a34);
-  a14=(a121*a14);
-  a34=(a34-a14);
-  a133=(a134*a133);
-  a157=(a48*a157);
-  a133=(a133-a157);
-  a34=(a34-a133);
-  a34=(a52*a34);
-  a152=(a152+a34);
-  a152=(a0*a152);
-  a152=(-a152);
-  if (res[0]!=0) res[0][119]=a152;
-  a152=(a2*a16);
-  a34=(a22*a152);
-  a133=(a2*a24);
-  a157=(a13*a133);
-  a34=(a34+a157);
-  a157=(a2*a30);
-  a14=(a33*a157);
-  a153=(a2*a35);
-  a17=(a28*a153);
-  a14=(a14+a17);
-  a34=(a34-a14);
-  a34=(a1*a34);
-  a34=(a73*a34);
-  a34=(a3*a34);
-  a14=(a2*a34);
-  a14=(a1*a14);
-  a17=(a10*a157);
-  a17=(a54*a17);
-  a51=(a51-a17);
-  a17=(a10*a153);
-  a17=(a43*a17);
-  a15=(a41*a15);
-  a15=(a15-a45);
-  a15=(a39*a15);
-  a45=(a2*a15);
-  a38=(a38*a45);
-  a17=(a17+a38);
-  a38=(a10*a133);
-  a38=(a50*a38);
-  a12=(a41*a12);
-  a49=(a49-a12);
-  a49=(a39*a49);
-  a12=(a2*a49);
-  a47=(a47*a12);
-  a38=(a38-a47);
-  a17=(a17+a38);
-  a51=(a51-a17);
-  a116=(a116*a152);
-  a147=(a147*a157);
-  a116=(a116-a147);
-  a144=(a144*a133);
-  a116=(a116+a144);
-  a145=(a145*a153);
-  a116=(a116-a145);
-  a56=(a56*a116);
-  a145=(a1*a152);
-  a145=(a55*a145);
-  a56=(a56+a145);
-  a51=(a51-a56);
-  a56=(a2*a51);
-  a145=(a58*a56);
-  a144=(a10*a152);
-  a144=(a50*a144);
-  a57=(a57*a12);
-  a144=(a144-a57);
-  a57=(a10*a157);
-  a57=(a43*a57);
-  a59=(a59*a45);
-  a57=(a57+a59);
-  a144=(a144+a57);
-  a57=(a10*a153);
-  a57=(a54*a57);
-  a60=(a60-a57);
-  a144=(a144+a60);
-  a61=(a61*a116);
-  a60=(a1*a133);
-  a60=(a55*a60);
-  a61=(a61+a60);
-  a144=(a144-a61);
-  a61=(a2*a144);
-  a60=(a46*a61);
-  a145=(a145+a60);
-  a60=(a10*a133);
-  a60=(a43*a60);
-  a63=(a63*a45);
-  a60=(a60-a63);
-  a63=(a10*a153);
-  a63=(a50*a63);
-  a65=(a65*a12);
-  a63=(a63+a65);
-  a60=(a60-a63);
-  a63=(a10*a152);
-  a63=(a54*a63);
-  a63=(a63+a66);
-  a60=(a60-a63);
-  a67=(a67*a116);
-  a63=(a1*a157);
-  a63=(a55*a63);
-  a67=(a67-a63);
-  a60=(a60-a67);
-  a67=(a2*a60);
-  a63=(a69*a67);
-  a66=(a10*a152);
-  a66=(a43*a66);
-  a68=(a68*a45);
-  a66=(a66-a68);
-  a68=(a10*a157);
-  a68=(a50*a68);
-  a70=(a70*a12);
-  a68=(a68+a70);
-  a66=(a66-a68);
-  a68=(a10*a133);
-  a68=(a54*a68);
-  a68=(a68+a71);
-  a66=(a66+a68);
-  a72=(a72*a116);
-  a116=(a1*a153);
-  a55=(a55*a116);
-  a72=(a72-a55);
-  a66=(a66+a72);
-  a72=(a2*a66);
-  a55=(a64*a72);
-  a63=(a63-a55);
-  a145=(a145+a63);
-  a145=(a1*a145);
-  a145=(a73*a145);
-  a145=(a3*a145);
-  a63=(a37*a145);
-  a14=(a14+a63);
-  a14=(a0*a14);
-  if (res[0]!=0) res[0][120]=a14;
-  a28=(a28*a133);
-  a22=(a22*a157);
-  a28=(a28-a22);
-  a33=(a33*a152);
-  a13=(a13*a153);
-  a33=(a33-a13);
-  a28=(a28-a33);
-  a28=(a1*a28);
-  a28=(a73*a28);
-  a28=(a3*a28);
-  a33=(a2*a28);
-  a33=(a1*a33);
-  a58=(a58*a67);
-  a64=(a64*a61);
-  a58=(a58+a64);
-  a69=(a69*a56);
-  a46=(a46*a72);
-  a69=(a69-a46);
-  a58=(a58-a69);
-  a58=(a1*a58);
-  a58=(a73*a58);
-  a58=(a3*a58);
-  a69=(a37*a58);
-  a33=(a33+a69);
-  a33=(a0*a33);
-  if (res[0]!=0) res[0][121]=a33;
-  a158=(a158*a152);
-  a159=(a159*a157);
-  a158=(a158-a159);
-  a158=(a1*a158);
-  a158=(a73*a158);
-  a158=(a3*a158);
-  a159=(a2*a158);
-  a159=(a1*a159);
-  a108=(a108*a56);
-  a110=(a110*a67);
-  a108=(a108+a110);
-  a108=(a1*a108);
-  a108=(a73*a108);
-  a108=(a3*a108);
-  a110=(a37*a108);
-  a159=(a159+a110);
-  a159=(a0*a159);
-  a159=(-a159);
-  if (res[0]!=0) res[0][122]=a159;
-  a34=(a1*a34);
-  a145=(a1*a145);
-  a34=(a34+a145);
-  a145=(a10*a67);
-  a145=(a85*a145);
-  a159=(a82*a12);
-  a110=(a44*a45);
-  a157=(a50*a110);
-  a159=(a159+a157);
-  a157=(a79*a45);
-  a152=(a44*a12);
-  a33=(a43*a152);
-  a157=(a157+a33);
-  a159=(a159-a157);
-  a159=(a52*a159);
-  a157=(a2*a159);
-  a157=(a19-a157);
-  a84=(a84*a157);
-  a145=(a145+a84);
-  a84=(a10*a72);
-  a84=(a76*a84);
-  a50=(a41*a50);
-  a12=(a26*a12);
-  a50=(a50-a12);
-  a152=(a54*a152);
-  a79=(a79-a152);
-  a50=(a50-a79);
-  a50=(a39*a50);
-  a79=(a2*a50);
-  a62=(a62*a79);
-  a84=(a84+a62);
-  a62=(a10*a61);
-  a62=(a83*a62);
-  a54=(a54*a110);
-  a82=(a82-a54);
-  a43=(a41*a43);
-  a26=(a26*a45);
-  a43=(a43-a26);
-  a82=(a82-a43);
-  a82=(a39*a82);
-  a2=(a2*a82);
-  a81=(a81*a2);
-  a62=(a62-a81);
-  a84=(a84+a62);
-  a145=(a145-a84);
-  a112=(a112*a56);
-  a118=(a118*a67);
-  a112=(a112+a118);
-  a119=(a119*a61);
-  a112=(a112+a119);
-  a120=(a120*a72);
-  a112=(a112-a120);
-  a87=(a87*a112);
-  a120=(a1*a56);
-  a120=(a86*a120);
-  a87=(a87+a120);
-  a145=(a145-a87);
-  a87=(a37*a145);
-  a120=(a89*a87);
-  a119=(a10*a56);
-  a119=(a83*a119);
-  a88=(a88*a2);
-  a119=(a119-a88);
-  a88=(a10*a67);
-  a88=(a76*a88);
-  a90=(a90*a79);
-  a88=(a88-a90);
-  a119=(a119-a88);
-  a91=(a91*a157);
-  a88=(a10*a72);
-  a88=(a85*a88);
-  a91=(a91-a88);
-  a119=(a119+a91);
-  a92=(a92*a112);
-  a91=(a1*a61);
-  a91=(a86*a91);
-  a92=(a92+a91);
-  a119=(a119-a92);
-  a92=(a37*a119);
-  a91=(a80*a92);
-  a120=(a120+a91);
-  a91=(a10*a61);
-  a91=(a76*a91);
-  a94=(a94*a79);
-  a91=(a91-a94);
-  a94=(a10*a72);
-  a94=(a83*a94);
-  a96=(a96*a2);
-  a94=(a94+a96);
-  a91=(a91-a94);
-  a94=(a10*a56);
-  a94=(a85*a94);
-  a97=(a97*a157);
-  a94=(a94+a97);
-  a91=(a91-a94);
-  a98=(a98*a112);
-  a94=(a1*a67);
-  a94=(a86*a94);
-  a98=(a98+a94);
-  a91=(a91-a98);
-  a98=(a37*a91);
-  a94=(a100*a98);
-  a56=(a10*a56);
-  a56=(a76*a56);
-  a99=(a99*a79);
-  a56=(a56-a99);
-  a67=(a10*a67);
-  a67=(a83*a67);
-  a101=(a101*a2);
-  a67=(a67-a101);
-  a56=(a56+a67);
-  a61=(a10*a61);
-  a61=(a85*a61);
-  a102=(a102*a157);
-  a61=(a61+a102);
-  a56=(a56+a61);
-  a103=(a103*a112);
-  a72=(a1*a72);
-  a86=(a86*a72);
-  a103=(a103-a86);
-  a56=(a56+a103);
-  a103=(a37*a56);
-  a86=(a95*a103);
-  a94=(a94-a86);
-  a120=(a120+a94);
-  a120=(a1*a120);
-  a120=(a73*a120);
-  a120=(a3*a120);
-  a34=(a34+a120);
-  a34=(a0*a34);
-  if (res[0]!=0) res[0][123]=a34;
-  a28=(a1*a28);
-  a58=(a1*a58);
-  a28=(a28+a58);
-  a89=(a89*a98);
-  a95=(a95*a92);
-  a89=(a89+a95);
-  a100=(a100*a87);
-  a80=(a80*a103);
-  a100=(a100-a80);
-  a89=(a89-a100);
-  a89=(a1*a89);
-  a89=(a73*a89);
-  a89=(a3*a89);
-  a28=(a28+a89);
-  a28=(a0*a28);
-  if (res[0]!=0) res[0][124]=a28;
-  a158=(a1*a158);
-  a108=(a1*a108);
-  a158=(a158+a108);
-  a105=(a105*a87);
-  a122=(a122*a98);
-  a105=(a105+a122);
-  a105=(a1*a105);
-  a73=(a73*a105);
-  a3=(a3*a73);
-  a158=(a158+a3);
-  a158=(a0*a158);
-  a158=(-a158);
-  if (res[0]!=0) res[0][125]=a158;
-  a51=(a1*a51);
-  a16=(a16+a51);
-  a145=(a1*a145);
-  a16=(a16+a145);
-  a145=(a10*a98);
-  a145=(a53*a145);
-  a51=(a129*a2);
-  a158=(a44*a79);
-  a3=(a83*a158);
-  a51=(a51+a3);
-  a3=(a109*a79);
-  a73=(a44*a2);
-  a105=(a76*a73);
-  a3=(a3+a105);
-  a51=(a51-a3);
-  a51=(a52*a51);
-  a3=(a37*a51);
-  a3=(a19-a3);
-  a104=(a104*a3);
-  a145=(a145+a104);
-  a104=(a10*a103);
-  a104=(a40*a104);
-  a105=(a41*a157);
-  a83=(a83*a105);
-  a2=(a107*a2);
-  a83=(a83-a2);
-  a109=(a109*a157);
-  a73=(a85*a73);
-  a109=(a109-a73);
-  a83=(a83-a109);
-  a83=(a39*a83);
-  a109=(a37*a83);
-  a111=(a111*a109);
-  a104=(a104+a111);
-  a111=(a10*a92);
-  a111=(a48*a111);
-  a129=(a129*a157);
-  a85=(a85*a158);
-  a129=(a129-a85);
-  a76=(a76*a105);
-  a107=(a107*a79);
-  a76=(a76-a107);
-  a129=(a129-a76);
-  a129=(a39*a129);
-  a37=(a37*a129);
-  a131=(a131*a37);
-  a111=(a111-a131);
-  a104=(a104+a111);
-  a145=(a145-a104);
-  a114=(a114*a87);
-  a135=(a135*a98);
-  a114=(a114+a135);
-  a136=(a136*a92);
-  a114=(a114+a136);
-  a137=(a137*a103);
-  a114=(a114-a137);
-  a130=(a130*a114);
-  a137=(a1*a87);
-  a137=(a139*a137);
-  a130=(a130+a137);
-  a145=(a145-a130);
-  a16=(a16+a145);
-  a16=(a0*a16);
-  if (res[0]!=0) res[0][126]=a16;
-  a60=(a1*a60);
-  a60=(a60-a30);
-  a91=(a1*a91);
-  a60=(a60+a91);
-  a91=(a10*a92);
-  a91=(a40*a91);
-  a77=(a77*a109);
-  a91=(a91-a77);
-  a77=(a10*a103);
-  a77=(a48*a77);
-  a138=(a138*a37);
-  a77=(a77+a138);
-  a91=(a91-a77);
-  a77=(a10*a87);
-  a77=(a53*a77);
-  a140=(a140*a3);
-  a77=(a77+a140);
-  a91=(a91-a77);
-  a128=(a128*a114);
-  a77=(a1*a98);
-  a77=(a139*a77);
-  a128=(a128+a77);
-  a91=(a91-a128);
-  a60=(a60+a91);
-  a60=(a0*a60);
-  if (res[0]!=0) res[0][127]=a60;
-  a144=(a1*a144);
-  a24=(a24+a144);
-  a119=(a1*a119);
-  a24=(a24+a119);
-  a119=(a10*a87);
-  a119=(a48*a119);
-  a93=(a93*a37);
-  a119=(a119-a93);
-  a93=(a10*a98);
-  a93=(a40*a93);
-  a141=(a141*a109);
-  a93=(a93-a141);
-  a119=(a119-a93);
-  a142=(a142*a3);
-  a93=(a10*a103);
-  a93=(a53*a93);
-  a142=(a142-a93);
-  a119=(a119+a142);
-  a125=(a125*a114);
-  a142=(a1*a92);
-  a142=(a139*a142);
-  a125=(a125+a142);
-  a119=(a119-a125);
-  a24=(a24+a119);
-  a24=(a0*a24);
-  if (res[0]!=0) res[0][128]=a24;
-  a66=(a1*a66);
-  a35=(a35+a66);
-  a56=(a1*a56);
-  a35=(a35+a56);
-  a87=(a10*a87);
-  a87=(a40*a87);
-  a9=(a9*a109);
-  a87=(a87-a9);
-  a98=(a10*a98);
-  a98=(a48*a98);
-  a123=(a123*a37);
-  a98=(a98-a123);
-  a87=(a87+a98);
-  a10=(a10*a92);
-  a10=(a53*a10);
-  a126=(a126*a3);
-  a10=(a10+a126);
-  a87=(a87+a10);
-  a124=(a124*a114);
-  a103=(a1*a103);
-  a139=(a139*a103);
-  a124=(a124-a139);
-  a87=(a87+a124);
-  a35=(a35+a87);
-  a35=(a0*a35);
-  a35=(-a35);
-  if (res[0]!=0) res[0][129]=a35;
-  a50=(a1*a50);
-  a15=(a15+a50);
-  a83=(a1*a83);
-  a15=(a15+a83);
-  a41=(a41*a3);
-  a83=(a48*a41);
-  a50=(a74*a37);
-  a83=(a83-a50);
-  a50=(a121*a3);
-  a35=(a44*a37);
-  a87=(a53*a35);
-  a50=(a50-a87);
-  a83=(a83-a50);
-  a83=(a39*a83);
-  a15=(a15+a83);
-  a15=(a0*a15);
-  a15=(-a15);
-  if (res[0]!=0) res[0][130]=a15;
-  a82=(a1*a82);
-  a49=(a49+a82);
-  a129=(a1*a129);
-  a49=(a49+a129);
-  a3=(a134*a3);
-  a44=(a44*a109);
-  a53=(a53*a44);
-  a3=(a3-a53);
-  a41=(a40*a41);
-  a74=(a74*a109);
-  a41=(a41-a74);
-  a3=(a3-a41);
-  a39=(a39*a3);
-  a49=(a49+a39);
-  a49=(a0*a49);
-  a49=(-a49);
-  if (res[0]!=0) res[0][131]=a49;
-  a159=(a1*a159);
-  a1=(a1*a51);
-  a159=(a159+a1);
-  a134=(a134*a37);
-  a48=(a48*a44);
-  a134=(a134+a48);
-  a121=(a121*a109);
-  a40=(a40*a35);
-  a121=(a121+a40);
-  a134=(a134-a121);
-  a52=(a52*a134);
-  a159=(a159+a52);
-  a0=(a0*a159);
-  a19=(a19-a0);
-  if (res[0]!=0) res[0][132]=a19;
-  return 0;
-}
-
-int FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f3(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_ddynamics_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_ddynamics_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_ddynamics_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_ddynamics_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_ddynamics_0_release(int mem) {
-}
-
-void FORCENLPsolver_ddynamics_0_incref(void) {
-}
-
-void FORCENLPsolver_ddynamics_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_ddynamics_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_ddynamics_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_ddynamics_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_ddynamics_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_ddynamics_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s5;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_inequalities_0:(i0[17],i1[9])->(o0) */
-static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2;
-  a0=arg[0]? arg[0][4] : 0;
-  a1=arg[1]? arg[1][6] : 0;
-  a0=(a0-a1);
-  a0=casadi_sq(a0);
-  a1=arg[0]? arg[0][5] : 0;
-  a2=arg[1]? arg[1][7] : 0;
-  a1=(a1-a2);
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  a1=arg[0]? arg[0][6] : 0;
-  a2=arg[1]? arg[1][8] : 0;
-  a1=(a1-a2);
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][0]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f4(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_inequalities_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_inequalities_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_0_release(int mem) {
-}
-
-void FORCENLPsolver_inequalities_0_incref(void) {
-}
-
-void FORCENLPsolver_inequalities_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_inequalities_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_inequalities_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_inequalities_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_inequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dinequalities_0:(i0[17],i1[9])->(o0[1x17,3nz]) */
-static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][4] : 0;
-  a1=arg[1]? arg[1][6] : 0;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][5] : 0;
-  a1=arg[1]? arg[1][7] : 0;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=arg[0]? arg[0][6] : 0;
-  a1=arg[1]? arg[1][8] : 0;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][2]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f5(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dinequalities_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dinequalities_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_0_release(int mem) {
-}
-
-void FORCENLPsolver_dinequalities_0_incref(void) {
-}
-
-void FORCENLPsolver_dinequalities_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dinequalities_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dinequalities_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dinequalities_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s6;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dinequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_objective_1:(i0[17],i1[9])->(o0) */
-static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a3=(a3*a1);
-  a1=arg[0]? arg[0][5] : 0;
-  a2=arg[1]? arg[1][1] : 0;
-  a4=(a1-a2);
-  a4=(a0*a4);
-  a1=(a1-a2);
-  a4=(a4*a1);
-  a3=(a3+a4);
-  a4=arg[0]? arg[0][6] : 0;
-  a1=arg[1]? arg[1][2] : 0;
-  a2=(a4-a1);
-  a0=(a0*a2);
-  a4=(a4-a1);
-  a0=(a0*a4);
-  a3=(a3+a0);
-  a0=20.;
-  a4=arg[0]? arg[0][7] : 0;
-  a1=arg[1]? arg[1][3] : 0;
-  a2=(a4-a1);
-  a2=(a0*a2);
-  a4=(a4-a1);
-  a2=(a2*a4);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][8] : 0;
-  a4=arg[1]? arg[1][4] : 0;
-  a1=(a2-a4);
-  a1=(a0*a1);
-  a2=(a2-a4);
-  a1=(a1*a2);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][9] : 0;
-  a2=arg[1]? arg[1][5] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=10.;
-  a1=arg[0]? arg[0][10] : 0;
-  a2=(a0*a1);
-  a2=(a2*a1);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][11] : 0;
-  a1=(a0*a2);
-  a1=(a1*a2);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][12] : 0;
-  a2=(a0*a1);
-  a2=(a2*a1);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][13] : 0;
-  a1=1.;
-  a4=(a2-a1);
-  a4=(a0*a4);
-  a2=(a2-a1);
-  a4=(a4*a2);
-  a3=(a3+a4);
-  a4=arg[0]? arg[0][14] : 0;
-  a2=(a0*a4);
-  a2=(a2*a4);
-  a3=(a3+a2);
-  a2=arg[0]? arg[0][15] : 0;
-  a4=(a0*a2);
-  a4=(a4*a2);
-  a3=(a3+a4);
-  a4=arg[0]? arg[0][16] : 0;
-  a0=(a0*a4);
-  a0=(a0*a4);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-01;
-  a4=arg[0]? arg[0][0] : 0;
-  a4=casadi_sq(a4);
-  a2=arg[0]? arg[0][1] : 0;
-  a2=casadi_sq(a2);
-  a4=(a4+a2);
-  a2=arg[0]? arg[0][2] : 0;
-  a2=casadi_sq(a2);
-  a4=(a4+a2);
-  a2=arg[0]? arg[0][3] : 0;
-  a2=casadi_sq(a2);
-  a4=(a4+a2);
-  a0=(a0*a4);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][0]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f6(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_objective_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_objective_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_objective_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_1_release(int mem) {
-}
-
-void FORCENLPsolver_objective_1_incref(void) {
-}
-
-void FORCENLPsolver_objective_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_objective_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_objective_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_objective_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dobjective_1:(i0[17],i1[9])->(o0[1x17]) */
-static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-01;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][0]=a1;
-  a1=arg[0]? arg[0][1] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][1]=a1;
-  a1=arg[0]? arg[0][2] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][2]=a1;
-  a1=arg[0]? arg[0][3] : 0;
-  a1=(a1+a1);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][3]=a0;
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][4]=a3;
-  a3=arg[0]? arg[0][5] : 0;
-  a1=arg[1]? arg[1][1] : 0;
-  a2=(a3-a1);
-  a2=(a0*a2);
-  a3=(a3-a1);
-  a3=(a0*a3);
-  a2=(a2+a3);
-  if (res[0]!=0) res[0][5]=a2;
-  a2=arg[0]? arg[0][6] : 0;
-  a3=arg[1]? arg[1][2] : 0;
-  a1=(a2-a3);
-  a1=(a0*a1);
-  a2=(a2-a3);
-  a0=(a0*a2);
-  a1=(a1+a0);
-  if (res[0]!=0) res[0][6]=a1;
-  a1=20.;
-  a0=arg[0]? arg[0][7] : 0;
-  a2=arg[1]? arg[1][3] : 0;
-  a3=(a0-a2);
-  a3=(a1*a3);
-  a0=(a0-a2);
-  a0=(a1*a0);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][7]=a3;
-  a3=arg[0]? arg[0][8] : 0;
-  a0=arg[1]? arg[1][4] : 0;
-  a2=(a3-a0);
-  a2=(a1*a2);
-  a3=(a3-a0);
-  a3=(a1*a3);
-  a2=(a2+a3);
-  if (res[0]!=0) res[0][8]=a2;
-  a2=arg[0]? arg[0][9] : 0;
-  a3=arg[1]? arg[1][5] : 0;
-  a0=(a2-a3);
-  a0=(a1*a0);
-  a2=(a2-a3);
-  a1=(a1*a2);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][9]=a0;
-  a0=10.;
-  a1=arg[0]? arg[0][10] : 0;
-  a2=(a0*a1);
-  a1=(a0*a1);
-  a2=(a2+a1);
-  if (res[0]!=0) res[0][10]=a2;
-  a2=arg[0]? arg[0][11] : 0;
-  a1=(a0*a2);
-  a2=(a0*a2);
-  a1=(a1+a2);
-  if (res[0]!=0) res[0][11]=a1;
-  a1=arg[0]? arg[0][12] : 0;
-  a2=(a0*a1);
-  a1=(a0*a1);
-  a2=(a2+a1);
-  if (res[0]!=0) res[0][12]=a2;
-  a2=arg[0]? arg[0][13] : 0;
-  a1=1.;
-  a3=(a2-a1);
-  a3=(a0*a3);
-  a2=(a2-a1);
-  a2=(a0*a2);
-  a3=(a3+a2);
-  if (res[0]!=0) res[0][13]=a3;
-  a3=arg[0]? arg[0][14] : 0;
-  a2=(a0*a3);
-  a3=(a0*a3);
-  a2=(a2+a3);
-  if (res[0]!=0) res[0][14]=a2;
-  a2=arg[0]? arg[0][15] : 0;
-  a3=(a0*a2);
-  a2=(a0*a2);
-  a3=(a3+a2);
-  if (res[0]!=0) res[0][15]=a3;
-  a3=arg[0]? arg[0][16] : 0;
-  a2=(a0*a3);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][16]=a2;
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f7(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dobjective_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dobjective_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_1_release(int mem) {
-}
-
-void FORCENLPsolver_dobjective_1_incref(void) {
-}
-
-void FORCENLPsolver_dobjective_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dobjective_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dobjective_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dobjective_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s3;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_inequalities_1:(i0[17],i1[9])->(o0) */
-static int casadi_f8(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2;
-  a0=arg[0]? arg[0][4] : 0;
-  a1=arg[1]? arg[1][6] : 0;
-  a0=(a0-a1);
-  a0=casadi_sq(a0);
-  a1=arg[0]? arg[0][5] : 0;
-  a2=arg[1]? arg[1][7] : 0;
-  a1=(a1-a2);
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  a1=arg[0]? arg[0][6] : 0;
-  a2=arg[1]? arg[1][8] : 0;
-  a1=(a1-a2);
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][0]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f8(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_inequalities_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_inequalities_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_1_release(int mem) {
-}
-
-void FORCENLPsolver_inequalities_1_incref(void) {
-}
-
-void FORCENLPsolver_inequalities_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_inequalities_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_inequalities_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_inequalities_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_inequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dinequalities_1:(i0[17],i1[9])->(o0[1x17,3nz]) */
-static int casadi_f9(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][4] : 0;
-  a1=arg[1]? arg[1][6] : 0;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][5] : 0;
-  a1=arg[1]? arg[1][7] : 0;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=arg[0]? arg[0][6] : 0;
-  a1=arg[1]? arg[1][8] : 0;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][2]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f9(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dinequalities_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dinequalities_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_1_release(int mem) {
-}
-
-void FORCENLPsolver_dinequalities_1_incref(void) {
-}
-
-void FORCENLPsolver_dinequalities_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dinequalities_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dinequalities_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dinequalities_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s6;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dinequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
Index: model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* obj_mex;
-	mxArray* gradobj_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	obj_mex = mxCreateDoubleMatrix(1, 1, mxREAL);
-	gradobj_mex = mxCreateDoubleMatrix(nvar, 1, mxREAL);
-	copyCArrayToM_FORCENLPsolver(obj, mxGetPr(obj_mex), 1);
-	copyCArrayToM_FORCENLPsolver(jacobj, mxGetPr(gradobj_mex), nvar);
-	plhs[0] = obj_mex;
-	plhs[1] = gradobj_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
===================================================================
diff --git a/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c b/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
deleted file mode 100644
--- a/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,560 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-
-#define S_FUNCTION_LEVEL 2
-#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlockcompact
-
-#include "simstruc.h"
-
-
-
-/* include FORCESPRO functions and defs */
-#include "../include/FORCENLPsolver.h" 
-
-/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */
-
-
-#if defined(MATLAB_MEX_FILE)
-#include "tmwtypes.h"
-#include "simstruc_types.h"
-#else
-#include "rtwtypes.h"
-#endif
-
-typedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;
-
-extern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-
-
-/*====================*
- * S-function methods *
- *====================*/
-/* Function: mdlInitializeSizes =========================================
- * Abstract:
- *   Setup sizes of the various vectors.
- */
-static void mdlInitializeSizes(SimStruct *S)
-{
-
-    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
-    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
-    ssSetNumSFcnParams(S, 0);
-    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
-	{
-		return; /* Parameter mismatch will be reported by Simulink */
-    }
-
-	/* initialize size of continuous and discrete states to zero */
-    ssSetNumContStates(S, 0);
-    ssSetNumDiscStates(S, 0);
-
-	/* initialize input ports - there are 6 in total */
-    if (!ssSetNumInputPorts(S, 6)) return;
-    	
-	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 1, 1);
-    ssSetInputPortDataType(S, 0, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
-	
-	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 160, 1);
-    ssSetInputPortDataType(S, 1, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/
-	
-	/* Input Port 2 */
-    ssSetInputPortMatrixDimensions(S,  2, 160, 1);
-    ssSetInputPortDataType(S, 2, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/
-	
-	/* Input Port 3 */
-    ssSetInputPortMatrixDimensions(S,  3, 13, 1);
-    ssSetInputPortDataType(S, 3, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/
-	
-	/* Input Port 4 */
-    ssSetInputPortMatrixDimensions(S,  4, 680, 1);
-    ssSetInputPortDataType(S, 4, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 4, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 4, 1); /*direct input signal access*/
-	
-	/* Input Port 5 */
-    ssSetInputPortMatrixDimensions(S,  5, 360, 1);
-    ssSetInputPortDataType(S, 5, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 5, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 5, 1); /*direct input signal access*/
- 
-
-
-	/* initialize output ports - there are 1 in total */
-    if (!ssSetNumOutputPorts(S, 1)) return;    
-		
-	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 680, 1);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-
-
-	/* set sampling time */
-    ssSetNumSampleTimes(S, 1);
-
-	/* set internal memory of block */
-    ssSetNumRWork(S, 0);
-    ssSetNumIWork(S, 0);
-    ssSetNumPWork(S, 0);
-    ssSetNumModes(S, 0);
-    ssSetNumNonsampledZCs(S, 0);
-
-    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
-		             SS_OPTION_WORKS_WITH_CODE_REUSE)); */
-	ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );
-
-	
-}
-
-#if defined(MATLAB_MEX_FILE)
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-static void mdlSetInputPortDimensionInfo(SimStruct        *S, 
-                                         int_T            port,
-                                         const DimsInfo_T *dimsInfo)
-{
-    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)
-static void mdlSetOutputPortDimensionInfo(SimStruct        *S, 
-                                          int_T            port, 
-                                          const DimsInfo_T *dimsInfo)
-{
-    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-# define MDL_SET_INPUT_PORT_FRAME_DATA
-static void mdlSetInputPortFrameData(SimStruct  *S, 
-                                     int_T      port,
-                                     Frame_T    frameData)
-{
-    ssSetInputPortFrameData(S, port, frameData);
-}
-/* Function: mdlInitializeSampleTimes =========================================
- * Abstract:
- *    Specifiy  the sample time.
- */
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
-    ssSetOffsetTime(S, 0, 0.0);
-}
-
-#define MDL_SET_INPUT_PORT_DATA_TYPE
-static void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetInputPortDataType( S, 0, dType);
-}
-#define MDL_SET_OUTPUT_PORT_DATA_TYPE
-static void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetOutputPortDataType(S, 0, dType);
-}
-
-#define MDL_SET_DEFAULT_PORT_DATA_TYPES
-static void mdlSetDefaultPortDataTypes(SimStruct *S)
-{
-    ssSetInputPortDataType( S, 0, SS_DOUBLE);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-}
-
-
-
-
-
-/* Function: mdlOutputs =======================================================
- *
-*/
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	solver_int32_default i, j, k;
-	
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* Simulink data */
-	const FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,0);
-	const real_T *lb = (const real_T*) ssGetInputPortSignal(S,1);
-	const real_T *ub = (const real_T*) ssGetInputPortSignal(S,2);
-	const real_T *xinit = (const real_T*) ssGetInputPortSignal(S,3);
-	const real_T *x0 = (const real_T*) ssGetInputPortSignal(S,4);
-	const real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,5);
-	
-    real_T *outputs = (real_T*) ssGetOutputPortSignal(S,0);
-	
-	
-
-	/* Solver data */
-	static FORCENLPsolver_params params;
-	static FORCENLPsolver_output output;
-	static FORCENLPsolver_info info;	
-	solver_int32_default exitflag;
-
-	/* Extra NMPC data */
-	
-
-	/* Copy inputs */
-	for( i=0; i<160; i++)
-	{ 
-		params.lb[i] = (double) lb[i]; 
-	}
-
-	for( i=0; i<160; i++)
-	{ 
-		params.ub[i] = (double) ub[i]; 
-	}
-
-	for( i=0; i<13; i++)
-	{ 
-		params.xinit[i] = (double) xinit[i]; 
-	}
-
-	for( i=0; i<680; i++)
-	{ 
-		params.x0[i] = (double) x0[i]; 
-	}
-
-	for( i=0; i<360; i++)
-	{ 
-		params.all_parameters[i] = (double) all_parameters[i]; 
-	}
-
-	params.reinitialize = *reinitialize;
-
-	
-
-	
-
-    #if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* Call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			ssPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	
-
-	/* Copy outputs */
-	for( i=0; i<17; i++)
-	{ 
-		outputs[i] = (real_T) output.x01[i]; 
-	}
-
-	k=17; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x02[i]; 
-	}
-
-	k=34; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x03[i]; 
-	}
-
-	k=51; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x04[i]; 
-	}
-
-	k=68; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x05[i]; 
-	}
-
-	k=85; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x06[i]; 
-	}
-
-	k=102; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x07[i]; 
-	}
-
-	k=119; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x08[i]; 
-	}
-
-	k=136; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x09[i]; 
-	}
-
-	k=153; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x10[i]; 
-	}
-
-	k=170; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x11[i]; 
-	}
-
-	k=187; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x12[i]; 
-	}
-
-	k=204; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x13[i]; 
-	}
-
-	k=221; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x14[i]; 
-	}
-
-	k=238; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x15[i]; 
-	}
-
-	k=255; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x16[i]; 
-	}
-
-	k=272; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x17[i]; 
-	}
-
-	k=289; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x18[i]; 
-	}
-
-	k=306; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x19[i]; 
-	}
-
-	k=323; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x20[i]; 
-	}
-
-	k=340; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x21[i]; 
-	}
-
-	k=357; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x22[i]; 
-	}
-
-	k=374; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x23[i]; 
-	}
-
-	k=391; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x24[i]; 
-	}
-
-	k=408; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x25[i]; 
-	}
-
-	k=425; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x26[i]; 
-	}
-
-	k=442; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x27[i]; 
-	}
-
-	k=459; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x28[i]; 
-	}
-
-	k=476; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x29[i]; 
-	}
-
-	k=493; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x30[i]; 
-	}
-
-	k=510; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x31[i]; 
-	}
-
-	k=527; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x32[i]; 
-	}
-
-	k=544; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x33[i]; 
-	}
-
-	k=561; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x34[i]; 
-	}
-
-	k=578; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x35[i]; 
-	}
-
-	k=595; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x36[i]; 
-	}
-
-	k=612; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x37[i]; 
-	}
-
-	k=629; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x38[i]; 
-	}
-
-	k=646; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x39[i]; 
-	}
-
-	k=663; 
-	for( i=0; i<17; i++)
-	{ 
-		outputs[k++] = (real_T) output.x40[i]; 
-	}
-
-	
-}
-
-
-
-
-
-/* Function: mdlTerminate =====================================================
- * Abstract:
- *    In this function, you should perform any actions that are necessary
- *    at the termination of a simulation.  For example, if memory was
- *    allocated in mdlStart, this is the place to free it.
- */
-static void mdlTerminate(SimStruct *S)
-{
-}
-#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
-#include "simulink.c"      /* MEX-file interface mechanism */
-#else
-#include "cg_sfun.h"       /* Code generation registration function */
-#endif
-
-
Index: model/FORCENLPsolver/interface/definitions_eval.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>is_static = True\nlib = \"solver_with_model.dll\"\nf = \"FORCENLPsolver_interface\"\nintel_libs_dir = \"C:\\\\Users\\\\Vassil\\\\Desktop\\\\Personal\\\\TU Delft\\\\Msc Robotics\\\\forces_pro_client\\\\libs_Intel\\\\win64\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/model/FORCENLPsolver/interface/definitions_eval.py b/model/FORCENLPsolver/interface/definitions_eval.py
--- a/model/FORCENLPsolver/interface/definitions_eval.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ b/model/FORCENLPsolver/interface/definitions_eval.py	(date 1646425681876)
@@ -1,4 +1,4 @@
 is_static = True
-lib = "solver_with_model.dll"
+lib = "libsolver_with_model.so"
 f = "FORCENLPsolver_interface"
-intel_libs_dir = "C:\\Users\\Vassil\\Desktop\\Personal\\TU Delft\\Msc Robotics\\forces_pro_client\\libs_Intel\\win64"
+intel_libs_dir = "/home/richard/Applications/Forces_Pro/forces_pro_client/libs_Intel/win64"
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9 (MPC)\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ b/.idea/misc.xml	(date 1646425681884)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (MPC)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.6 (cs285)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/MPC_final_project.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\" />\n    <content url=\"file://$MODULE_DIR$/../../forces_pro_client\">\n      <sourceFolder url=\"file://$MODULE_DIR$/../../forces_pro_client\" isTestSource=\"false\" />\n    </content>\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9 (MPC)\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n  <component name=\"PyDocumentationSettings\">\n    <option name=\"format\" value=\"PLAIN\" />\n    <option name=\"myDocStringFormat\" value=\"Plain\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/MPC_final_project.iml b/.idea/MPC_final_project.iml
--- a/.idea/MPC_final_project.iml	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ b/.idea/MPC_final_project.iml	(date 1646425681892)
@@ -5,7 +5,7 @@
     <content url="file://$MODULE_DIR$/../../forces_pro_client">
       <sourceFolder url="file://$MODULE_DIR$/../../forces_pro_client" isTestSource="false" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.9 (MPC)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.6 (cs285)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="PyDocumentationSettings">
