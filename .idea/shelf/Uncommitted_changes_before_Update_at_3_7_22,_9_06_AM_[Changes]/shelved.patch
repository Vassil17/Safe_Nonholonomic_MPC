Index: model/FORCENLPsolver/interface/definitions_eval.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/definitions_eval.py b/model/FORCENLPsolver/interface/definitions_eval.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/definitions_eval.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,4 +0,0 @@
-is_static = True
-lib = "solver_with_model.dll"
-f = "FORCENLPsolver_interface"
-intel_libs_dir = "C:\\Users\\Vassil\\Desktop\\Personal\\TU Delft\\Msc Robotics\\forces_pro_client\\libs_Intel\\win64"
Index: model/FORCENLPsolver/interface/definitions.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/definitions.py b/model/FORCENLPsolver/interface/definitions.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/definitions.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,114 +0,0 @@
-import numpy
-import ctypes
-
-name = "FORCENLPsolver"
-requires_callback = True
-lib = "lib/FORCENLPsolver.dll"
-lib_static = "lib/FORCENLPsolver_static.lib"
-c_header = "include/FORCENLPsolver.h"
-nstages = 40
-
-# Parameter             | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
-params = \
-[("xinit"               , "dense" , ""               , ctypes.c_double, numpy.float64, (  3,   1),    3),
- ("x0"                  , "dense" , ""               , ctypes.c_double, numpy.float64, (200,   1),  200),
- ("all_parameters"      , "dense" , ""               , ctypes.c_double, numpy.float64, (120,   1),  120),
- ("reinitialize"        , ""      , "FORCENLPsolver_int", ctypes.c_int   , numpy.int32  , (  0,   1),    1)]
-
-# Output                | Type    | Scalar type      | Ctypes type    | Numpy type   | Shape     | Len
-outputs = \
-[("x01"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x02"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x03"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x04"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x05"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x06"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x07"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x08"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x09"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x10"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x11"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x12"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x13"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x14"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x15"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x16"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x17"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x18"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x19"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x20"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x21"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x22"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x23"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x24"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x25"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x26"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x27"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x28"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x29"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x30"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x31"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x32"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x33"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x34"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x35"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x36"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x37"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x38"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x39"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5),
- ("x40"                 , ""      , ""               , ctypes.c_double, numpy.float64,     (  5,),    5)]
-
-# Info Struct Fields
-info = \
-[("it", ctypes.c_int),
- ("res_eq", ctypes.c_double),
- ("rsnorm", ctypes.c_double),
- ("pobj", ctypes.c_double),
- ("solvetime", ctypes.c_double),
- ("fevalstime", ctypes.c_double),
- ("QPtime", ctypes.c_double)]
-
-# Dynamics dimensions
-#   nvar    |   neq   |   dimh    |   dimp    |   diml    |   dimu    |   dimhl   |   dimhu    
-dynamics_dims = [
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0), 
-	(5, 3, 1, 3, 0, 0, 1, 0)
-]
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlock.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,739 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-
-#define S_FUNCTION_LEVEL 2
-#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlock
-
-#include "simstruc.h"
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* include FORCESPRO functions and defs */
-#include "../include/FORCENLPsolver.h" 
-
-/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */
-
-
-#if defined(MATLAB_MEX_FILE)
-#include "tmwtypes.h"
-#include "simstruc_types.h"
-#else
-#include "rtwtypes.h"
-#endif
-
-typedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;
-
-extern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-
-
-/*====================*
- * S-function methods *
- *====================*/
-/* Function: mdlInitializeSizes =========================================
- * Abstract:
- *   Setup sizes of the various vectors.
- */
-static void mdlInitializeSizes(SimStruct *S)
-{
-
-    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
-    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
-    ssSetNumSFcnParams(S, 0);
-    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
-	{
-		return; /* Parameter mismatch will be reported by Simulink */
-    }
-
-	/* initialize size of continuous and discrete states to zero */
-    ssSetNumContStates(S, 0);
-    ssSetNumDiscStates(S, 0);
-
-	/* initialize input ports - there are 4 in total */
-    if (!ssSetNumInputPorts(S, 4)) return;
-    	
-	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 3, 1);
-    ssSetInputPortDataType(S, 0, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
-	
-	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 200, 1);
-    ssSetInputPortDataType(S, 1, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/
-	
-	/* Input Port 2 */
-    ssSetInputPortMatrixDimensions(S,  2, 120, 1);
-    ssSetInputPortDataType(S, 2, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/
-	
-	/* Input Port 3 */
-    ssSetInputPortMatrixDimensions(S,  3, 1, 1);
-    ssSetInputPortDataType(S, 3, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/
- 
-
-
-	/* initialize output ports - there are 40 in total */
-    if (!ssSetNumOutputPorts(S, 40)) return;    
-		
-	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 5, 1);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 1 */
-    ssSetOutputPortMatrixDimensions(S,  1, 5, 1);
-    ssSetOutputPortDataType(S, 1, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 2 */
-    ssSetOutputPortMatrixDimensions(S,  2, 5, 1);
-    ssSetOutputPortDataType(S, 2, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 3 */
-    ssSetOutputPortMatrixDimensions(S,  3, 5, 1);
-    ssSetOutputPortDataType(S, 3, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 4 */
-    ssSetOutputPortMatrixDimensions(S,  4, 5, 1);
-    ssSetOutputPortDataType(S, 4, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 4, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 5 */
-    ssSetOutputPortMatrixDimensions(S,  5, 5, 1);
-    ssSetOutputPortDataType(S, 5, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 5, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 6 */
-    ssSetOutputPortMatrixDimensions(S,  6, 5, 1);
-    ssSetOutputPortDataType(S, 6, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 6, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 7 */
-    ssSetOutputPortMatrixDimensions(S,  7, 5, 1);
-    ssSetOutputPortDataType(S, 7, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 7, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 8 */
-    ssSetOutputPortMatrixDimensions(S,  8, 5, 1);
-    ssSetOutputPortDataType(S, 8, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 8, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 9 */
-    ssSetOutputPortMatrixDimensions(S,  9, 5, 1);
-    ssSetOutputPortDataType(S, 9, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 9, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 10 */
-    ssSetOutputPortMatrixDimensions(S,  10, 5, 1);
-    ssSetOutputPortDataType(S, 10, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 10, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 11 */
-    ssSetOutputPortMatrixDimensions(S,  11, 5, 1);
-    ssSetOutputPortDataType(S, 11, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 11, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 12 */
-    ssSetOutputPortMatrixDimensions(S,  12, 5, 1);
-    ssSetOutputPortDataType(S, 12, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 12, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 13 */
-    ssSetOutputPortMatrixDimensions(S,  13, 5, 1);
-    ssSetOutputPortDataType(S, 13, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 13, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 14 */
-    ssSetOutputPortMatrixDimensions(S,  14, 5, 1);
-    ssSetOutputPortDataType(S, 14, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 14, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 15 */
-    ssSetOutputPortMatrixDimensions(S,  15, 5, 1);
-    ssSetOutputPortDataType(S, 15, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 15, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 16 */
-    ssSetOutputPortMatrixDimensions(S,  16, 5, 1);
-    ssSetOutputPortDataType(S, 16, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 16, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 17 */
-    ssSetOutputPortMatrixDimensions(S,  17, 5, 1);
-    ssSetOutputPortDataType(S, 17, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 17, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 18 */
-    ssSetOutputPortMatrixDimensions(S,  18, 5, 1);
-    ssSetOutputPortDataType(S, 18, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 18, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 19 */
-    ssSetOutputPortMatrixDimensions(S,  19, 5, 1);
-    ssSetOutputPortDataType(S, 19, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 19, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 20 */
-    ssSetOutputPortMatrixDimensions(S,  20, 5, 1);
-    ssSetOutputPortDataType(S, 20, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 20, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 21 */
-    ssSetOutputPortMatrixDimensions(S,  21, 5, 1);
-    ssSetOutputPortDataType(S, 21, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 21, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 22 */
-    ssSetOutputPortMatrixDimensions(S,  22, 5, 1);
-    ssSetOutputPortDataType(S, 22, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 22, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 23 */
-    ssSetOutputPortMatrixDimensions(S,  23, 5, 1);
-    ssSetOutputPortDataType(S, 23, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 23, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 24 */
-    ssSetOutputPortMatrixDimensions(S,  24, 5, 1);
-    ssSetOutputPortDataType(S, 24, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 24, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 25 */
-    ssSetOutputPortMatrixDimensions(S,  25, 5, 1);
-    ssSetOutputPortDataType(S, 25, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 25, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 26 */
-    ssSetOutputPortMatrixDimensions(S,  26, 5, 1);
-    ssSetOutputPortDataType(S, 26, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 26, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 27 */
-    ssSetOutputPortMatrixDimensions(S,  27, 5, 1);
-    ssSetOutputPortDataType(S, 27, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 27, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 28 */
-    ssSetOutputPortMatrixDimensions(S,  28, 5, 1);
-    ssSetOutputPortDataType(S, 28, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 28, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 29 */
-    ssSetOutputPortMatrixDimensions(S,  29, 5, 1);
-    ssSetOutputPortDataType(S, 29, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 29, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 30 */
-    ssSetOutputPortMatrixDimensions(S,  30, 5, 1);
-    ssSetOutputPortDataType(S, 30, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 30, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 31 */
-    ssSetOutputPortMatrixDimensions(S,  31, 5, 1);
-    ssSetOutputPortDataType(S, 31, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 31, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 32 */
-    ssSetOutputPortMatrixDimensions(S,  32, 5, 1);
-    ssSetOutputPortDataType(S, 32, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 32, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 33 */
-    ssSetOutputPortMatrixDimensions(S,  33, 5, 1);
-    ssSetOutputPortDataType(S, 33, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 33, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 34 */
-    ssSetOutputPortMatrixDimensions(S,  34, 5, 1);
-    ssSetOutputPortDataType(S, 34, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 34, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 35 */
-    ssSetOutputPortMatrixDimensions(S,  35, 5, 1);
-    ssSetOutputPortDataType(S, 35, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 35, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 36 */
-    ssSetOutputPortMatrixDimensions(S,  36, 5, 1);
-    ssSetOutputPortDataType(S, 36, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 36, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 37 */
-    ssSetOutputPortMatrixDimensions(S,  37, 5, 1);
-    ssSetOutputPortDataType(S, 37, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 37, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 38 */
-    ssSetOutputPortMatrixDimensions(S,  38, 5, 1);
-    ssSetOutputPortDataType(S, 38, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 38, COMPLEX_NO); /* no complex signals suppported */
-	
-	/* Output Port 39 */
-    ssSetOutputPortMatrixDimensions(S,  39, 5, 1);
-    ssSetOutputPortDataType(S, 39, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 39, COMPLEX_NO); /* no complex signals suppported */
-
-
-	/* set sampling time */
-    ssSetNumSampleTimes(S, 1);
-
-	/* set internal memory of block */
-    ssSetNumRWork(S, 0);
-    ssSetNumIWork(S, 0);
-    ssSetNumPWork(S, 0);
-    ssSetNumModes(S, 0);
-    ssSetNumNonsampledZCs(S, 0);
-
-    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
-		             SS_OPTION_WORKS_WITH_CODE_REUSE)); */
-	ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );
-
-	
-}
-
-#if defined(MATLAB_MEX_FILE)
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-static void mdlSetInputPortDimensionInfo(SimStruct        *S, 
-                                         int_T            port,
-                                         const DimsInfo_T *dimsInfo)
-{
-    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)
-static void mdlSetOutputPortDimensionInfo(SimStruct        *S, 
-                                          int_T            port, 
-                                          const DimsInfo_T *dimsInfo)
-{
-    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-# define MDL_SET_INPUT_PORT_FRAME_DATA
-static void mdlSetInputPortFrameData(SimStruct  *S, 
-                                     int_T      port,
-                                     Frame_T    frameData)
-{
-    ssSetInputPortFrameData(S, port, frameData);
-}
-/* Function: mdlInitializeSampleTimes =========================================
- * Abstract:
- *    Specifiy  the sample time.
- */
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
-    ssSetOffsetTime(S, 0, 0.0);
-}
-
-#define MDL_SET_INPUT_PORT_DATA_TYPE
-static void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetInputPortDataType( S, 0, dType);
-}
-#define MDL_SET_OUTPUT_PORT_DATA_TYPE
-static void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetOutputPortDataType(S, 0, dType);
-}
-
-#define MDL_SET_DEFAULT_PORT_DATA_TYPES
-static void mdlSetDefaultPortDataTypes(SimStruct *S)
-{
-    ssSetInputPortDataType( S, 0, SS_DOUBLE);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-}
-
-
-
-
-
-/* Function: mdlOutputs =======================================================
- *
-*/
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	solver_int32_default i, j, k;
-	
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* Simulink data */
-	const real_T *xinit = (const real_T*) ssGetInputPortSignal(S,0);
-	const real_T *x0 = (const real_T*) ssGetInputPortSignal(S,1);
-	const real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,2);
-	const FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,3);
-	
-    real_T *x01 = (real_T*) ssGetOutputPortSignal(S,0);
-	real_T *x02 = (real_T*) ssGetOutputPortSignal(S,1);
-	real_T *x03 = (real_T*) ssGetOutputPortSignal(S,2);
-	real_T *x04 = (real_T*) ssGetOutputPortSignal(S,3);
-	real_T *x05 = (real_T*) ssGetOutputPortSignal(S,4);
-	real_T *x06 = (real_T*) ssGetOutputPortSignal(S,5);
-	real_T *x07 = (real_T*) ssGetOutputPortSignal(S,6);
-	real_T *x08 = (real_T*) ssGetOutputPortSignal(S,7);
-	real_T *x09 = (real_T*) ssGetOutputPortSignal(S,8);
-	real_T *x10 = (real_T*) ssGetOutputPortSignal(S,9);
-	real_T *x11 = (real_T*) ssGetOutputPortSignal(S,10);
-	real_T *x12 = (real_T*) ssGetOutputPortSignal(S,11);
-	real_T *x13 = (real_T*) ssGetOutputPortSignal(S,12);
-	real_T *x14 = (real_T*) ssGetOutputPortSignal(S,13);
-	real_T *x15 = (real_T*) ssGetOutputPortSignal(S,14);
-	real_T *x16 = (real_T*) ssGetOutputPortSignal(S,15);
-	real_T *x17 = (real_T*) ssGetOutputPortSignal(S,16);
-	real_T *x18 = (real_T*) ssGetOutputPortSignal(S,17);
-	real_T *x19 = (real_T*) ssGetOutputPortSignal(S,18);
-	real_T *x20 = (real_T*) ssGetOutputPortSignal(S,19);
-	real_T *x21 = (real_T*) ssGetOutputPortSignal(S,20);
-	real_T *x22 = (real_T*) ssGetOutputPortSignal(S,21);
-	real_T *x23 = (real_T*) ssGetOutputPortSignal(S,22);
-	real_T *x24 = (real_T*) ssGetOutputPortSignal(S,23);
-	real_T *x25 = (real_T*) ssGetOutputPortSignal(S,24);
-	real_T *x26 = (real_T*) ssGetOutputPortSignal(S,25);
-	real_T *x27 = (real_T*) ssGetOutputPortSignal(S,26);
-	real_T *x28 = (real_T*) ssGetOutputPortSignal(S,27);
-	real_T *x29 = (real_T*) ssGetOutputPortSignal(S,28);
-	real_T *x30 = (real_T*) ssGetOutputPortSignal(S,29);
-	real_T *x31 = (real_T*) ssGetOutputPortSignal(S,30);
-	real_T *x32 = (real_T*) ssGetOutputPortSignal(S,31);
-	real_T *x33 = (real_T*) ssGetOutputPortSignal(S,32);
-	real_T *x34 = (real_T*) ssGetOutputPortSignal(S,33);
-	real_T *x35 = (real_T*) ssGetOutputPortSignal(S,34);
-	real_T *x36 = (real_T*) ssGetOutputPortSignal(S,35);
-	real_T *x37 = (real_T*) ssGetOutputPortSignal(S,36);
-	real_T *x38 = (real_T*) ssGetOutputPortSignal(S,37);
-	real_T *x39 = (real_T*) ssGetOutputPortSignal(S,38);
-	real_T *x40 = (real_T*) ssGetOutputPortSignal(S,39);
-	
-	
-
-	/* Solver data */
-	static FORCENLPsolver_params params;
-	static FORCENLPsolver_output output;
-	static FORCENLPsolver_info info;	
-	solver_int32_default exitflag;
-
-	/* Extra NMPC data */
-	
-
-	/* Copy inputs */
-	for( i=0; i<3; i++)
-	{ 
-		params.xinit[i] = (double) xinit[i]; 
-	}
-
-	for( i=0; i<200; i++)
-	{ 
-		params.x0[i] = (double) x0[i]; 
-	}
-
-	for( i=0; i<120; i++)
-	{ 
-		params.all_parameters[i] = (double) all_parameters[i]; 
-	}
-
-	params.reinitialize = *reinitialize;
-
-	
-
-	
-
-    #if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* Call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			ssPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	
-
-	/* Copy outputs */
-	for( i=0; i<5; i++)
-	{ 
-		x01[i] = (real_T) output.x01[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x02[i] = (real_T) output.x02[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x03[i] = (real_T) output.x03[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x04[i] = (real_T) output.x04[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x05[i] = (real_T) output.x05[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x06[i] = (real_T) output.x06[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x07[i] = (real_T) output.x07[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x08[i] = (real_T) output.x08[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x09[i] = (real_T) output.x09[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x10[i] = (real_T) output.x10[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x11[i] = (real_T) output.x11[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x12[i] = (real_T) output.x12[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x13[i] = (real_T) output.x13[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x14[i] = (real_T) output.x14[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x15[i] = (real_T) output.x15[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x16[i] = (real_T) output.x16[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x17[i] = (real_T) output.x17[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x18[i] = (real_T) output.x18[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x19[i] = (real_T) output.x19[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x20[i] = (real_T) output.x20[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x21[i] = (real_T) output.x21[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x22[i] = (real_T) output.x22[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x23[i] = (real_T) output.x23[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x24[i] = (real_T) output.x24[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x25[i] = (real_T) output.x25[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x26[i] = (real_T) output.x26[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x27[i] = (real_T) output.x27[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x28[i] = (real_T) output.x28[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x29[i] = (real_T) output.x29[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x30[i] = (real_T) output.x30[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x31[i] = (real_T) output.x31[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x32[i] = (real_T) output.x32[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x33[i] = (real_T) output.x33[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x34[i] = (real_T) output.x34[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x35[i] = (real_T) output.x35[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x36[i] = (real_T) output.x36[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x37[i] = (real_T) output.x37[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x38[i] = (real_T) output.x38[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x39[i] = (real_T) output.x39[i]; 
-	}
-
-	for( i=0; i<5; i++)
-	{ 
-		x40[i] = (real_T) output.x40[i]; 
-	}
-
-	
-}
-
-
-
-
-
-/* Function: mdlTerminate =====================================================
- * Abstract:
- *    In this function, you should perform any actions that are necessary
- *    at the termination of a simulation.  For example, if memory was
- *    allocated in mdlStart, this is the place to free it.
- */
-static void mdlTerminate(SimStruct *S)
-{
-}
-#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
-#include "simulink.c"      /* MEX-file interface mechanism */
-#else
-#include "cg_sfun.h"       /* Code generation registration function */
-#endif
-
-
Index: model/FORCENLPsolver/FORCENLPsolver_model.h
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_model.h b/model/FORCENLPsolver/FORCENLPsolver_model.h
deleted file mode 100644
--- a/model/FORCENLPsolver/FORCENLPsolver_model.h	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,53 +0,0 @@
-
-
-#ifndef FORCENLPSOLVER_MODEL_H
-#include "include/FORCENLPsolver.h"
-#define FORCENLPSOLVER_MODEL_H
-/* This file was automatically generated by CasADi.
-   The CasADi copyright holders make no ownership claim of its contents. */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef casadi_real
-#define casadi_real FORCENLPsolver_float
-#endif
-
-#ifndef casadi_int
-#define casadi_int solver_int32_default
-#endif
-
-int FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_inequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_inequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dinequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_out(casadi_int i);
-int FORCENLPsolver_dinequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_inequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_inequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-int FORCENLPsolver_dinequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem);
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_out(casadi_int i);
-int FORCENLPsolver_dinequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w);
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-#endif
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,446 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_double(double *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyMArrayToC_double(double *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double) (*src++) ;
-    }
-}
-
-void copyMValueToC_double(double * src, double * dest)
-{
-	*dest = (double) *src;
-}
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver_int(FORCENLPsolver_int *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyMArrayToC_FORCENLPsolver_int(double *src, FORCENLPsolver_int *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_int) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver_int(double * src, FORCENLPsolver_int * dest)
-{
-	*dest = (FORCENLPsolver_int) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-/* Some memory for mex-function */
-static FORCENLPsolver_params params;
-static FORCENLPsolver_output output;
-static FORCENLPsolver_info info;
-
-/* THE mex-function */
-void mexFunction( solver_int32_default nlhs, mxArray *plhs[], solver_int32_default nrhs, const mxArray *prhs[] )  
-{
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* define variables */	
-	mxArray *par;
-	mxArray *outvar;
-	const mxArray *PARAMS = prhs[0]; 
-	double *pvalue;
-	solver_int32_default i;
-	solver_int32_default exitflag;
-	const solver_int8_default *fname;
-	const solver_int8_default *outputnames[40] = {"x01","x02","x03","x04","x05","x06","x07","x08","x09","x10","x11","x12","x13","x14","x15","x16","x17","x18","x19","x20","x21","x22","x23","x24","x25","x26","x27","x28","x29","x30","x31","x32","x33","x34","x35","x36","x37","x38","x39","x40"};
-	const solver_int8_default *infofields[7] = { "it", "res_eq", "rsnorm", "pobj", "solvetime",  "fevalstime", "QPtime"};
-	
-	/* Check for proper number of arguments */
-    if (nrhs != 1)
-	{
-		mexErrMsgTxt("This function requires exactly 1 input: PARAMS struct.\nType 'help FORCENLPsolver_mex' for details.");
-	}    
-	if (nlhs > 3) 
-	{
-        mexErrMsgTxt("This function returns at most 3 outputs.\nType 'help FORCENLPsolver_mex' for details.");
-    }
-
-	/* Check whether params is actually a structure */
-	if( !mxIsStruct(PARAMS) ) 
-	{
-		mexErrMsgTxt("PARAMS must be a structure.");
-	}
-	 
-
-	/* copy parameters into the right location */
-	par = mxGetField(PARAMS, 0, "xinit");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.xinit not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.xinit must be a double.");
-    }
-    if( mxGetM(par) != 3 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.xinit must be of size [3 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.xinit,3);
-
-	}
-	par = mxGetField(PARAMS, 0, "x0");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.x0 not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.x0 must be a double.");
-    }
-    if( mxGetM(par) != 200 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.x0 must be of size [200 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.x0,200);
-
-	}
-	par = mxGetField(PARAMS, 0, "all_parameters");
-#ifdef MEXARGMUENTCHECKS
-    if( par == NULL )	
-	{
-        mexErrMsgTxt("PARAMS.all_parameters not found");
-    }
-    if( !mxIsDouble(par) )
-    {
-    mexErrMsgTxt("PARAMS.all_parameters must be a double.");
-    }
-    if( mxGetM(par) != 120 || mxGetN(par) != 1 ) 
-	{
-    mexErrMsgTxt("PARAMS.all_parameters must be of size [120 x 1]");
-    }
-#endif	 
-	if ( (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMArrayToC_double(mxGetPr(par), params.all_parameters,120);
-
-	}
-	par = mxGetField(PARAMS, 0, "reinitialize");
-	if ( (par != NULL) && (mxGetN(par) != 0) && (mxGetM(par) != 0) )
-	{
-		copyMValueToC_FORCENLPsolver_int(mxGetPr(par), &params.reinitialize);
-
-	}
-
-
-
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp, pt2function_FORCENLPsolver);
-	
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			mexPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	/* copy output to matlab arrays */
-	plhs[0] = mxCreateStructMatrix(1, 1, 40, outputnames);
-		outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x01, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x01", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x02, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x02", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x03, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x03", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x04, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x04", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x05, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x05", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x06, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x06", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x07, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x07", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x08, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x08", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x09, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x09", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x10, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x10", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x11, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x11", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x12, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x12", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x13, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x13", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x14, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x14", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x15, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x15", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x16, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x16", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x17, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x17", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x18, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x18", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x19, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x19", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x20, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x20", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x21, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x21", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x22, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x22", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x23, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x23", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x24, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x24", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x25, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x25", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x26, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x26", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x27, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x27", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x28, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x28", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x29, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x29", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x30, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x30", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x31, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x31", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x32, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x32", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x33, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x33", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x34, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x34", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x35, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x35", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x36, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x36", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x37, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x37", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x38, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x38", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x39, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x39", outvar);
-
-	outvar = mxCreateDoubleMatrix(5, 1, mxREAL);
-	copyCArrayToM_double( output.x40, mxGetPr(outvar), 5);
-	mxSetField(plhs[0], 0, "x40", outvar);
-
-
-
-	/* copy exitflag */
-	if( nlhs > 1 )
-	{
-	plhs[1] = mxCreateDoubleMatrix(1, 1, mxREAL);
-	*mxGetPr(plhs[1]) = (double)exitflag;
-	}
-
-	/* copy info struct */
-	if( nlhs > 2 )
-	{
-	        plhs[2] = mxCreateStructMatrix(1, 1, 7, infofields);
-        
-		/* iterations */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = (double)info.it;
-		mxSetField(plhs[2], 0, "it", outvar);
-
-		/* res_eq */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.res_eq;
-		mxSetField(plhs[2], 0, "res_eq", outvar);
-
-		/* rsnorm */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.rsnorm;
-		mxSetField(plhs[2], 0, "rsnorm", outvar);
-
-		/* pobj */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.pobj;
-		mxSetField(plhs[2], 0, "pobj", outvar);
-
-		/* solver time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.solvetime;
-		mxSetField(plhs[2], 0, "solvetime", outvar);
-
-		/* fevals time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.fevalstime;
-		mxSetField(plhs[2], 0, "fevalstime", outvar);
-		
-		/* QP time */
-		outvar = mxCreateDoubleMatrix(1, 1, mxREAL);
-		*mxGetPr(outvar) = info.QPtime;
-		mxSetField(plhs[2], 0, "QPtime", outvar);		
-
-	}
-}
Index: model/FORCENLPsolver/FORCENLPsolver_model.c
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_model.c b/model/FORCENLPsolver/FORCENLPsolver_model.c
deleted file mode 100644
--- a/model/FORCENLPsolver/FORCENLPsolver_model.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,1195 +0,0 @@
-/* This file was automatically generated by CasADi.
-   The CasADi copyright holders make no ownership claim of its contents. */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* How to prefix internal symbols */
-#ifdef CASADI_CODEGEN_PREFIX
-  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
-  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
-  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
-#else
-  #define CASADI_PREFIX(ID) FORCENLPsolver_model_ ## ID
-#endif
-
-#include <math.h> 
-#include "FORCENLPsolver_model.h"
-
-#ifndef casadi_real
-#define casadi_real FORCENLPsolver_float
-#endif
-
-#ifndef casadi_int
-#define casadi_int solver_int32_default
-#endif
-
-/* Add prefix to internal symbols */
-#define casadi_f0 CASADI_PREFIX(f0)
-#define casadi_f1 CASADI_PREFIX(f1)
-#define casadi_f2 CASADI_PREFIX(f2)
-#define casadi_f3 CASADI_PREFIX(f3)
-#define casadi_f4 CASADI_PREFIX(f4)
-#define casadi_f5 CASADI_PREFIX(f5)
-#define casadi_f6 CASADI_PREFIX(f6)
-#define casadi_f7 CASADI_PREFIX(f7)
-#define casadi_f8 CASADI_PREFIX(f8)
-#define casadi_f9 CASADI_PREFIX(f9)
-#define casadi_s0 CASADI_PREFIX(s0)
-#define casadi_s1 CASADI_PREFIX(s1)
-#define casadi_s2 CASADI_PREFIX(s2)
-#define casadi_s3 CASADI_PREFIX(s3)
-#define casadi_s4 CASADI_PREFIX(s4)
-#define casadi_s5 CASADI_PREFIX(s5)
-#define casadi_s6 CASADI_PREFIX(s6)
-#define casadi_sq CASADI_PREFIX(sq)
-
-/* Symbol visibility in DLLs */
-#if 0
-  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-    #if defined(STATIC_LINKED)
-      #define CASADI_SYMBOL_EXPORT
-    #else
-      #define __declspec(dllexport)
-    #endif
-  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
-    #define __attribute__ ((visibility ("default")))
-  #else
-    #define CASADI_SYMBOL_EXPORT
-  #endif
-#endif
-
-casadi_real casadi_sq(casadi_real x) { return x*x;}
-
-static const casadi_int casadi_s0[9] = {5, 1, 0, 5, 0, 1, 2, 3, 4};
-static const casadi_int casadi_s1[7] = {3, 1, 0, 3, 0, 1, 2};
-static const casadi_int casadi_s2[5] = {1, 1, 0, 1, 0};
-static const casadi_int casadi_s3[12] = {1, 5, 0, 1, 2, 3, 4, 4, 0, 0, 0, 0};
-static const casadi_int casadi_s4[18] = {3, 5, 0, 2, 5, 6, 7, 10, 0, 1, 0, 1, 2, 0, 1, 0, 1, 2};
-static const casadi_int casadi_s5[10] = {1, 5, 0, 0, 0, 1, 2, 2, 0, 0};
-static const casadi_int casadi_s6[13] = {1, 5, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0};
-
-/* FORCENLPsolver_objective_0:(i0[5],i1[3])->(o0) */
-static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
-  a0=100.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a3=(a3*a1);
-  a1=arg[0]? arg[0][3] : 0;
-  a2=arg[1]? arg[1][1] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=casadi_sq(a1);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][1] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][0]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_objective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f0(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_objective_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_objective_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_objective_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_0_release(int mem) {
-}
-
-void FORCENLPsolver_objective_0_incref(void) {
-}
-
-void FORCENLPsolver_objective_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_objective_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_objective_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_objective_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_objective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dobjective_0:(i0[5],i1[3])->(o0[1x5,4nz]) */
-static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][0]=a1;
-  a1=arg[0]? arg[0][1] : 0;
-  a1=(a1+a1);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=100.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  a3=arg[0]? arg[0][3] : 0;
-  a1=arg[1]? arg[1][1] : 0;
-  a2=(a3-a1);
-  a2=(a0*a2);
-  a3=(a3-a1);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][3]=a2;
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f1(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dobjective_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dobjective_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_0_release(int mem) {
-}
-
-void FORCENLPsolver_dobjective_0_incref(void) {
-}
-
-void FORCENLPsolver_dobjective_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dobjective_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dobjective_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dobjective_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s3;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dobjective_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dynamics_0:(i0[5],i1[3])->(o0[3]) */
-static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a2, a3, a4, a5, a6, a7, a8, a9;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=8.3333333333333339e-004;
-  a2=arg[0]? arg[0][0] : 0;
-  a3=arg[0]? arg[0][4] : 0;
-  a4=cos(a3);
-  a4=(a2*a4);
-  a5=2.;
-  a6=2.5000000000000001e-003;
-  a7=arg[0]? arg[0][1] : 0;
-  a8=(a6*a7);
-  a8=(a3+a8);
-  a9=cos(a8);
-  a9=(a2*a9);
-  a9=(a5*a9);
-  a4=(a4+a9);
-  a6=(a6*a7);
-  a6=(a3+a6);
-  a9=cos(a6);
-  a9=(a2*a9);
-  a9=(a5*a9);
-  a4=(a4+a9);
-  a9=5.0000000000000001e-003;
-  a9=(a9*a7);
-  a9=(a3+a9);
-  a10=cos(a9);
-  a10=(a2*a10);
-  a4=(a4+a10);
-  a4=(a1*a4);
-  a0=(a0+a4);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
-  a4=sin(a3);
-  a4=(a2*a4);
-  a8=sin(a8);
-  a8=(a2*a8);
-  a8=(a5*a8);
-  a4=(a4+a8);
-  a6=sin(a6);
-  a6=(a2*a6);
-  a6=(a5*a6);
-  a4=(a4+a6);
-  a9=sin(a9);
-  a2=(a2*a9);
-  a4=(a4+a2);
-  a4=(a1*a4);
-  a0=(a0+a4);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=(a5*a7);
-  a0=(a7+a0);
-  a5=(a5*a7);
-  a0=(a0+a5);
-  a0=(a0+a7);
-  a1=(a1*a0);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_dynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f2(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dynamics_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dynamics_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dynamics_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dynamics_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dynamics_0_release(int mem) {
-}
-
-void FORCENLPsolver_dynamics_0_incref(void) {
-}
-
-void FORCENLPsolver_dynamics_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dynamics_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dynamics_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dynamics_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dynamics_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dynamics_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dynamics_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s1;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_ddynamics_0:(i0[5],i1[3])->(o0[3x5,10nz]) */
-static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a10, a11, a12, a13, a2, a3, a4, a5, a6, a7, a8, a9;
-  a0=8.3333333333333339e-004;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=cos(a1);
-  a3=2.;
-  a4=2.5000000000000001e-003;
-  a5=arg[0]? arg[0][1] : 0;
-  a6=(a4*a5);
-  a6=(a1+a6);
-  a7=cos(a6);
-  a7=(a3*a7);
-  a2=(a2+a7);
-  a7=(a4*a5);
-  a7=(a1+a7);
-  a8=cos(a7);
-  a8=(a3*a8);
-  a2=(a2+a8);
-  a8=5.0000000000000001e-003;
-  a5=(a8*a5);
-  a5=(a1+a5);
-  a9=cos(a5);
-  a2=(a2+a9);
-  a2=(a0*a2);
-  if (res[0]!=0) res[0][0]=a2;
-  a2=sin(a1);
-  a9=sin(a6);
-  a9=(a3*a9);
-  a2=(a2+a9);
-  a9=sin(a7);
-  a9=(a3*a9);
-  a2=(a2+a9);
-  a9=sin(a5);
-  a2=(a2+a9);
-  a2=(a0*a2);
-  if (res[0]!=0) res[0][1]=a2;
-  a2=arg[0]? arg[0][0] : 0;
-  a9=sin(a6);
-  a10=(a4*a9);
-  a10=(a2*a10);
-  a10=(a3*a10);
-  a11=sin(a7);
-  a12=(a4*a11);
-  a12=(a2*a12);
-  a12=(a3*a12);
-  a10=(a10+a12);
-  a12=sin(a5);
-  a13=(a8*a12);
-  a13=(a2*a13);
-  a10=(a10+a13);
-  a10=(a0*a10);
-  a10=(-a10);
-  if (res[0]!=0) res[0][2]=a10;
-  a6=cos(a6);
-  a10=(a4*a6);
-  a10=(a2*a10);
-  a10=(a3*a10);
-  a7=cos(a7);
-  a4=(a4*a7);
-  a4=(a2*a4);
-  a4=(a3*a4);
-  a10=(a10+a4);
-  a5=cos(a5);
-  a4=(a8*a5);
-  a4=(a2*a4);
-  a10=(a10+a4);
-  a10=(a0*a10);
-  if (res[0]!=0) res[0][3]=a10;
-  if (res[0]!=0) res[0][4]=a8;
-  a8=1.;
-  if (res[0]!=0) res[0][5]=a8;
-  if (res[0]!=0) res[0][6]=a8;
-  a10=sin(a1);
-  a10=(a2*a10);
-  a9=(a2*a9);
-  a9=(a3*a9);
-  a10=(a10+a9);
-  a11=(a2*a11);
-  a11=(a3*a11);
-  a10=(a10+a11);
-  a12=(a2*a12);
-  a10=(a10+a12);
-  a10=(a0*a10);
-  a10=(-a10);
-  if (res[0]!=0) res[0][7]=a10;
-  a1=cos(a1);
-  a1=(a2*a1);
-  a6=(a2*a6);
-  a6=(a3*a6);
-  a1=(a1+a6);
-  a7=(a2*a7);
-  a3=(a3*a7);
-  a1=(a1+a3);
-  a2=(a2*a5);
-  a1=(a1+a2);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][8]=a0;
-  if (res[0]!=0) res[0][9]=a8;
-  return 0;
-}
-
-int FORCENLPsolver_ddynamics_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f3(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_ddynamics_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_ddynamics_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_ddynamics_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_ddynamics_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_ddynamics_0_release(int mem) {
-}
-
-void FORCENLPsolver_ddynamics_0_incref(void) {
-}
-
-void FORCENLPsolver_ddynamics_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_ddynamics_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_ddynamics_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_ddynamics_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_ddynamics_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_ddynamics_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_ddynamics_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s4;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_ddynamics_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_inequalities_0:(i0[5],i1[3])->(o0) */
-static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=casadi_sq(a0);
-  a1=arg[0]? arg[0][3] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][0]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f4(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_inequalities_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_inequalities_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_0_release(int mem) {
-}
-
-void FORCENLPsolver_inequalities_0_incref(void) {
-}
-
-void FORCENLPsolver_inequalities_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_inequalities_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_inequalities_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_inequalities_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_inequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dinequalities_0:(i0[5],i1[3])->(o0[1x5,2nz]) */
-static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][1]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f5(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dinequalities_0_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_0_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_0_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dinequalities_0_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_0_release(int mem) {
-}
-
-void FORCENLPsolver_dinequalities_0_incref(void) {
-}
-
-void FORCENLPsolver_dinequalities_0_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dinequalities_0_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dinequalities_0_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dinequalities_0_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_0_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_0_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_0_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s5;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dinequalities_0_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_objective_1:(i0[5],i1[3])->(o0) */
-static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3, a4;
-  a0=500.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a3=(a3*a1);
-  a1=arg[0]? arg[0][3] : 0;
-  a2=arg[1]? arg[1][1] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=100.;
-  a1=arg[0]? arg[0][4] : 0;
-  a2=arg[1]? arg[1][2] : 0;
-  a4=(a1-a2);
-  a0=(a0*a4);
-  a1=(a1-a2);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=casadi_sq(a1);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  a1=arg[0]? arg[0][1] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0*a1);
-  a3=(a3+a0);
-  if (res[0]!=0) res[0][0]=a3;
-  return 0;
-}
-
-int FORCENLPsolver_objective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f6(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_objective_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_objective_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_objective_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_objective_1_release(int mem) {
-}
-
-void FORCENLPsolver_objective_1_incref(void) {
-}
-
-void FORCENLPsolver_objective_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_objective_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_objective_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_objective_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_objective_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_objective_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_objective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dobjective_1:(i0[5],i1[3])->(o0[1x5]) */
-static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1, a2, a3;
-  a0=1.0000000000000001e-001;
-  a1=arg[0]? arg[0][0] : 0;
-  a1=(a1+a1);
-  a1=(a0*a1);
-  if (res[0]!=0) res[0][0]=a1;
-  a1=arg[0]? arg[0][1] : 0;
-  a1=(a1+a1);
-  a0=(a0*a1);
-  if (res[0]!=0) res[0][1]=a0;
-  a0=500.;
-  a1=arg[0]? arg[0][2] : 0;
-  a2=arg[1]? arg[1][0] : 0;
-  a3=(a1-a2);
-  a3=(a0*a3);
-  a1=(a1-a2);
-  a1=(a0*a1);
-  a3=(a3+a1);
-  if (res[0]!=0) res[0][2]=a3;
-  a3=arg[0]? arg[0][3] : 0;
-  a1=arg[1]? arg[1][1] : 0;
-  a2=(a3-a1);
-  a2=(a0*a2);
-  a3=(a3-a1);
-  a0=(a0*a3);
-  a2=(a2+a0);
-  if (res[0]!=0) res[0][3]=a2;
-  a2=100.;
-  a0=arg[0]? arg[0][4] : 0;
-  a3=arg[1]? arg[1][2] : 0;
-  a1=(a0-a3);
-  a1=(a2*a1);
-  a0=(a0-a3);
-  a2=(a2*a0);
-  a1=(a1+a2);
-  if (res[0]!=0) res[0][4]=a1;
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f7(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dobjective_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dobjective_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dobjective_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dobjective_1_release(int mem) {
-}
-
-void FORCENLPsolver_dobjective_1_incref(void) {
-}
-
-void FORCENLPsolver_dobjective_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dobjective_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dobjective_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dobjective_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dobjective_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dobjective_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s6;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dobjective_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_inequalities_1:(i0[5],i1[3])->(o0) */
-static int casadi_f8(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=casadi_sq(a0);
-  a1=arg[0]? arg[0][3] : 0;
-  a1=casadi_sq(a1);
-  a0=(a0+a1);
-  if (res[0]!=0) res[0][0]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f8(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_inequalities_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_inequalities_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_inequalities_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_inequalities_1_release(int mem) {
-}
-
-void FORCENLPsolver_inequalities_1_incref(void) {
-}
-
-void FORCENLPsolver_inequalities_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_inequalities_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_inequalities_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_inequalities_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_inequalities_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_inequalities_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s2;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_inequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-/* FORCENLPsolver_dinequalities_1:(i0[5],i1[3])->(o0[1x5,2nz]) */
-static int casadi_f9(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
-  casadi_real a0, a1;
-  a0=arg[0]? arg[0][2] : 0;
-  a1=5.;
-  a0=(a0-a1);
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][0]=a0;
-  a0=arg[0]? arg[0][3] : 0;
-  a0=(a0+a0);
-  if (res[0]!=0) res[0][1]=a0;
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
-  return casadi_f9(arg, res, iw, w, mem);
-}
-
-int FORCENLPsolver_dinequalities_1_alloc_mem(void) {
-  return 0;
-}
-
-int FORCENLPsolver_dinequalities_1_init_mem(int mem) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_1_free_mem(int mem) {
-}
-
-int FORCENLPsolver_dinequalities_1_checkout(void) {
-  return 0;
-}
-
-void FORCENLPsolver_dinequalities_1_release(int mem) {
-}
-
-void FORCENLPsolver_dinequalities_1_incref(void) {
-}
-
-void FORCENLPsolver_dinequalities_1_decref(void) {
-}
-
-casadi_int FORCENLPsolver_dinequalities_1_n_in(void) { return 2;}
-
-casadi_int FORCENLPsolver_dinequalities_1_n_out(void) { return 1;}
-
-casadi_real FORCENLPsolver_dinequalities_1_default_in(casadi_int i){
-  switch (i) {
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_1_name_in(casadi_int i){
-  switch (i) {
-    case 0: return "i0";
-    case 1: return "i1";
-    default: return 0;
-  }
-}
-
-const char* FORCENLPsolver_dinequalities_1_name_out(casadi_int i){
-  switch (i) {
-    case 0: return "o0";
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_in(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s0;
-    case 1: return casadi_s1;
-    default: return 0;
-  }
-}
-
-const casadi_int* FORCENLPsolver_dinequalities_1_sparsity_out(casadi_int i) {
-  switch (i) {
-    case 0: return casadi_s5;
-    default: return 0;
-  }
-}
-
-int FORCENLPsolver_dinequalities_1_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
-  if (sz_arg) *sz_arg = 2;
-  if (sz_res) *sz_res = 1;
-  if (sz_iw) *sz_iw = 0;
-  if (sz_w) *sz_w = 0;
-  return 0;
-}
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
Index: model/FORCENLPsolver/python_static_interface.template.c
===================================================================
diff --git a/model/FORCENLPsolver/python_static_interface.template.c b/model/FORCENLPsolver/python_static_interface.template.c
deleted file mode 100644
--- a/model/FORCENLPsolver/python_static_interface.template.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,31 +0,0 @@
-/* This template is used when statically linking a solver and its external
- * evaluation functions (for nonlinearties). It simply exports a function that
- * is essentially a closure around the solver function, with the last argument
- * (the pointer to the external evaluation function) fixed.
- *
- * The template is used by setting the following preprocessor macros:
- *  - FORCENLPsolver
- *  - "include/FORCENLPsolver.h"
- *  - FORCENLPsolver_casadi2forces
- *  - FORCENLPsolver_interface
- *
- * Compare also the MEX interface, which exists for a similar purpose in the
- * MATLAB client. */
-
-#define CONCAT(x, y) x ## y
-#define CONCATENATE(x, y) CONCAT(x, y)
-#define SOLVER_FLOAT CONCATENATE(FORCENLPsolver, _float)
-#define SOLVER_FUN_NAME CONCATENATE(FORCENLPsolver, _solve)
-
-#include "include/FORCENLPsolver.h"
-
-/* Header of external evaluation function */
-void FORCENLPsolver_casadi2forces(SOLVER_FLOAT *x, SOLVER_FLOAT *y, SOLVER_FLOAT *l,
-                   SOLVER_FLOAT *p, SOLVER_FLOAT *f, SOLVER_FLOAT *nabla_f,
-                   SOLVER_FLOAT *c, SOLVER_FLOAT *nabla_c, SOLVER_FLOAT *h,
-                   SOLVER_FLOAT *nabla_h, SOLVER_FLOAT *hess,
-                   solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-
-int FORCENLPsolver_interface(void *params, void *outputs, void *info, FILE *fp) {
-    return SOLVER_FUN_NAME(params, outputs, info, fp, &FORCENLPsolver_casadi2forces);
-}
Index: model/FORCENLPsolver/FORCENLPsolver_interface.c
===================================================================
diff --git a/model/FORCENLPsolver/FORCENLPsolver_interface.c b/model/FORCENLPsolver/FORCENLPsolver_interface.c
deleted file mode 100644
--- a/model/FORCENLPsolver/FORCENLPsolver_interface.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,202 +0,0 @@
-/*
- * CasADi to FORCESPRO Template - missing information to be filled in by createCasadi.m 
- * (C) embotech AG, Zurich, Switzerland, 2013-2021. All rights reserved.
- *
- * This file is part of the FORCESPRO client, and carries the same license.
- */ 
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-    
-#include "include/FORCENLPsolver.h"
-
-#ifndef NULL
-#define NULL ((void *) 0)
-#endif
-
-#include "FORCENLPsolver_model.h"
-
-
-
-/* copies data from sparse matrix into a dense one */
-static void sparse2fullcopy(solver_int32_default nrow, solver_int32_default ncol, const solver_int32_default *colidx, const solver_int32_default *row, FORCENLPsolver_callback_float *data, FORCENLPsolver_float *out)
-{
-    solver_int32_default i, j;
-    
-    /* copy data into dense matrix */
-    for(i=0; i<ncol; i++)
-    {
-        for(j=colidx[i]; j<colidx[i+1]; j++)
-        {
-            out[i*nrow + row[j]] = ((FORCENLPsolver_float) data[j]);
-        }
-    }
-}
-
-
-
-
-/* CasADi to FORCESPRO interface */
-extern void FORCENLPsolver_casadi2forces(FORCENLPsolver_float *x,        /* primal vars                                         */
-                                 FORCENLPsolver_float *y,        /* eq. constraint multiplers                           */
-                                 FORCENLPsolver_float *l,        /* ineq. constraint multipliers                        */
-                                 FORCENLPsolver_float *p,        /* parameters                                          */
-                                 FORCENLPsolver_float *f,        /* objective function (scalar)                         */
-                                 FORCENLPsolver_float *nabla_f,  /* gradient of objective function                      */
-                                 FORCENLPsolver_float *c,        /* dynamics                                            */
-                                 FORCENLPsolver_float *nabla_c,  /* Jacobian of the dynamics (column major)             */
-                                 FORCENLPsolver_float *h,        /* inequality constraints                              */
-                                 FORCENLPsolver_float *nabla_h,  /* Jacobian of inequality constraints (column major)   */
-                                 FORCENLPsolver_float *hess,     /* Hessian (column major)                              */
-                                 solver_int32_default stage,     /* stage number (0 indexed)                           */
-								 solver_int32_default iteration, /* iteration number of solver                         */
-								 solver_int32_default threadID   /* Id of caller thread                                */)
-{
-    /* CasADi input and output arrays */
-    const FORCENLPsolver_callback_float *in[4];
-    FORCENLPsolver_callback_float *out[7];
-	
-
-	/* Allocate working arrays for CasADi */
-	FORCENLPsolver_float w[14];
-	
-    /* temporary storage for CasADi sparse output */
-    FORCENLPsolver_callback_float this_f;
-    FORCENLPsolver_float nabla_f_sparse[5];
-    FORCENLPsolver_float h_sparse[1];
-    FORCENLPsolver_float nabla_h_sparse[2];
-    FORCENLPsolver_float c_sparse[3];
-    FORCENLPsolver_float nabla_c_sparse[10];
-            
-    
-    /* pointers to row and column info for 
-     * column compressed format used by CasADi */
-    solver_int32_default nrow, ncol;
-    const solver_int32_default *colind, *row;
-    
-    /* set inputs for CasADi */
-    in[0] = x;
-    in[1] = p;
-    in[2] = l;
-    in[3] = y;
-
-	if ((0 <= stage && stage <= 38))
-	{
-		
-		
-		if( &this_f )
-		{
-			out[0] = &this_f;
-			FORCENLPsolver_objective_0(in, out, NULL, w, 0);
-		}
-		
-		if( nabla_f )
-		{
-			out[0] = nabla_f_sparse;
-			FORCENLPsolver_dobjective_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dobjective_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dobjective_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dobjective_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);
-		}
-		
-		if( c )
-		{
-			out[0] = c_sparse;
-			FORCENLPsolver_dynamics_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dynamics_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dynamics_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dynamics_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, c_sparse, c);
-		}
-		
-		if( nabla_c )
-		{
-			out[0] = nabla_c_sparse;
-			FORCENLPsolver_ddynamics_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_ddynamics_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_ddynamics_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_ddynamics_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_c_sparse, nabla_c);
-		}
-		
-		if( h )
-		{
-			out[0] = h_sparse;
-			FORCENLPsolver_inequalities_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_inequalities_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_inequalities_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_inequalities_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_inequalities_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, h_sparse, h);
-		}
-		
-		if( nabla_h )
-		{
-			out[0] = nabla_h_sparse;
-			FORCENLPsolver_dinequalities_0(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dinequalities_0_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dinequalities_0_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dinequalities_0_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dinequalities_0_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_h_sparse, nabla_h);
-		}
-	}
-	if ((39 == stage))
-	{
-		
-		
-		if( &this_f )
-		{
-			out[0] = &this_f;
-			FORCENLPsolver_objective_1(in, out, NULL, w, 0);
-		}
-		
-		if( nabla_f )
-		{
-			out[0] = nabla_f_sparse;
-			FORCENLPsolver_dobjective_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dobjective_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dobjective_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dobjective_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_f_sparse, nabla_f);
-		}
-		
-		if( h )
-		{
-			out[0] = h_sparse;
-			FORCENLPsolver_inequalities_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_inequalities_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_inequalities_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_inequalities_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_inequalities_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, h_sparse, h);
-		}
-		
-		if( nabla_h )
-		{
-			out[0] = nabla_h_sparse;
-			FORCENLPsolver_dinequalities_1(in, out, NULL, w, 0);
-			nrow = FORCENLPsolver_dinequalities_1_sparsity_out(0)[0];
-			ncol = FORCENLPsolver_dinequalities_1_sparsity_out(0)[1];
-			colind = FORCENLPsolver_dinequalities_1_sparsity_out(0) + 2;
-			row = FORCENLPsolver_dinequalities_1_sparsity_out(0) + 2 + (ncol + 1);
-			sparse2fullcopy(nrow, ncol, colind, row, nabla_h_sparse, nabla_h);
-		}
-	}
-    
-    /* add to objective */
-    if (f != NULL)
-    {
-        *f += ((FORCENLPsolver_float) this_f);
-    }
-}
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
Index: model/FORCENLPsolver/include/FORCENLPsolver.h
===================================================================
diff --git a/model/FORCENLPsolver/include/FORCENLPsolver.h b/model/FORCENLPsolver/include/FORCENLPsolver.h
deleted file mode 100644
--- a/model/FORCENLPsolver/include/FORCENLPsolver.h	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,315 +0,0 @@
-#ifndef FORCENLPsolver_H
-#define FORCENLPsolver_H
-/* Generated by FORCESPRO v5.1.0 on Wednesday, March 2, 2022 at 2:15:46 PM */
-
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#include <stddef.h>
-#endif
-
-
-/* DATA TYPE ------------------------------------------------------------*/
-typedef double FORCENLPsolver_float;
-typedef double FORCENLPsolver_callback_float;
-typedef double FORCENLPsolverinterface_float;
-typedef int FORCENLPsolver_int;
-
-#ifndef SOLVER_STANDARD_TYPES
-#define SOLVER_STANDARD_TYPES
-
-typedef signed char solver_int8_signed;
-typedef unsigned char solver_int8_unsigned;
-typedef char solver_int8_default;
-typedef signed short int solver_int16_signed;
-typedef unsigned short int solver_int16_unsigned;
-typedef short int solver_int16_default;
-typedef signed int solver_int32_signed;
-typedef unsigned int solver_int32_unsigned;
-typedef int solver_int32_default;
-typedef signed long long int solver_int64_signed;
-typedef unsigned long long int solver_int64_unsigned;
-typedef long long int solver_int64_default;
-
-#endif
-
-/* SOLVER SETTINGS ------------------------------------------------------*/
-
-/* MISRA-C compliance */
-#ifndef MISRA_C_FORCENLPsolver
-#define MISRA_C_FORCENLPsolver (0)
-#endif
-
-/* restrict code */
-#ifndef RESTRICT_CODE_FORCENLPsolver
-#define RESTRICT_CODE_FORCENLPsolver (0)
-#endif
-
-/* print level */
-#ifndef SET_PRINTLEVEL_FORCENLPsolver
-#define SET_PRINTLEVEL_FORCENLPsolver    (0)
-#endif
-
-/* timing */
-#ifndef SET_TIMING_FORCENLPsolver
-#define SET_TIMING_FORCENLPsolver    (1)
-#endif
-
-/* Numeric Warnings */
-/* #define PRINTNUMERICALWARNINGS */
-
-/* maximum number of iterations  */
-#define SET_MAXIT_FORCENLPsolver			(200)	 
-
-/* desired maximum residual on equality constraints */
-#define SET_ACC_RESEQ_FORCENLPsolver		(FORCENLPsolver_float)(1E-06)
-
-
-/* RETURN CODES----------------------------------------------------------*/
-/* solver has converged within desired accuracy */
-#define OPTIMAL_FORCENLPsolver      (1)
-
-/* maximum number of iterations has been reached */
-#define MAXITREACHED_FORCENLPsolver (0)
-
-/* solver has stopped due to a timeout */
-#define TIMEOUT_FORCENLPsolver   (2)
-
-/* NaN encountered in function evaluations */
-#define BADFUNCEVAL_FORCENLPsolver  (-6)
-
-/* no progress in method possible */
-#define NOPROGRESS_FORCENLPsolver   (-7)
-
-/* regularization error */
-#define REGULARIZATION_ERROR_FORCENLPsolver   (-9)
-
-/* invalid values in parameters */
-#define PARAM_VALUE_ERROR_FORCENLPsolver   (-11)
-
-/* too small timeout given */
-#define INVALID_TIMEOUT_FORCENLPsolver   (-12)
-
-/* error in linesearch */
-#define LINESEARCH_ERROR_FORCENLPsolver   (-13)
-
-/* thread error */
-#define THREAD_FAILURE_FORCENLPsolver  (-98)
-
-/* locking mechanism error */
-#define LOCK_FAILURE_FORCENLPsolver  (-99)
-
-/* licensing error - solver not valid on this machine */
-#define LICENSE_ERROR_FORCENLPsolver  (-100)
-
-/* qp solver error */
-#define QP_SOLVER_FAILURE_FORCENLPsolver (-8)
-
-
-/* INTEGRATORS RETURN CODE ------------*/
-/* Integrator ran successfully */
-#define INTEGRATOR_SUCCESS (11)
-/* Number of steps set by user exceeds maximum number of steps allowed */
-#define INTEGRATOR_MAXSTEPS_EXCEEDED (12)
-
-/* PARAMETERS -----------------------------------------------------------*/
-/* fill this with data before calling the solver! */
-typedef struct
-{
-	    /* vector of size 3 */
-    FORCENLPsolver_float xinit[3];
-
-    /* vector of size 200 */
-    FORCENLPsolver_float x0[200];
-
-    /* vector of size 120 */
-    FORCENLPsolver_float all_parameters[120];
-
-    /* scalar */
-    FORCENLPsolver_int reinitialize;
-
-
-} FORCENLPsolver_params;
-
-
-/* OUTPUTS --------------------------------------------------------------*/
-/* the desired variables are put here by the solver */
-typedef struct
-{
-	    /* vector of size 5 */
-    FORCENLPsolver_float x01[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x02[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x03[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x04[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x05[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x06[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x07[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x08[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x09[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x10[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x11[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x12[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x13[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x14[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x15[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x16[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x17[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x18[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x19[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x20[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x21[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x22[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x23[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x24[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x25[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x26[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x27[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x28[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x29[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x30[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x31[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x32[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x33[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x34[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x35[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x36[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x37[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x38[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x39[5];
-
-    /* vector of size 5 */
-    FORCENLPsolver_float x40[5];
-
-
-} FORCENLPsolver_output;
-
-
-/* SOLVER INFO ----------------------------------------------------------*/
-/* diagnostic data from last interior point step */
-typedef struct
-{
-	/* iteration number */
-	solver_int32_default it;
-
-	/* inf-norm of equality constraint residuals */
-	FORCENLPsolver_float res_eq;
-
-	/* norm of stationarity condition */
-	FORCENLPsolver_float rsnorm;
-
-	/* primal objective */
-	FORCENLPsolver_float pobj;
-
-	/* total solve time */
-	FORCENLPsolver_float solvetime;
-
-	/* time spent in function evaluations */
-	FORCENLPsolver_float fevalstime;
-
-	/* time spent solving QPs */
-	FORCENLPsolver_float QPtime;
-} FORCENLPsolver_info;
-
-
-
-/* SOLVER FUNCTION DEFINITION -------------------------------------------*/
-/* Time of Solver Generation: (UTC) Wednesday, March 2, 2022 2:15:48 PM */
-/* User License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) (at the time of code generation) */
-/* Solver Static License expires on: (UTC) Monday, August 22, 2022 10:00:00 PM (approx.) */
-/* Solver Generation Request Id: 76f14dbb-068e-4b16-8c5e-840c976298ab */
-/* examine exitflag before using the result! */
-#ifdef __cplusplus
-extern "C" {
-#endif		
-
-typedef void(*FORCENLPsolver_extfunc)(FORCENLPsolver_float* x, FORCENLPsolver_float* y, FORCENLPsolver_float* lambda, FORCENLPsolver_float* params, FORCENLPsolver_float* pobj, FORCENLPsolver_float* g, FORCENLPsolver_float* c, FORCENLPsolver_float* Jeq, FORCENLPsolver_float* h, FORCENLPsolver_float* Jineq, FORCENLPsolver_float* H, solver_int32_default stage, solver_int32_default iterations, solver_int32_default threadID);
-
-extern solver_int32_default FORCENLPsolver_solve(FORCENLPsolver_params *params, FORCENLPsolver_output *output, FORCENLPsolver_info *info, FILE *fs, FORCENLPsolver_extfunc evalextfunctions_FORCENLPsolver);
-
-
-
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
Index: model/FORCENLPsolver/interface/FORCENLPsolver_build.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_build.py b/model/FORCENLPsolver/interface/FORCENLPsolver_build.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_build.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,62 +0,0 @@
-#FORCENLPsolver : A fast customized optimization solver.
-#
-#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-#
-#
-#This software is intended for simulation and testing purposes only. 
-#Use of this software for any commercial purpose is prohibited.
-#
-#This program is distributed in the hope that it will be useful.
-#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-#PARTICULAR PURPOSE. 
-#
-#EMBOTECH shall not have any liability for any damage arising from the use
-#of the software.
-#
-#This Agreement shall exclusively be governed by and interpreted in 
-#accordance with the laws of Switzerland, excluding its principles
-#of conflict of laws. The Courts of Zurich-City shall have exclusive 
-#jurisdiction in case of any dispute.
-#
-from distutils.ccompiler import new_compiler
-c = new_compiler()
-#from numpy.distutils.intelccompiler import IntelCCompiler
-#c = IntelCCompiler()
-
-
-import os
-import sys
-import distutils
-
-# determine source file
-sourcefile = os.path.join(os.getcwd(),"FORCENLPsolver","src","FORCENLPsolver"+".c")
-
-# determine lib file
-if sys.platform.startswith('win'):
-	libfile = os.path.join(os.getcwd(),"FORCENLPsolver","lib","FORCENLPsolver"+".lib")
-else:
-	libfile = os.path.join(os.getcwd(),"FORCENLPsolver","lib","FORCENLPsolver"+".so")	
-
-# create lib dir if it does not exist yet
-if not os.path.exists(os.path.join(os.getcwd(),"FORCENLPsolver","lib")):
-	os.makedirs(os.path.join(os.getcwd(),"FORCENLPsolver","lib"))
-								
-
-				
-# compile into object file
-objdir = os.path.join(os.getcwd(),"FORCENLPsolver","obj")
-if isinstance(c,distutils.unixccompiler.UnixCCompiler):
-	#objects = c.compile([sourcefile], output_dir=objdir, extra_preargs=['-O3','-fPIC','-fopenmp','-mavx'])
-	objects = c.compile([sourcefile], output_dir=objdir, extra_preargs=['-O3','-fPIC','-mavx'])
-	if sys.platform.startswith('linux'):
-		c.set_libraries(['rt','gomp'])
-else:
-	objects = c.compile([sourcefile], output_dir=objdir)
-
-				
-# create libraries
-libdir = os.path.join(os.getcwd(),"FORCENLPsolver","lib")
-exportsymbols = ["%s_solve" % "FORCENLPsolver"]
-c.create_static_lib(objects, "FORCENLPsolver", output_dir=libdir)
-c.link_shared_lib(objects, "FORCENLPsolver", output_dir=libdir, export_symbols=exportsymbols)
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_dynamics_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES-1) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES-1));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* c_mex;
-	mxArray* jacc_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	c_mex = mxCreateDoubleMatrix(neq, 1, mxREAL);
-	jacc_mex = mxCreateDoubleMatrix(neq, nvar, mxREAL);
-	copyCArrayToM_FORCENLPsolver(c, mxGetPr(c_mex), neq);
-	copyCArrayToM_FORCENLPsolver(jacc, mxGetPr(jacc_mex), neq*nvar);
-	plhs[0] = c_mex;
-	plhs[1] = jacc_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_inequalities_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* h_mex;
-	mxArray* jach_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	h_mex = mxCreateDoubleMatrix(dimh, 1, mxREAL);
-	jach_mex = mxCreateDoubleMatrix(dimh, nvar, mxREAL);
-	copyCArrayToM_FORCENLPsolver(h, mxGetPr(h_mex), dimh);
-	copyCArrayToM_FORCENLPsolver(jach, mxGetPr(jach_mex), dimh*nvar);
-	plhs[0] = h_mex;
-	plhs[1] = jach_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c b/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_simulinkBlockcompact.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,544 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-
-#define S_FUNCTION_LEVEL 2
-#define S_FUNCTION_NAME FORCENLPsolver_simulinkBlockcompact
-
-#include "simstruc.h"
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* include FORCESPRO functions and defs */
-#include "../include/FORCENLPsolver.h" 
-
-/* SYSTEM INCLUDES FOR TIMING ------------------------------------------ */
-
-
-#if defined(MATLAB_MEX_FILE)
-#include "tmwtypes.h"
-#include "simstruc_types.h"
-#else
-#include "rtwtypes.h"
-#endif
-
-typedef FORCENLPsolverinterface_float FORCENLPsolvernmpc_float;
-
-extern void (double *x, double *y, double *l, double *p, double *f, double *nabla_f, double *c, double *nabla_c, double *h, double *nabla_h, double *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-
-
-/*====================*
- * S-function methods *
- *====================*/
-/* Function: mdlInitializeSizes =========================================
- * Abstract:
- *   Setup sizes of the various vectors.
- */
-static void mdlInitializeSizes(SimStruct *S)
-{
-
-    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
-    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
-    ssSetNumSFcnParams(S, 0);
-    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) 
-	{
-		return; /* Parameter mismatch will be reported by Simulink */
-    }
-
-	/* initialize size of continuous and discrete states to zero */
-    ssSetNumContStates(S, 0);
-    ssSetNumDiscStates(S, 0);
-
-	/* initialize input ports - there are 4 in total */
-    if (!ssSetNumInputPorts(S, 4)) return;
-    	
-	/* Input Port 0 */
-    ssSetInputPortMatrixDimensions(S,  0, 1, 1);
-    ssSetInputPortDataType(S, 0, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 0, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/
-	
-	/* Input Port 1 */
-    ssSetInputPortMatrixDimensions(S,  1, 3, 1);
-    ssSetInputPortDataType(S, 1, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 1, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 1, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 1, 1); /*direct input signal access*/
-	
-	/* Input Port 2 */
-    ssSetInputPortMatrixDimensions(S,  2, 200, 1);
-    ssSetInputPortDataType(S, 2, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 2, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 2, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 2, 1); /*direct input signal access*/
-	
-	/* Input Port 3 */
-    ssSetInputPortMatrixDimensions(S,  3, 120, 1);
-    ssSetInputPortDataType(S, 3, SS_DOUBLE);
-    ssSetInputPortComplexSignal(S, 3, COMPLEX_NO); /* no complex signals suppported */
-    ssSetInputPortDirectFeedThrough(S, 3, 1); /* Feedthrough enabled */
-    ssSetInputPortRequiredContiguous(S, 3, 1); /*direct input signal access*/
- 
-
-
-	/* initialize output ports - there are 1 in total */
-    if (!ssSetNumOutputPorts(S, 1)) return;    
-		
-	/* Output Port 0 */
-    ssSetOutputPortMatrixDimensions(S,  0, 200, 1);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO); /* no complex signals suppported */
-
-
-	/* set sampling time */
-    ssSetNumSampleTimes(S, 1);
-
-	/* set internal memory of block */
-    ssSetNumRWork(S, 0);
-    ssSetNumIWork(S, 0);
-    ssSetNumPWork(S, 0);
-    ssSetNumModes(S, 0);
-    ssSetNumNonsampledZCs(S, 0);
-
-    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-	/* SS_OPTION_USE_TLC_WITH_ACCELERATOR removed */ 
-    /* ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
-		             SS_OPTION_WORKS_WITH_CODE_REUSE)); */
-	ssSetOptions(S, SS_OPTION_EXCEPTION_FREE_CODE );
-
-	
-}
-
-#if defined(MATLAB_MEX_FILE)
-#define MDL_SET_INPUT_PORT_DIMENSION_INFO
-static void mdlSetInputPortDimensionInfo(SimStruct        *S, 
-                                         int_T            port,
-                                         const DimsInfo_T *dimsInfo)
-{
-    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-
-#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
-#if defined(MDL_SET_OUTPUT_PORT_DIMENSION_INFO)
-static void mdlSetOutputPortDimensionInfo(SimStruct        *S, 
-                                          int_T            port, 
-                                          const DimsInfo_T *dimsInfo)
-{
-    if (!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
-}
-#endif
-# define MDL_SET_INPUT_PORT_FRAME_DATA
-static void mdlSetInputPortFrameData(SimStruct  *S, 
-                                     int_T      port,
-                                     Frame_T    frameData)
-{
-    ssSetInputPortFrameData(S, port, frameData);
-}
-/* Function: mdlInitializeSampleTimes =========================================
- * Abstract:
- *    Specifiy  the sample time.
- */
-static void mdlInitializeSampleTimes(SimStruct *S)
-{
-    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
-    ssSetOffsetTime(S, 0, 0.0);
-}
-
-#define MDL_SET_INPUT_PORT_DATA_TYPE
-static void mdlSetInputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetInputPortDataType( S, 0, dType);
-}
-#define MDL_SET_OUTPUT_PORT_DATA_TYPE
-static void mdlSetOutputPortDataType(SimStruct *S, solver_int32_default port, DTypeId dType)
-{
-    ssSetOutputPortDataType(S, 0, dType);
-}
-
-#define MDL_SET_DEFAULT_PORT_DATA_TYPES
-static void mdlSetDefaultPortDataTypes(SimStruct *S)
-{
-    ssSetInputPortDataType( S, 0, SS_DOUBLE);
-    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
-}
-
-
-
-
-
-/* Function: mdlOutputs =======================================================
- *
-*/
-static void mdlOutputs(SimStruct *S, int_T tid)
-{
-	solver_int32_default i, j, k;
-	
-	/* file pointer for printing */
-	FILE *fp = NULL;
-
-	/* Simulink data */
-	const FORCENLPsolver_int *reinitialize = (const FORCENLPsolver_int*) ssGetInputPortSignal(S,0);
-	const real_T *xinit = (const real_T*) ssGetInputPortSignal(S,1);
-	const real_T *x0 = (const real_T*) ssGetInputPortSignal(S,2);
-	const real_T *all_parameters = (const real_T*) ssGetInputPortSignal(S,3);
-	
-    real_T *outputs = (real_T*) ssGetOutputPortSignal(S,0);
-	
-	
-
-	/* Solver data */
-	static FORCENLPsolver_params params;
-	static FORCENLPsolver_output output;
-	static FORCENLPsolver_info info;	
-	solver_int32_default exitflag;
-
-	/* Extra NMPC data */
-	
-
-	/* Copy inputs */
-	for( i=0; i<3; i++)
-	{ 
-		params.xinit[i] = (double) xinit[i]; 
-	}
-
-	for( i=0; i<200; i++)
-	{ 
-		params.x0[i] = (double) x0[i]; 
-	}
-
-	for( i=0; i<120; i++)
-	{ 
-		params.all_parameters[i] = (double) all_parameters[i]; 
-	}
-
-	params.reinitialize = *reinitialize;
-
-	
-
-	
-
-    #if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Prepare file for printfs */
-        fp = fopen("stdout_temp","w+");
-		if( fp == NULL ) 
-		{
-			mexErrMsgTxt("freopen of stdout did not work.");
-		}
-		rewind(fp);
-	#endif
-
-	/* Call solver */
-	exitflag = FORCENLPsolver_solve(&params, &output, &info, fp , pt2function_FORCENLPsolver);
-
-	#if SET_PRINTLEVEL_FORCENLPsolver > 0
-		/* Read contents of printfs printed to file */
-		rewind(fp);
-		while( (i = fgetc(fp)) != EOF ) 
-		{
-			ssPrintf("%c",i);
-		}
-		fclose(fp);
-	#endif
-
-	
-
-	/* Copy outputs */
-	for( i=0; i<5; i++)
-	{ 
-		outputs[i] = (real_T) output.x01[i]; 
-	}
-
-	k=5; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x02[i]; 
-	}
-
-	k=10; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x03[i]; 
-	}
-
-	k=15; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x04[i]; 
-	}
-
-	k=20; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x05[i]; 
-	}
-
-	k=25; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x06[i]; 
-	}
-
-	k=30; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x07[i]; 
-	}
-
-	k=35; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x08[i]; 
-	}
-
-	k=40; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x09[i]; 
-	}
-
-	k=45; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x10[i]; 
-	}
-
-	k=50; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x11[i]; 
-	}
-
-	k=55; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x12[i]; 
-	}
-
-	k=60; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x13[i]; 
-	}
-
-	k=65; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x14[i]; 
-	}
-
-	k=70; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x15[i]; 
-	}
-
-	k=75; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x16[i]; 
-	}
-
-	k=80; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x17[i]; 
-	}
-
-	k=85; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x18[i]; 
-	}
-
-	k=90; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x19[i]; 
-	}
-
-	k=95; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x20[i]; 
-	}
-
-	k=100; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x21[i]; 
-	}
-
-	k=105; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x22[i]; 
-	}
-
-	k=110; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x23[i]; 
-	}
-
-	k=115; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x24[i]; 
-	}
-
-	k=120; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x25[i]; 
-	}
-
-	k=125; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x26[i]; 
-	}
-
-	k=130; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x27[i]; 
-	}
-
-	k=135; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x28[i]; 
-	}
-
-	k=140; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x29[i]; 
-	}
-
-	k=145; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x30[i]; 
-	}
-
-	k=150; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x31[i]; 
-	}
-
-	k=155; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x32[i]; 
-	}
-
-	k=160; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x33[i]; 
-	}
-
-	k=165; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x34[i]; 
-	}
-
-	k=170; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x35[i]; 
-	}
-
-	k=175; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x36[i]; 
-	}
-
-	k=180; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x37[i]; 
-	}
-
-	k=185; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x38[i]; 
-	}
-
-	k=190; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x39[i]; 
-	}
-
-	k=195; 
-	for( i=0; i<5; i++)
-	{ 
-		outputs[k++] = (real_T) output.x40[i]; 
-	}
-
-	
-}
-
-
-
-
-
-/* Function: mdlTerminate =====================================================
- * Abstract:
- *    In this function, you should perform any actions that are necessary
- *    at the termination of a simulation.  For example, if memory was
- *    allocated in mdlStart, this is the place to free it.
- */
-static void mdlTerminate(SimStruct *S)
-{
-}
-#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
-#include "simulink.c"      /* MEX-file interface mechanism */
-#else
-#include "cg_sfun.h"       /* Code generation registration function */
-#endif
-
-
Index: model/FORCENLPsolver/interface/FORCENLPsolver_py.py
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_py.py b/model/FORCENLPsolver/interface/FORCENLPsolver_py.py
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_py.py	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,412 +0,0 @@
-#FORCENLPsolver : A fast customized optimization solver.
-#
-#Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-#
-#
-#This software is intended for simulation and testing purposes only. 
-#Use of this software for any commercial purpose is prohibited.
-#
-#This program is distributed in the hope that it will be useful.
-#EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-#PARTICULAR PURPOSE. 
-#
-#EMBOTECH shall not have any liability for any damage arising from the use
-#of the software.
-#
-#This Agreement shall exclusively be governed by and interpreted in 
-#accordance with the laws of Switzerland, excluding its principles
-#of conflict of laws. The Courts of Zurich-City shall have exclusive 
-#jurisdiction in case of any dispute.
-#
-#def __init__():
-'''
-a Python wrapper for a fast solver generated by FORCESPRO v5.1.0
-
-   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
-   subject to the parameters supplied in the following dictionary:
-       PARAMS['xinit'] - column vector of length 3
-       PARAMS['x0'] - column vector of length 200
-       PARAMS['all_parameters'] - column vector of length 120
-       PARAMS['reinitialize'] - scalar
-
-   OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 5
-       OUTPUT['x02'] - column vector of size 5
-       OUTPUT['x03'] - column vector of size 5
-       OUTPUT['x04'] - column vector of size 5
-       OUTPUT['x05'] - column vector of size 5
-       OUTPUT['x06'] - column vector of size 5
-       OUTPUT['x07'] - column vector of size 5
-       OUTPUT['x08'] - column vector of size 5
-       OUTPUT['x09'] - column vector of size 5
-       OUTPUT['x10'] - column vector of size 5
-       OUTPUT['x11'] - column vector of size 5
-       OUTPUT['x12'] - column vector of size 5
-       OUTPUT['x13'] - column vector of size 5
-       OUTPUT['x14'] - column vector of size 5
-       OUTPUT['x15'] - column vector of size 5
-       OUTPUT['x16'] - column vector of size 5
-       OUTPUT['x17'] - column vector of size 5
-       OUTPUT['x18'] - column vector of size 5
-       OUTPUT['x19'] - column vector of size 5
-       OUTPUT['x20'] - column vector of size 5
-       OUTPUT['x21'] - column vector of size 5
-       OUTPUT['x22'] - column vector of size 5
-       OUTPUT['x23'] - column vector of size 5
-       OUTPUT['x24'] - column vector of size 5
-       OUTPUT['x25'] - column vector of size 5
-       OUTPUT['x26'] - column vector of size 5
-       OUTPUT['x27'] - column vector of size 5
-       OUTPUT['x28'] - column vector of size 5
-       OUTPUT['x29'] - column vector of size 5
-       OUTPUT['x30'] - column vector of size 5
-       OUTPUT['x31'] - column vector of size 5
-       OUTPUT['x32'] - column vector of size 5
-       OUTPUT['x33'] - column vector of size 5
-       OUTPUT['x34'] - column vector of size 5
-       OUTPUT['x35'] - column vector of size 5
-       OUTPUT['x36'] - column vector of size 5
-       OUTPUT['x37'] - column vector of size 5
-       OUTPUT['x38'] - column vector of size 5
-       OUTPUT['x39'] - column vector of size 5
-       OUTPUT['x40'] - column vector of size 5
-
-   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
-   the integer EXITFLAG indicating the state of the solution with 
-       1 - Optimal solution has been found (subject to desired accuracy)
-       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
-       0 - Timeout - maximum number of iterations reached
-      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
-      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
-      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
-      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
-     -10 - The convex solver could not proceed due to an internal error
-    -100 - License error
-
-   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns 
-   additional information about the last iterate:
-       INFO.it        - number of iterations that lead to this result
-       INFO.it2opt    - number of convex solves
-       INFO.res_eq    - max. equality constraint residual
-       INFO.res_ineq  - max. inequality constraint residual
-       INFO.pobj      - primal objective
-       INFO.dobj      - dual objective
-       INFO.dgap      - duality gap := pobj - dobj
-       INFO.rdgap     - relative duality gap := |dgap / pobj|
-       INFO.mu        - duality measure
-       INFO.sigma     - centering parameter
-       INFO.lsit_aff  - iterations of affine line search
-       INFO.lsit_cc   - iterations of line search (combined direction)
-       INFO.step_aff  - step size (affine direction)
-       INFO.step_cc   - step size (centering direction)
-       INFO.solvetime - Time needed for solve (wall clock time)
-
- See also COPYING
-
-'''
-
-import ctypes
-import os
-import numpy as np
-import numpy.ctypeslib as npct
-import sys
-
-#_lib = ctypes.CDLL(os.path.join(os.getcwd(),'FORCENLPsolver/lib/FORCENLPsolver.dll')) 
-try:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/FORCENLPsolver.dll'))
-    csolver = getattr(_lib,'FORCENLPsolver_solve')
-except:
-    _lib = ctypes.CDLL(os.path.join(os.path.dirname(os.path.abspath(__file__)),'FORCENLPsolver/lib/libFORCENLPsolver.dll'))
-    csolver = getattr(_lib,'FORCENLPsolver_solve')
-
-class FORCENLPsolver_params_ctypes(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [('xinit', ctypes.c_double * 3),
-('x0', ctypes.c_double * 200),
-('all_parameters', ctypes.c_double * 120),
-('reinitialize', ctypes.c_int),
-]
-
-FORCENLPsolver_params = {'xinit' : np.array([]),
-'x0' : np.array([]),
-'all_parameters' : np.array([]),
-'reinitialize' : np.array([]),
-}
-params = {'xinit' : np.array([]),
-'x0' : np.array([]),
-'all_parameters' : np.array([]),
-'reinitialize' : np.array([]),
-}
-FORCENLPsolver_params_types = {'xinit' : np.float64,
-'x0' : np.float64,
-'all_parameters' : np.float64,
-'reinitialize' : np.int32,
-}
-
-class FORCENLPsolver_outputs_ctypes(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [('x01', ctypes.c_double * 5),
-('x02', ctypes.c_double * 5),
-('x03', ctypes.c_double * 5),
-('x04', ctypes.c_double * 5),
-('x05', ctypes.c_double * 5),
-('x06', ctypes.c_double * 5),
-('x07', ctypes.c_double * 5),
-('x08', ctypes.c_double * 5),
-('x09', ctypes.c_double * 5),
-('x10', ctypes.c_double * 5),
-('x11', ctypes.c_double * 5),
-('x12', ctypes.c_double * 5),
-('x13', ctypes.c_double * 5),
-('x14', ctypes.c_double * 5),
-('x15', ctypes.c_double * 5),
-('x16', ctypes.c_double * 5),
-('x17', ctypes.c_double * 5),
-('x18', ctypes.c_double * 5),
-('x19', ctypes.c_double * 5),
-('x20', ctypes.c_double * 5),
-('x21', ctypes.c_double * 5),
-('x22', ctypes.c_double * 5),
-('x23', ctypes.c_double * 5),
-('x24', ctypes.c_double * 5),
-('x25', ctypes.c_double * 5),
-('x26', ctypes.c_double * 5),
-('x27', ctypes.c_double * 5),
-('x28', ctypes.c_double * 5),
-('x29', ctypes.c_double * 5),
-('x30', ctypes.c_double * 5),
-('x31', ctypes.c_double * 5),
-('x32', ctypes.c_double * 5),
-('x33', ctypes.c_double * 5),
-('x34', ctypes.c_double * 5),
-('x35', ctypes.c_double * 5),
-('x36', ctypes.c_double * 5),
-('x37', ctypes.c_double * 5),
-('x38', ctypes.c_double * 5),
-('x39', ctypes.c_double * 5),
-('x40', ctypes.c_double * 5),
-]
-
-FORCENLPsolver_outputs = {'x01' : np.array([]),
-'x02' : np.array([]),
-'x03' : np.array([]),
-'x04' : np.array([]),
-'x05' : np.array([]),
-'x06' : np.array([]),
-'x07' : np.array([]),
-'x08' : np.array([]),
-'x09' : np.array([]),
-'x10' : np.array([]),
-'x11' : np.array([]),
-'x12' : np.array([]),
-'x13' : np.array([]),
-'x14' : np.array([]),
-'x15' : np.array([]),
-'x16' : np.array([]),
-'x17' : np.array([]),
-'x18' : np.array([]),
-'x19' : np.array([]),
-'x20' : np.array([]),
-'x21' : np.array([]),
-'x22' : np.array([]),
-'x23' : np.array([]),
-'x24' : np.array([]),
-'x25' : np.array([]),
-'x26' : np.array([]),
-'x27' : np.array([]),
-'x28' : np.array([]),
-'x29' : np.array([]),
-'x30' : np.array([]),
-'x31' : np.array([]),
-'x32' : np.array([]),
-'x33' : np.array([]),
-'x34' : np.array([]),
-'x35' : np.array([]),
-'x36' : np.array([]),
-'x37' : np.array([]),
-'x38' : np.array([]),
-'x39' : np.array([]),
-'x40' : np.array([]),
-}
-
-
-class FORCENLPsolver_info(ctypes.Structure):
-#    @classmethod
-#    def from_param(self):
-#        return self
-    _fields_ = [("it", ctypes.c_int),
- ("res_eq", ctypes.c_double),
- ("rsnorm", ctypes.c_double),
- ("pobj", ctypes.c_double),
- ("solvetime", ctypes.c_double),
- ("fevalstime", ctypes.c_double),
- ("QPtime", ctypes.c_double)]
-
-class FILE(ctypes.Structure):
-        pass
-if sys.version_info.major == 2:
-    PyFile_AsFile = ctypes.pythonapi.PyFile_AsFile # problem here with python 3 http://stackoverflow.com/questions/16130268/python-3-replacement-for-pyfile-asfile
-    PyFile_AsFile.argtypes = [ctypes.py_object]
-    PyFile_AsFile.restype = ctypes.POINTER(FILE)
-
-# determine data types for solver function prototype 
-csolver.argtypes = ( ctypes.POINTER(FORCENLPsolver_params_ctypes), ctypes.POINTER(FORCENLPsolver_outputs_ctypes), ctypes.POINTER(FORCENLPsolver_info), ctypes.POINTER(FILE))
-csolver.restype = ctypes.c_int
-
-def FORCENLPsolver_solve(params_arg):
-    '''
-a Python wrapper for a fast solver generated by FORCESPRO v5.1.0
-
-   OUTPUT = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) solves a multistage problem
-   subject to the parameters supplied in the following dictionary:
-       PARAMS['xinit'] - column vector of length 3
-       PARAMS['x0'] - column vector of length 200
-       PARAMS['all_parameters'] - column vector of length 120
-       PARAMS['reinitialize'] - scalar
-
-   OUTPUT returns the values of the last iteration of the solver where
-       OUTPUT['x01'] - column vector of size 5
-       OUTPUT['x02'] - column vector of size 5
-       OUTPUT['x03'] - column vector of size 5
-       OUTPUT['x04'] - column vector of size 5
-       OUTPUT['x05'] - column vector of size 5
-       OUTPUT['x06'] - column vector of size 5
-       OUTPUT['x07'] - column vector of size 5
-       OUTPUT['x08'] - column vector of size 5
-       OUTPUT['x09'] - column vector of size 5
-       OUTPUT['x10'] - column vector of size 5
-       OUTPUT['x11'] - column vector of size 5
-       OUTPUT['x12'] - column vector of size 5
-       OUTPUT['x13'] - column vector of size 5
-       OUTPUT['x14'] - column vector of size 5
-       OUTPUT['x15'] - column vector of size 5
-       OUTPUT['x16'] - column vector of size 5
-       OUTPUT['x17'] - column vector of size 5
-       OUTPUT['x18'] - column vector of size 5
-       OUTPUT['x19'] - column vector of size 5
-       OUTPUT['x20'] - column vector of size 5
-       OUTPUT['x21'] - column vector of size 5
-       OUTPUT['x22'] - column vector of size 5
-       OUTPUT['x23'] - column vector of size 5
-       OUTPUT['x24'] - column vector of size 5
-       OUTPUT['x25'] - column vector of size 5
-       OUTPUT['x26'] - column vector of size 5
-       OUTPUT['x27'] - column vector of size 5
-       OUTPUT['x28'] - column vector of size 5
-       OUTPUT['x29'] - column vector of size 5
-       OUTPUT['x30'] - column vector of size 5
-       OUTPUT['x31'] - column vector of size 5
-       OUTPUT['x32'] - column vector of size 5
-       OUTPUT['x33'] - column vector of size 5
-       OUTPUT['x34'] - column vector of size 5
-       OUTPUT['x35'] - column vector of size 5
-       OUTPUT['x36'] - column vector of size 5
-       OUTPUT['x37'] - column vector of size 5
-       OUTPUT['x38'] - column vector of size 5
-       OUTPUT['x39'] - column vector of size 5
-       OUTPUT['x40'] - column vector of size 5
-
-   [OUTPUT, EXITFLAG] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns additionally
-   the integer EXITFLAG indicating the state of the solution with 
-       1 - Optimal solution has been found (subject to desired accuracy)
-       2 - (only branch-and-bound) A feasible point has been identified for which the objective value is no more than codeoptions.mip.mipgap*100 per cent worse than the global optimum 
-       0 - Timeout - maximum number of iterations reached
-      -1 - (only branch-and-bound) Infeasible problem (problems solving the root relaxation to the desired accuracy)
-      -2 - (only branch-and-bound) Out of memory - cannot fit branch and bound nodes into pre-allocated memory.
-      -6 - NaN or INF occured during evaluation of functions and derivatives. Please check your initial guess.
-      -7 - Method could not progress. Problem may be infeasible. Run FORCESdiagnostics on your problem to check for most common errors in the formulation.
-     -10 - The convex solver could not proceed due to an internal error
-    -100 - License error
-
-   [OUTPUT, EXITFLAG, INFO] = FORCENLPsolver_py.FORCENLPsolver_solve(PARAMS) returns 
-   additional information about the last iterate:
-       INFO.it        - number of iterations that lead to this result
-       INFO.it2opt    - number of convex solves
-       INFO.res_eq    - max. equality constraint residual
-       INFO.res_ineq  - max. inequality constraint residual
-       INFO.pobj      - primal objective
-       INFO.dobj      - dual objective
-       INFO.dgap      - duality gap := pobj - dobj
-       INFO.rdgap     - relative duality gap := |dgap / pobj|
-       INFO.mu        - duality measure
-       INFO.sigma     - centering parameter
-       INFO.lsit_aff  - iterations of affine line search
-       INFO.lsit_cc   - iterations of line search (combined direction)
-       INFO.step_aff  - step size (affine direction)
-       INFO.step_cc   - step size (centering direction)
-       INFO.solvetime - Time needed for solve (wall clock time)
-
- See also COPYING
-
-    '''
-    global _lib
-
-    # convert parameters
-    params_py = FORCENLPsolver_params_ctypes()
-    for par in params_arg:
-        try:
-            #setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='A')))
-            if isinstance(getattr(params_py, par), ctypes.Array):
-                params_arg[par] = np.require(params_arg[par], dtype=FORCENLPsolver_params_types[par], requirements='F')
-                setattr(params_py, par, npct.as_ctypes(np.reshape(params_arg[par],np.size(params_arg[par]),order='F')))
-            else:
-                setattr(params_py, par, params_arg[par])
-        except:
-            raise ValueError('Parameter ' + par + ' does not have the appropriate dimensions or data type. Please use numpy arrays for parameters.')
-    
-    outputs_py = FORCENLPsolver_outputs_ctypes()
-    info_py = FORCENLPsolver_info()
-    if sys.version_info.major == 2:
-        if sys.platform.startswith('win'):
-            fp = None # if set to none, the solver prints to stdout by default - necessary because we have an access violation otherwise under windows
-        else:
-            #fp = open('stdout_temp.txt','w')
-            fp = sys.stdout
-        try:
-            PyFile_AsFile.restype = ctypes.POINTER(FILE)
-            exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), PyFile_AsFile(fp)  )
-            #fp = open('stdout_temp.txt','r')
-            #print (fp.read())
-            #fp.close()
-        except:
-            #print 'Problem with solver'
-            raise
-    elif sys.version_info.major == 3:
-        if sys.platform.startswith('win'):
-            libc = ctypes.cdll.msvcrt
-        elif sys.platform.startswith('darwin'):
-            libc = ctypes.CDLL('libc.dylib')
-        else:
-            libc = ctypes.CDLL('libc.so.6')       # Open libc
-        cfopen = getattr(libc,'fopen')        # Get its fopen
-        cfopen.restype = ctypes.POINTER(FILE) # Yes, fopen gives a file pointer
-        cfopen.argtypes = [ctypes.c_char_p, ctypes.c_char_p] # Yes, fopen gives a file pointer 
-        fp = cfopen('stdout_temp.txt'.encode('utf-8'),'w'.encode('utf-8'))    # Use that fopen 
-
-        try:
-            if sys.platform.startswith('win'):
-                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), None )
-            else:
-                exitflag = _lib.FORCENLPsolver_solve( ctypes.byref(params_py), ctypes.byref(outputs_py), ctypes.byref(info_py), fp )
-            libc.fclose(fp)
-            fptemp = open('stdout_temp.txt','r')
-            print (fptemp.read())
-            fptemp.close()            
-        except:
-            #print 'Problem with solver'
-            raise
-
-    # convert outputs
-    for out in FORCENLPsolver_outputs:
-        FORCENLPsolver_outputs[out] = npct.as_array(getattr(outputs_py,out))
-
-    return FORCENLPsolver_outputs,int(exitflag),info_py
-
-solve = FORCENLPsolver_solve
-
-
Index: model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
===================================================================
diff --git a/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c b/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c
deleted file mode 100644
--- a/model/FORCENLPsolver/interface/FORCENLPsolver_objective_mex.c	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ /dev/null	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
@@ -1,241 +0,0 @@
-/*
-FORCENLPsolver : A fast customized optimization solver.
-
-Copyright (C) 2013-2021 EMBOTECH AG [info@embotech.com]. All rights reserved.
-
-
-This software is intended for simulation and testing purposes only. 
-Use of this software for any commercial purpose is prohibited.
-
-This program is distributed in the hope that it will be useful.
-EMBOTECH makes NO WARRANTIES with respect to the use of the software 
-without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
-PARTICULAR PURPOSE. 
-
-EMBOTECH shall not have any liability for any damage arising from the use
-of the software.
-
-This Agreement shall exclusively be governed by and interpreted in 
-accordance with the laws of Switzerland, excluding its principles
-of conflict of laws. The Courts of Zurich-City shall have exclusive 
-jurisdiction in case of any dispute.
-
-*/
-
-#include "mex.h"
-#include "math.h"
-#include <string.h>
-#include "../include/FORCENLPsolver.h"
-#ifndef SOLVER_STDIO_H
-#define SOLVER_STDIO_H
-#include <stdio.h>
-#endif
-
-typedef FORCENLPsolver_float solver_float;
-typedef solver_int32_default solver_int;
-#define NSTAGES ( 40 )
-#define MAX(X, Y)  ((X) < (Y) ? (Y) : (X))
-
-/* For compatibility with Microsoft Visual Studio 2015 */
-#if _MSC_VER >= 1900
-FILE _iob[3];
-FILE * __cdecl __iob_func(void)
-{
-	_iob[0] = *stdin;
-	_iob[1] = *stdout;
-	_iob[2] = *stderr;
-	return _iob;
-}
-#endif
-
-/* copy functions */
-
-void copyCArrayToM_FORCENLPsolver(FORCENLPsolver_float *src, double *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (double)*src++;
-    }
-}
-
-void copyCValueToM_FORCENLPsolver(FORCENLPsolver_float* src, double* dest)
-{
-    *dest = (double)*src;
-}
-
-void copyMArrayToC_FORCENLPsolver(double *src, FORCENLPsolver_float *dest, solver_int32_default dim) 
-{
-    solver_int32_default i;
-    for( i = 0; i < dim; i++ ) 
-    {
-        *dest++ = (FORCENLPsolver_float) (*src++) ;
-    }
-}
-
-void copyMValueToC_FORCENLPsolver(double * src, FORCENLPsolver_float * dest)
-{
-	*dest = (FORCENLPsolver_float) *src;
-}
-
-
-
-extern void (FORCENLPsolver_float *x, FORCENLPsolver_float *y, FORCENLPsolver_float *l, FORCENLPsolver_float *p, FORCENLPsolver_float *f, FORCENLPsolver_float *nabla_f, FORCENLPsolver_float *c, FORCENLPsolver_float *nabla_c, FORCENLPsolver_float *h, FORCENLPsolver_float *nabla_h, FORCENLPsolver_float *hess, solver_int32_default stage, solver_int32_default iteration, solver_int32_default threadID);
-FORCENLPsolver_extfunc pt2function_FORCENLPsolver = &;
-
-
-static void getDims(const solver_int stage, solver_int* nvar, solver_int* neq, solver_int* dimh, 
-             solver_int* dimp, solver_int* diml, solver_int* dimu, solver_int* dimhl, solver_int* dimhu)
-{
-    const solver_int nvarArr[NSTAGES] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}; 
-    const solver_int neqArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimhArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimpArr[NSTAGES] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-    const solver_int dimlArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    const solver_int dimhlArr[NSTAGES] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
-    const solver_int dimhuArr[NSTAGES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-    *nvar = nvarArr[stage];
-    *neq = neqArr[stage];
-    *dimh = dimhArr[stage];
-    *dimp = dimpArr[stage];
-    *diml = dimlArr[stage];
-    *dimu = dimuArr[stage];
-    *dimhl = dimhlArr[stage];
-    *dimhu = dimhuArr[stage];
-}
-
-/* Checks all inputs and returns stage number (1-indexed) */
-static void assignData(solver_int nrhs, const mxArray *prhs[], solver_int * const stage, solver_int * const nvar, solver_int * const neq, 
-                    solver_int * const dimh, solver_int * const dimp, solver_int * const diml, solver_int * const dimu, solver_int * const dimhl, solver_int * const dimhu)
-{
-    mxArray *arr;
-
-    if (nrhs > 3 || nrhs < 1)
-	{
-		mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "This function takes at least one input: z. And at most 3 inputs: z, p, stage.");
-	}     
-
-    // get stage
-    *stage = (solver_int) 1;
-    if (nrhs == 3)
-    {
-        arr = prhs[2];
-        if ( !mxIsDouble(arr) )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The third input (stage number) must be an integer.");
-        }
-        *stage = (solver_int) *mxGetPr(arr);
-    }
-    if ( *stage < 1 || (NSTAGES) < *stage )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Stage must be between %d and %d.", 1, (NSTAGES));
-    }    
-
-    /* Get other dimensions */
-    *stage -= 1; /* 0-indexed stages */
-    getDims(*stage, nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu);
-
-    /* Check that passed z and p have correct dims */  
-    arr = prhs[0];
-    if ( !mxIsDouble(arr) )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector.");
-    }    
-    if ( mxGetM(arr) != *nvar || mxGetN(arr) != 1 )
-    {
-        mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The first input (z) must be a column vector of length %d.", *nvar);
-    }
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( *dimp > 0 && mxIsEmpty(arr))
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-        }   
-        if ( !mxIsEmpty(arr) )
-        {
-            if ( !mxIsDouble(arr) )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector.");
-            }    
-            if ( mxGetM(arr) != *dimp || mxGetN(arr) != 1 )
-            {
-                mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "The second input (p) must be a column vector of length %d.", *dimp);
-            }            
-        }
-	}
-    else
-    {
-        if ( *dimp > 0 )
-        {
-            mexErrMsgIdAndTxt("FORCESPRO:IncorrectInputs", "Run time parameters are required as a second input for evaluating this fcn.");
-        }         
-    } 
-}
-
-/* THE mex-function */
-void mexFunction( solver_int nlhs, mxArray *plhs[], solver_int nrhs, const mxArray *prhs[] )  
-{
-	mxArray *arr;
-    solver_int nvar, neq, dimh, dimp, diml, dimu, dimhl, dimhu, stage, dimmul;
-
-    // Allocate memory 
-    solver_float *z, *p, *y, *l, *obj, *jacobj, *c, *jacc, *h, *jach, *hess;
-
-	mxArray* obj_mex;
-	mxArray* gradobj_mex;
-
-
-    // get data
-    assignData(nrhs, prhs, &stage, &nvar, &neq, &dimh, &dimp, &diml, &dimu, &dimhl, &dimhu);
-    dimmul = diml+dimu+dimhl+dimhu;
-
-    // Allocate memory 
-    z = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    p = (solver_float *) malloc(sizeof(solver_float)*MAX(dimp,1));
-    y = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    l = (solver_float *) malloc(sizeof(solver_float)*MAX(dimmul,1));
-    obj = (solver_float *) malloc(sizeof(solver_float));
-    jacobj = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar,1));
-    c = (solver_float *) malloc(sizeof(solver_float)*MAX(neq,1));
-    jacc = (solver_float *) malloc(sizeof(solver_float)*MAX(neq*nvar,1));
-    h = (solver_float *) malloc(sizeof(solver_float)*MAX(dimh,1));
-    jach = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*dimh,1));
-    hess = (solver_float *) malloc(sizeof(solver_float)*MAX(nvar*nvar,1));
-
-    /* Initialize all inputs */
-    arr = prhs[0];
-    copyMArrayToC_FORCENLPsolver(mxGetPr(arr), z, nvar);
-    if (nrhs > 1)
-	{
-        arr = prhs[1];
-        if ( !mxIsEmpty(arr) )
-        {
-            copyMArrayToC_FORCENLPsolver(mxGetPr(arr), p, dimp);
-        }
-	}   
-    memset(y, 0, sizeof(solver_float)*neq);
-    memset(l, 0, sizeof(solver_float)*dimmul);
-    memset(obj, 0, sizeof(solver_float));
-    memset(jacobj, 0, sizeof(solver_float)*nvar);
-    memset(c, 0, sizeof(solver_float)*neq);
-    memset(jacc, 0, sizeof(solver_float)*neq*nvar);
-    memset(h, 0, sizeof(solver_float)*dimh);
-    memset(jach, 0, sizeof(solver_float)*dimh*nvar);
-    memset(hess, 0, sizeof(solver_float)*nvar*nvar);
-
-    // Evaluate fcns and read output into mex format
-	(z, y, l, p, obj, jacobj, c, jacc, h, jach, hess, stage, 0, 0);
-	obj_mex = mxCreateDoubleMatrix(1, 1, mxREAL);
-	gradobj_mex = mxCreateDoubleMatrix(nvar, 1, mxREAL);
-	copyCArrayToM_FORCENLPsolver(obj, mxGetPr(obj_mex), 1);
-	copyCArrayToM_FORCENLPsolver(jacobj, mxGetPr(gradobj_mex), nvar);
-	plhs[0] = obj_mex;
-	plhs[1] = gradobj_mex;
-
-
-    // Free memory
-    free(z); free(p); free(y); free(l); free(obj); free(jacobj); free(c); free(jacc); free(h); free(jach); free(hess);
-}
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.9 (MPC)\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ b/.idea/misc.xml	(date 1646640285573)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9 (MPC)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.6 (cs285)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/MPC_final_project.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\" />\n    <content url=\"file://$MODULE_DIR$/../../forces_pro_client\">\n      <sourceFolder url=\"file://$MODULE_DIR$/../../forces_pro_client\" isTestSource=\"false\" />\n    </content>\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.9 (MPC)\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n  <component name=\"PyDocumentationSettings\">\n    <option name=\"format\" value=\"PLAIN\" />\n    <option name=\"myDocStringFormat\" value=\"Plain\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/MPC_final_project.iml b/.idea/MPC_final_project.iml
--- a/.idea/MPC_final_project.iml	(revision 8f53df455055f024e63b9795f7d7960674f4db9b)
+++ b/.idea/MPC_final_project.iml	(date 1646640285569)
@@ -5,7 +5,7 @@
     <content url="file://$MODULE_DIR$/../../forces_pro_client">
       <sourceFolder url="file://$MODULE_DIR$/../../forces_pro_client" isTestSource="false" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.9 (MPC)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.6 (cs285)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="PyDocumentationSettings">
